!######################################################################
!
! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! Sterrewacht Leiden, The Netherlands
!
! HISTORY:
!
! V1.4: MC Verification of intrinsic velocity moments calculation.
!     Fixed significant bug in mergrid_store. Slightly revised 
!     implementation
!     to make it easier to check. Independent test of the results 
!      still needed
! V2.0: RvdB. Fork for the Triaxial orbit library code.
! V2.0.1 : Changed quadrant grid bins to have more bins.
! V2.0.2 : fix 10**rlogmax in bin setup of qgrid_setup
!          add internal moments
! V2.0.3 : change the zeroth moment grid
! V2.0.4 : add zero psf routine
!          fixed projection
! V3.0.0 : Make intrinisic grid size recipe to be able to numerically  
!          Fit the intrinsic mass.
!     RvdB, Leiden, oktober/2005
!
!######################################################################
! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! Sterrewacht Leiden, The Netherlands

module random_gauss_generator
  use numeric_kinds
  implicit none
  private

  ! Seeds the NR random generator
  public :: random_gauss_seed

  ! F version of the gaussian random generator
  ! generate gaussians for a n*m*o array with a width
  public :: random_gauss

  !Generate one 2d gaussian deviate with sigma "width"
  private :: gaussdev

contains

! adapted from NR2.
! Internal computation in SP for speed
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine  gaussdev(x)
    real (kind=dp), intent(out), dimension(:) :: x
    !----------------------------------------------------------------------
    real (kind=sp), dimension(2) :: v
    real (kind=sp) :: rsq

    do
       call random_number(v)
       v = 2.0_sp*v - 1.0_sp
       rsq = sum(v**2)
       if (rsq > 0.0_sp .and. rsq < 1.0_sp) exit
    end do
    x = v*sqrt(-2.0_sp*log(rsq)/rsq)

  end subroutine gaussdev

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine random_gauss_seed()
  !----------------------------------------------------------------------
    logical, save :: initialized = .false.

    print*,"  * Seeding native Random generator"
    if (.not. initialized) then
      call random_seed()
      print*,"  * Internal Compiler random functions needs to be checked."
      initialized =  .true.
    end if

  end subroutine random_gauss_seed

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine random_gauss(t)
    real    (kind = dp ), dimension(:,:), intent(out) :: t
  !----------------------------------------------------------------------
    integer (kind = i4b)                              :: k

    do k=1,size(t,1)
        call gaussdev( t(k,:) )
    end do

  end subroutine random_gauss

end module random_gauss_generator

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $
! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! Sterrewacht Leiden, The Netherlands

module integrator
  ! Integrator module. Integrates a point in the MGE potential
  use numeric_kinds
  implicit none
  private

  public  :: integrator_integrate

  public  :: integrator_setup,integrator_set_current

  public  :: integrator_stop,integrator_find_orbtype

  public  :: integrator_setup_write,integrator_write

  private :: real_integrator

  ! current orbit
  integer (kind=i4b),public :: integrator_current

  ! contains the number of points generated by the integrator
  integer (kind=i4b),public :: integrator_points

  ! Starting point to begin with
  integer (kind=i4b),private :: integrator_start

  ! Number of different orbits
  integer (kind=i4b),private :: integrator_number

  ! Number of orbits to integrate for each orbit
  real (kind=dp), private :: integrator_n_orbits

  ! accuracy of integrator
  real (kind=dp),private :: integrator_accuracy

  ! Number of orbit ditherings
  integer (kind=i4b),public :: integrator_dithering


  ! is the current orbital set not regularizble?
  integer (kind=i4b),public :: totalnotregularizable

  ! temporary pos and velocity array for the dense output of the integrator
  real (kind=dp),private,allocatable,dimension(:,:) :: vel_t,pos_t

  ! functions and variables copied from original orblib
  private :: integrator_whichorbit,derivs,SOLOUT
  public :: ini_integ

  ! information about the initial conditions for the orbit integration,
  ! and the grid in integral space.
  real (kind=dp),private,allocatable,dimension(:) :: xini,yini,zini
  real (kind=dp),private,allocatable,dimension(:) :: vxini,vzini
  real (kind=dp),public ,allocatable,dimension(:) :: vyini,rcirc
  real (kind=dp),private,allocatable,dimension(:) :: vcirc,tcirc
  integer (kind=i4b), private,allocatable, dimension(:) :: regurizable

  integer (kind=i4b), private,allocatable, dimension(:) :: gEner,gI2,gI3
 
  integer (kind=i4b), public ::  nEner,nI2,nI3

  integer(kind=i4b),dimension(:),allocatable,private :: integrator_orbittypes
  real (kind=dp),private,allocatable,dimension(:,:)  ::  integrator_moments

   ! store the previously integrated orbit
   real    (kind=dp ),private,allocatable,dimension(:,:) :: pos_old, vel_old

contains

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine integrator_set_current(orbit)
    integer (kind=i4b) ,intent(in):: orbit
  !----------------------------------------------------------------------
    integrator_current=orbit
    Print*,"  * Starting at orbit", orbit+1
    if (orbit < 0) stop " Can't start at that orbit"
    if (orbit > (nEner*nI2*nI3/integrator_dithering**3) -1) &
         stop " Not so many orbits"

  end subroutine integrator_set_current

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine integrator_setup()
  use initial_parameters , only : iniparam,orbit_dithering
  !use triaxpotent, only : tp_setup
  use interpolpot       , only : ip_setup
  !----------------------------------------------------------------------
  integer(kind=i4b) :: ndith3
    print*,"  ** Setting up integrator module"
    print*,"  * Calling MGE setup"
    call iniparam()
    call ip_setup()
    call ini_integ()
    print*,"  * How many orbits should be integrated?"
    read *,    integrator_n_orbits
    print*,"    ",integrator_n_orbits
    if (integrator_n_orbits < 1) stop " Too few orbits"
    print*,"  * How many points should be generated per starting point?"
    read *,integrator_points
    print*,"    ", integrator_points
    integrator_dithering=orbit_dithering
    ndith3=integrator_dithering**3
    allocate(integrator_orbittypes(ndith3))
    allocate(integrator_moments(5,ndith3))
    if (integrator_points < 1) stop " Too few points"
    print*,"  * At which starting point should be started?"
    read *,integrator_start
    print*,"    ",integrator_start
    call integrator_set_current(integrator_start-1)
    print*,"  * How many starting points should be integrated?"
    read *, integrator_number
    print*,"    ",integrator_number
    if (integrator_number == -1) integrator_number= &
         (nEner*nI2*nI3/integrator_dithering**3)

    if (integrator_number <  1) stop " To few starting points"
    if (integrator_number >  &
         (nEner*nI2*nI3/integrator_dithering**3)) &
         & stop " Too many orbits in total"
    print*,"  * How great should te accuracy be of the integrator?"
    read *,integrator_accuracy
    print*,"    ",integrator_accuracy
    if (integrator_accuracy < 0 .or. 0.5 < integrator_accuracy) &
      & stop " wrong accuracy"

     print*,"  ** integrator module setup finished"


     
    
  end subroutine integrator_setup

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine integrator_stop()
  !----------------------------------------------------------------------
    if (allocated( xini )) then
       deallocate(xini,yini,zini,vxini,vyini,vzini,gener,gi2,gi3,&
            vcirc,tcirc,rcirc,regurizable,vel_old,pos_old)
    endif

   if  (allocated(pos_old)) then
         deallocate(pos_old,vel_old)
         deallocate(pos_t,vel_t)
    endif 
    
  close (unit=30)
  end subroutine integrator_stop

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine integrator_integrate(pos,vel,otype,done,first,alldone)
    logical           ,intent(out):: done,alldone
    logical           ,intent(in):: first
    real    (kind=dp ),intent(out),dimension(integrator_points,3) :: pos
    real    (kind=dp ),intent(out),dimension(integrator_points,3) :: vel
    integer (kind=i4b),intent(out) :: otype
    integer (kind=i4b),save :: dith=0
    integer (kind=i4b)    :: temporbit        
    real    (kind=dp ),dimension(5) :: moments
  !----------------------------------------------------------------------
    if (first) then 
       integrator_current=integrator_current+1
       dith=0
       totalnotregularizable=0
       print*,"  * Starting integrating :",integrator_current
    end if
    dith=dith+1
    if (dith <= integrator_dithering**3 .and. &
         integrator_current <= integrator_number) then 

       call integrator_whichorbit(integrator_current,dith,temporbit)
              
       ! check if there is an unregurizable compenent in this set
       if (regurizable(temporbit) == 1) totalnotregularizable=1
       !print*,"  * Starting integrating :",integrator_current,dith,temporbit
       call real_integrator (temporbit,pos,vel)
       call integrator_find_orbtype(otype,moments,pos,vel)
       integrator_orbittypes(dith)=otype     
       integrator_moments(:,dith)=moments
       done=.false.
    else
       ! integrating done. Set 'done' to true and return.
       pos(:,:)=0.0_dp
       vel(:,:)=0.0_dp
       done=.true.  
    end if

    if (integrator_current > integrator_number) alldone=.true.
 
  end subroutine integrator_integrate

!  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!  subroutine integrator_integrate_nodith(pos,vel,otype,done,first,alldone)
!    logical           ,intent(out):: done,alldone
!    logical           ,intent(in):: first
!    real    (kind=dp ),intent(out),dimension(integrator_points,3) :: pos
!    real    (kind=dp ),intent(out),dimension(integrator_points,3) :: vel
!    integer (kind=i4b),intent(out) :: otype
!    integer (kind=i4b),save :: dith=0
!    integer (kind=i4b)    :: temporbit
!  !----------------------------------------------------------------------
!    if (first) then 
!       integrator_current=integrator_current+1
!       dith=(integrator_dithering**3)/2+1
!       totalnotregularizable=0
!       print*,"  * Starting integrating :",integrator_current
!    endif
!    if (first .and. &
!         integrator_current <= integrator_number) then 
!
!       call integrator_whichorbit(integrator_current,dith,temporbit)
!              
!       ! check if there is an unregurizable compenent in this set
!       if (regurizable(temporbit) == 1) totalnotregularizable=1
!       print*,"  * Starting integrating :",integrator_current,dith,temporbit
!       call real_integrator (temporbit,pos,vel)
!       call integrator_find_orbtype(otype,pos,vel)
!       integrator_orbittypes(dith)=otype
!       done=.false.
!    else
!       ! integrating done. Set 'done' to true and return.
!       pos(:,:)=0.0_dp
!       vel(:,:)=0.0_dp
!       done=.true.  
!    end if
!
!    if (integrator_current > integrator_number) alldone=.true.
!
!  end subroutine integrator_integrate_nodith

! This routines finds the orbit dither number 
  subroutine integrator_whichorbit(orbit,dith,dithorbit)
    integer (kind=i4b),intent(in)      :: orbit,dith
    integer (kind=i4b),intent(out)     :: dithorbit
    integer (kind=i4b) :: E1,I2,I3,nd
    integer (kind=i4b) :: d1,d2,d3,DO1,DO2,DO3

    nd=integrator_dithering
    ! Reconstruct E, I2 and I3 number from orbit number:
    I3 = modulo( (orbit-1)                      , nI3/nd) + 1 
    I2 = modulo(((orbit-1) / (nI3     /nd    )) , nI2/nd) + 1
    E1 =        ((orbit-1) / (nI3*nI2/(nd*nd)))          + 1 
    ! Find which orbit dither we are currently at:
    d3 = modulo( (dith-1)            , nd) + 1
    d2 = modulo(((dith-1) /  nd    ) , nd) + 1
    d1 =        ((dith-1) / (nd*nd))       + 1 
    ! combine previous results to find the undithered orbit number
    DO3= (I3-1)*nd + d3 
    DO2= (I2-1)*nd + d2
    DO1= (E1-1)*nd + d1
    dithorbit = DO3 + ((DO2-1) * nI3)  + ((do1-1)*nI3*nI2)
  end subroutine integrator_whichorbit
 
  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine real_integrator(orbit,pos,vel)
    integer (kind=i4b),intent(in )                                :: orbit
    real    (kind=dp ),intent(out),dimension(integrator_points,3) :: pos
    real    (kind=dp ),intent(out),dimension(integrator_points,3) :: vel
  !----------------------------------------------------------------------
    integer (kind=i4b) :: IOUT,IDID,ITOL,i,l
    integer (kind=i4b),parameter :: N=6,NRDENS=6,LWORK=11*N+8*NRDENS+21
    integer (kind=i4b),parameter :: LIWORK = NRDENS+21
    real    (kind=dp ) :: X,Xend,RTOL,ATOL
    real    (kind=dp ), dimension(6) :: Y
    real    (kind=dp ), dimension(lwork ) :: WORK
    integer (kind=i4b), dimension(liwork) :: IWORK
    real    (kind=dp ), dimension(2) :: RPAR
    integer (kind=i4b), dimension(1) :: IPAR
    real    (kind=dp ),save :: stepsize=0.0_dp
    real    (kind=dp ) :: Ebeg,Eend
    integer (kind=i4b),save :: stored_orbit=0

   if (.NOT. allocated(pos_old)) then
       ! setting up the array for storing the points.
       allocate (pos_old(integrator_points,3),vel_old(integrator_points,3))
       allocate (pos_t  (integrator_points,3),vel_t  (integrator_points,3))

   else
       if (integrator_points /= size(pos_old,1)) then
         deallocate (pos_old,vel_old,pos_t,vel_t)
         allocate (pos_old(integrator_points,3),vel_old(integrator_points,3))
         allocate (pos_t  (integrator_points,3),vel_t  (integrator_points,3))
         ! Reset the flag to indicate that we do not have an orbit stored.
         stored_orbit=0
       endif
   endif

   ! --- REQUIRED TOLERANCE
   ! The integrator keeps the local error on Y(I)
   ! below RTOL(I)*ABS(Y(I)) + ATOL(I).
   ITOL = 0 ! Tolerances are scalars
   RTOL = integrator_accuracy
   ATOL = integrator_accuracy!/10000.0_dp
   ! The Absolutie Tolerance used to be set-up as a vector 
   ! ATOL= 1e-6* (/ rcirc(orbit), rcirc(orbit), rcirc(orbit), &
   !                   vcirc(orbit), vcirc(orbit), vcirc(orbit) /)

   Y(1) =  xini(orbit)  !  x(0)
   Y(2) =  yini(orbit)  !  y(0)
   Y(3) =  zini(orbit)  !  z(0)
   Y(4) = vxini(orbit)  ! vx(0)       
   Y(5) = vyini(orbit)  ! vy(0) 
   Y(6) = vzini(orbit)  ! vz(0) 

   ! Compute and store start energy at begin point
   call computer_energy(Y,Ebeg)

   DO  ! While integrating has not succeeded
    ! setting up the array for storing the points.
    ! --- DIMENSION OF THE SYSTEM
    IDID=0
    ! --- OUTPUT ROUTINE (AND DENSE OUTPUT) IS USED DURING INTEGRATION
    IOUT=2 
    ! --- INITIAL VALUES
    X=0.0

    Y(1) =  xini(orbit)  !  x(0)
    Y(2) =  yini(orbit)  !  y(0)
    Y(3) =  zini(orbit)  !  z(0)
    Y(4) = vxini(orbit)  ! vx(0)       
    Y(5) = vyini(orbit)  ! vy(0) 
    Y(6) = vzini(orbit)  ! vz(0) 
     
    
    ! --- ENDPOINT OF INTEGRATION
    XEND = integrator_n_orbits * tcirc(orbit)
    ! Stepsize. Make sure enough steps are in the integration by adding
    ! room for a couple of  extra steps. RvdB 19/12/04
    RPAR(2) = XEND/(integrator_points+4)
    RPAR(1) = 0.0 ! Unused

    ! --- VALUES FOR PARAMETERS
    ! Default values are used when IWORK or WORK are zero
    IWORK(:)=0
     WORK(:)=0.0_dp
    ! Maximum of allowed steps (just really high) (100000)
    IWORK(1)=  max(floor(min(dble(huge(1_i4b)-1),1.0_dp/RTOL*integrator_n_orbits/200),kind=i4b) , 100000_i4b)
    !number of dense components needed. (all in our case)
    IWORK(5)=NRDENS
    !stiffness detection (negative --> do not try to detect)
    IWORK(4)=-1
    !give guess of stepsize
    WORK(7) = stepsize

    !CALL OF THE SUBROUTINE DOPRI8 ( The dop853 integrator.)
    CALL DOP853(N,derivs,X,Y,XEND, RTOL,ATOL,ITOL, SOLOUT,IOUT, &
         &                  WORK,LWORK,IWORK,LIWORK,RPAR,IPAR,IDID)

!   IPAR(1)    COUNT   NUMBER OF STORED INTEGRATION STEPS IN pos_t AND vel_t
!   IWORK(17)  NFCN    NUMBER OF FUNCTION EVALUATIONS
!   IWORK(18)  NSTEP   NUMBER OF COMPUTED STEPS
!   IWORK(19)  NACCPT  NUMBER OF ACCEPTED STEPS
!   IWORK(20)  NREJCT  NUMBER OF REJECTED STEPS (DUE TO ERROR TEST),
!                      (STEP REJECTIONS IN THE FIRST STEP ARE NOT COUNTED)
!   print*,"  * Integrator output"
!   print*,iwork(17:20)

    ! compute final energy
    call computer_energy(Y,Eend)

    select case (IDID)
    case (-1)
       stop    "integrator:  INPUT IS NOT CONSISTENT,"
    case (-2)
       print*, "integrator:  LARGER NMAX IS NEEDED,"
    case (-3)
       print*, "integrator:  STEP SIZE BECOMES TOO SMALL."
    case (-4)
       stop    "integrator:  PROBLEM IS PROBABLY STIFF (INTERRUPTED)."
    case default
       ! Integrating went ok!
       
       if (abs((Ebeg-Eend)/Ebeg) .lt. 0.01) then 
         ! If Integration conserved energy within 1 percent then do 
         !   - Store pos and vel as failsafe for next orbit integration
         !   - Swap the points to the correct array.
         pos(:,:)     = pos_t(:,:)
         pos_old(:,:) = pos_t(:,:)
         vel_old(:,:) = vel_t(:,:)
         vel(:,:)     = vel_t(:,:)
         stored_orbit = 1
         stepsize=work(7)  ! Store integrater stepsize for next itegration
         EXIT  ! integration was succesfull
         endif
       print*, "Energy conserved to ",(Ebeg-Eend)/Ebeg*100.0_dp,", Increasing integrator accuracy"
    end select

  if (RTOL .lt. 1e-12_dp) then
    print*,'  * orbit ', orbit,' failed. Energy conserved up to ',(Ebeg-Eend)/Ebeg*100.0_dp 
    ! Orbit integration unsuccesfull even at higher accuracy
    if (stored_orbit .eq. 0) stop 'Abort, No backup orbit stored'
    pos_t(:,:) = pos_old(:,:)
    vel_t(:,:) = vel_old(:,:)
    EXIT ! Integration not succesfull
  endif 
    
    ! Increase accuracy and try again.
    RTOL = RTOL * 0.1_dp 
    ATOL = ATOL * 0.1_dp 
    
    print*,'  * Retrying orbit', orbit
end do

end subroutine real_integrator

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine integrator_setup_write(handle)
    integer (kind=i4b),intent(in) :: handle
    integer (kind=i4b)            :: t1,t2,t3,t4
  !----------------------------------------------------------------------
  print*,"  * Writing integrator output header"
  t1=  (nEner*nI2*nI3/integrator_dithering**3)
  t2= nEner/integrator_dithering
  t3= nI2/integrator_dithering
  t4= nI3/integrator_dithering
    write (unit=handle) t1,t2,t3,t4,integrator_dithering
 
 write (unit=30, fmt=*) Nener*ni2*ni3, integrator_dithering**3

  end subroutine integrator_setup_write

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine integrator_write(hdl)
    integer (kind=i4b),intent(in) :: hdl
  !----------------------------------------------------------------------
    integer (kind=i4b)            :: nd,orbit,I3,I2,E1
    orbit=integrator_current

    nd=integrator_dithering
    ! Reconstruct E, I2 and I3 number from orbit number:
    I3 = modulo( (orbit-1)                      , nI3/nd) + 1 
    I2 = modulo(((orbit-1) / (nI3     /nd    )) , nI2/nd) + 1
    E1 =        ((orbit-1) / (nI3*nI2/(nd*nd)))           + 1 

    ! write information about the orbit
    write (unit=hdl) orbit, E1,I2,I3,totalnotregularizable
    write (unit=hdl) integrator_orbittypes(:)

   write (unit=30, fmt="(25es13.5)") integrator_moments(:,:)  
  end subroutine integrator_write

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine ini_integ()
  !----------------------------------------------------------------------
    character (len=30) :: infil
    integer (kind=i4b) :: i

    print*, "  * Give name of file with begin conditions"
    read (unit=*, fmt="(a30)") infil
    print*,"   ",infil
    open (unit=31,file=infil,status="OLD",action="read",position="rewind")

    read (unit=31, fmt=*) nEner,nI2,nI3

    i = nEner*nI2*nI3
    
    print*," * Orbits in the input file"
    print*,nEner,nI2,nI3,i
    
    IF( .NOT. ALLOCATED( xini ) ) &
         allocate (xini(i),yini(i),zini(i),vxini(i),vyini(i),vzini(i),rcirc(i),&
         tcirc(i),vcirc(i),gEner(i),gI2(i),gI3(i),regurizable(i) )

    read (unit=31, fmt="(3I5,9ES30.10,I4)") (gener(i),gi2(i),gi3(i),xini(i),&
         yini(i),zini(i),vxini(i),vyini(i),vzini(i),rcirc(i),tcirc(i),&
         vcirc(i), regurizable(i), & 
         i=1,nEner*nI2*nI3)

    close (unit=31)

  end subroutine ini_integ


  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine derivs (N,xin,yin,dydx,RPAR,IPAR)
    use interpolpot, only : ip_accel
    !use triaxpotent, only : tp_accel
    integer           ,intent(in   )              :: N
    real    (kind=dp ),intent(in   )              :: xin
    real    (kind=dp ),intent(in   ),dimension(6) :: yin
    real    (kind=dp ),intent(out  ),dimension(6) :: dydx
    real    (kind=dp ),intent(inout),dimension(2) :: RPAR
    integer (kind=i4b),intent(inout),dimension(1) :: IPAR
  !----------------------------------------------------------------------

    ! subroutine which returns the right-hand side derivatives.
    !   x      = t
    !   yin(1) = x
    !   yin(2) = y
    !   yin(3) = z
    !   yin(4) = dx/dt
    !   yin(5) = dy/dt
    !   yin(6) = dz/dt

    ! First calculate the true accelerations at the given position
    dydx(1:3) = yin(4:6)
    call ip_accel(yin(1),yin(2),yin(3),dydx(4),dydx(5),dydx(6))

  end subroutine derivs

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  SUBROUTINE SOLOUT (NR,XOLD,X,Y,N,CON,ICOMP,ND,RPAR,IPAR,IRTRN)
    ! --- PRINTS SOLUTION AT EQUIDISTANT OUTPUT-POINTS
    ! --- BY USING "CONTD8", THE CONTINUOUS COLLOCATION SOLUTION
    integer          ,intent(in)    :: NR,N,ND
    real   (kind=dp ),intent(in)    :: XOLD,X
    integer          ,intent(inout) :: IRTRN
    real   (kind=dp ),intent(in)   ,dimension(N)    :: Y
    real   (kind=dp ),intent(in)   ,dimension(8*ND) :: CON
    integer(kind=i4b),intent(in)   ,dimension(ND)   :: ICOMP
    real   (kind=dp ),intent(inout),dimension(2)    :: RPAR
    integer(kind=i4b),intent(inout),dimension(1)    :: IPAR
  !----------------------------------------------------------------------
    real   (kind=dp ),save          :: XOUT
    integer(kind=i4b),save          :: count=0
    real   (kind=dp )               :: contd8,step,rnd
    step=RPAR(2)
    IF (NR == 1) THEN
       ! Start storing the orbit after 1+? steps to avoid aliasing
       call random_number(rnd) ! 0 < rnd < 1    
       XOUT=X+step*(1.0_dp+rnd)
       count=0
       IPAR(1)=0
    ELSE
       do
          ! Make sure count > integrator_points to make sure we do not
          ! go out of bounds on pos_t(:,:). RvdB, DK 16/06/03
          IF (X < XOUT .or. count >= integrator_points) exit
          count = count+1
          IPAR(1) = count
          pos_t(count,1) = CONTD8(1,XOUT,CON,ICOMP,ND)
          pos_t(count,2) = CONTD8(2,XOUT,CON,ICOMP,ND)
          pos_t(count,3) = CONTD8(3,XOUT,CON,ICOMP,ND)
          vel_t(count,1) = CONTD8(4,XOUT,CON,ICOMP,ND)
          vel_t(count,2) = CONTD8(5,XOUT,CON,ICOMP,ND)
          vel_t(count,3) = CONTD8(6,XOUT,CON,ICOMP,ND)
          XOUT = XOUT + step
       end do
    END IF
  END SUBROUTINE SOLOUT


 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 subroutine integrator_find_orbtype(type,moments,pos,vel)
   integer(kind=i4b), intent(out) :: type 
   real (kind=dp),intent(out),dimension(:            ) :: moments
   real (kind=dp),intent(in ),dimension(:,:          ) :: pos
   real (kind=dp),intent(in ),dimension(size(pos,1),3) :: vel
 !----------------------------------------------------------------------
   real (kind=dp) :: lxc,lyc,lzc
   real (kind=dp),dimension(size(pos,1)) :: t
   real (kind=dp),parameter :: nul=0.0_dp
   !  Lx = y*Vz-z*Vy
   t= pos(:,2) * vel(:,3) - pos (:,3) * vel(:,2)
   lxc=maxval(t)*minval(t)
   moments(1)=sum(t)/size(pos,1)                          

   !  Ly = z*Vx-x*Vz
   t= pos(:,3) * vel(:,1) - pos (:,1) * vel(:,3)
   lyc=maxval(t)*minval(t)
   moments(2)=sum(t)/size(pos,1)                          

   !  Lz = x*Vy-y*Vx
   t= pos(:,1) * vel(:,2) - pos (:,2) * vel(:,1)
   lzc=maxval(t)*minval(t)
   moments(3)=sum(t)/size(pos,1)                          

   ! assume orbit is chaotic, unless proven otherwise.
   type=5

   ! X tube
   if (lxc > nul .and. lyc < nul .and. lzc < nul ) type=1
   ! Y tube
   if (lxc < nul .and. lyc > nul .and. lzc < nul ) type=2
   ! Z tube
   if (lxc < nul .and. lyc < nul .and. lzc > nul ) type=3
   ! Box
   if (lxc < nul .and. lyc < nul .and. lzc < nul ) type=4       

   ! vector lenghts should be equal, otherwise DIM  is wrong
   !print*,size(sum(pos(:,:)**2,dim=2)) ,  size(pos,1)

   ! mean radius
   moments(4)= sum(sqrt(sum(pos(:,:)**2,dim=2)))/ size(pos,1)  

   ! second moment = vxx+vyy+vzz + 2vxy + 2vyz +2vzx
   moments(5)= sum(  sum(vel(:,:)**2,dim=2) + 2*(vel(:,1)*vel(:,2) + vel(:,2)*vel(:,3)+vel(:,3)*vel(:,1)))/ size(pos,1)
   
   !print*,moments(3),moments(5),moments(3)/moments(4)/sqrt(moments(5))
 end subroutine integrator_find_orbtype

subroutine computer_energy(Y,E)
! Compute the energy of a particle.
  use interpolpot, only : ip_potent
  real(kind=dp),intent(in),dimension(6) :: Y
  real(kind=dp),intent(out) :: E
  real(kind=dp) :: ep
  call ip_potent(y(1),y(2),y(3),Ep) 
  E=ep-0.5_dp*(y(4)**2+y(5)**2+y(6)**2)
end subroutine computer_energy

end module integrator

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! july 2002 Sterrewacht Leiden.

module projection
  ! module doing the circular projection of the orbit.
  use numeric_kinds
  implicit none
  private

  ! Number of projections around axis
  integer (kind=i4b), private :: proj_number

  ! Readin the number of rotation to be done.
  public :: projection_setup,projection_change_direction


  ! stop projection module
  public :: projection_stop

  ! Project pos(3,:),vel(3,:) to proj(2,:),lofvel(:)
  ! Using the n'th projection
  private :: project_n

  ! Project pos(3,:),vel(3,:) to proj(2,:),lofvel(:)
  !Done is set to .true. if all projections are finished
  public :: project

  ! amount of symmetry multipication. ( for triaxial galaxies there are
  ! 8 symmetries per orbit, but we do one (1) at a time.)
  integer (kind=i4b),public,parameter :: projection_symmetry=1

  real    (kind=dp),public :: theta_proj,phi_proj,psi_proj

contains

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine projection_setup()
    use initial_parameters, only : theta_view, phi_view,psi_view
  !----------------------------------------------------------------------
    print*,"  ** Projection setup"
    print*,"  * 8 Projections for Triaxial model"
    proj_number=8
    print*,"  * Inclination of the model is (theta,phi): ", theta_view,phi_view,psi_view
    theta_proj=theta_view
    phi_proj=phi_view
    psi_proj=psi_view
    print*, theta_proj,phi_proj,psi_proj
    print*,"  ** Projection setup finished"

  end subroutine projection_setup

  subroutine projection_change_direction()
  !----------------------------------------------------------------------
    real (kind=dp)              :: t1, t2, t3
    print*,"  ** Projection change direction"
    print*,"  * deprojection angles are (theta,phi,psi): ", &
          theta_proj/(pi_d/180.0_dp),phi_proj/(pi_d/180.0_dp),&
         psi_proj/(pi_d/180.0_dp)
    print*,"  * Give new angles (theta, phi, psi):"
    print*,"  * Anwser -501 0 0 to keep current values"
    read *,t1,t2,t3
    print*,t1,t2,t3
    if (t1 > -500 ) then
       theta_proj = t1*(pi_d/180.0_dp)
       phi_proj   = t2*(pi_d/180.0_dp)
       psi_proj   = t3*(pi_d/180.0_dp)
    endif
    print*,"  * New deprojection angles are (theta,phi,psi): ", &
         theta_proj/(pi_d/180.0_dp),phi_proj/(pi_d/180.0_dp),&
         psi_proj/(pi_d/180.0_dp)

    print*, theta_proj,phi_proj,psi_proj

  end subroutine projection_change_direction


  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine projection_stop()
  !----------------------------------------------------------------------
  ! empty function

  end subroutine projection_stop

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine project_n(type,pos,vel,proj,losvel,n)
!  use initial_parameters, only : theta_view, phi_view
    ! pos( :, (r,z) )
    real (kind=dp),intent(in ),dimension(:        ,:)   :: pos
    ! vel (:, (r,z,theta))
    real (kind=dp),intent(in ),dimension(size(pos,1),3) :: vel
    ! proj(:,(x',y'))
    real (kind=dp),intent(out),dimension(:,:)           :: proj
    ! losvd (:)
    real (kind=dp),intent(out),dimension(:)             :: losvel
    integer (kind=i4b),intent(in)                       :: type,n
  !----------------------------------------------------------------------
    real (kind=dp)              :: t1, t2, t3,theta,phi

    ! Signs of the (vx,vy,vz) for each Projection and type of Orbit
    real (kind=dp),dimension(3,8,5),parameter :: vsgn= reshape((/  &
    ! X tubes
    1 , 1 , 1    ,-1 , 1 , 1  , -1 , 1 ,-1  ,  1 , 1 , -1 , & 
    1 ,-1 , 1    ,-1 ,-1 , 1  , -1 ,-1 ,-1  ,  1 ,-1 , -1 , & 
    ! Y tubes
    1 , 1 , 1    , 1 , 1 ,-1  ,  1 ,-1 ,-1  ,  1 ,-1 , 1 , & 
   -1 , 1 , 1    ,-1 , 1 ,-1  , -1 ,-1 ,-1  , -1 ,-1 , 1 , & 
    ! Z tubes
    1 , 1 , 1    , 1 ,-1 , 1  , -1 ,-1 , 1  , -1 , 1 , 1 , & 
    1 , 1 ,-1    , 1 ,-1 ,-1  , -1 ,-1 ,-1  , -1 , 1 ,-1 , & 
    ! Boxed 
    1 , 1 , 1    ,-1 , 1 , 1  , -1 ,-1 , 1  ,  1 ,-1 , 1 , & 
    1 , 1 ,-1    ,-1 , 1 ,-1  , -1 ,-1 ,-1  ,  1 ,-1 ,-1 , & 
    ! Stochastic
    1 , 1 , 1    ,-1 , 1 , 1  , -1 ,-1 , 1  ,  1 ,-1 , 1 , & 
    1 , 1 ,-1    ,-1 , 1 ,-1  , -1 ,-1 ,-1  ,  1 ,-1 ,-1 /),(/3,8,5/))

    !Signs of the x,y,z for each projection  :psgn( [x,y,z], project )  
    real (kind=dp),dimension(3,8),parameter :: psgn= reshape((/  &   
    1 , 1 , 1   , -1 , 1 , 1  , -1 , -1 , 1 ,  1 , -1 , 1 , & 
    1 , 1 ,-1   , -1 , 1 ,-1  , -1 , -1 ,-1 ,  1 , -1 ,-1 /),(/3,8/))
    
    theta=theta_proj
    phi=phi_proj

    ! check orbit type
    if (type > 5 .or. type < 1 ) stop "project_n: Wrong orbit type" 
  
    ! Use sign matrix for the symmetries.
    ! Using the inverse (transpose) of the projection (eq. 4) of Thesis Ellen.
   
    ! x'
    t1 = -sin(phi  ) * psgn(1,n) 
    t2 =  cos(phi  ) * psgn(2,n)  
    proj(:,1) = t1 * pos(:,1)  + t2 * pos(:,2)

    ! y'
    t1 = -cos(theta)*cos(phi) * psgn(1,n) 
    t2 = -cos(theta)*sin(phi) * psgn(2,n) 
    t3 =  sin(theta)          * psgn(3,n)
    proj(:,2) = t1 * pos(:,1) + t2 * pos(:,2) + t3 * pos(:,3)

    ! v_LOS
    t1 = sin(theta)*cos(phi)  * vsgn(1,n,type) 
    t2 = sin(theta)*sin(phi)  * vsgn(2,n,type) 
    t3 = cos(theta)           * vsgn(3,n,type)
    losvel(:) = t1 * vel(:,1) + t2 * vel(:,2) + t3 * vel(:,3)

    !Comment from Giulia
    print*, t1,t2,t3

  !xaa = (-sin(phi)*x+cos(phi)*y)*sin(psi)-(-cos(theta)*cos(phi)*x-cos(theta)*sin(phi)*y+sin(theta)*z)*cos(psi);
  !yaa = (-sin(phi)*x+cos(phi)*y)*cos(psi)+(-cos(theta)*cos(phi)*x-cos(theta)*sin(phi)*y+sin(theta)*z)*sin(psi);

  !  t1 = sin(phi)        
  !  t3 = cos(phi)
  !  t5 = -t1*x+t3*y
  !  t6 = sin(psi)
  !  t8 = cos(theta)
  !  t13 = sin(theta)
  !  t15 = -t8*t3*x-t8*t1*y+t13*z
  !  t16 = cos(psi)
  !  v(1) = t5*t6-t15*t16
  !  v(2) = t5*t16+t15*t6

  !  v(1) = x*sin(psi)-y*cos(psi)
  !  v(2) = x*cos(psi)+y*sin(psi)

  end subroutine project_n

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine project(type,pos,vel,proj,lofvel,done,first)
    integer(kind=i4b),intent(in)                        :: type
    real (kind=dp),intent(in ),dimension(:,:          ) :: pos
    real (kind=dp),intent(in ),dimension(size(pos,1),3) :: vel
    real (kind=dp),intent(out),dimension(size(pos,1)*projection_symmetry,2) &
         & :: proj
    real (kind=dp),intent(out),dimension(size(pos,1)*projection_symmetry) &
         & :: lofvel
    logical       ,intent(out)                          :: done
    logical       ,intent(in )                          :: first
  !----------------------------------------------------------------------
    integer (kind=i4b),save :: count=0

    ! reset counter if this is the first projection for this orbit
    if (first) count=0
    count=count+1
    done=.false.

    if (count <= proj_number) then
       call project_n(type,pos,vel,proj,lofvel,count)
    else
       count=proj_number+1
       done=.true.
       proj(:,:)=0.0_dp
       lofvel(:)=0.0_dp
    endif

  end subroutine project
 

end module projection

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! Sterrewacht Leiden, The Netherlands

module psf
use numeric_kinds
implicit none
private

! * Module for the PSF generation.
! The way PSF are done in this program is quite simple. We just
! take the original point and modify it with a configurable
! random gaussian offset (psf_size).

! how many psf are there?
integer  (kind=i4b),public                           :: psf_n
! kind of psf(psf_n)
integer  (kind=i4b),private,allocatable,dimension(:) :: psf_kind
! size of psf for (n,psf)
real    (kind=dp ) ,private,allocatable,dimension(:,:) :: psf_sigma
! intensity of the psf(n,psf)
real    (kind=dp ) ,private,allocatable,dimension(:,:) :: psf_iten
! (i,j,pf) contains a sigma's in random order for psf pf
real    (kind=dp ) ,private,allocatable,dimension(:,:) :: psf_randomsigma
! setupup of psf variables
public :: psf_setup
! generate gaussian psf points of input array.
public :: psf_gaussian

public :: psf_stop

! Find the sigma of the psf number #.
public :: psf_cal_sigma

! Generates an array with proportionals sigma's of a MGE-PSF
private:: psf_sigma_map

contains

 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 subroutine psf_stop()
 !----------------------------------------------------------------------
   if (allocated(psf_kind)) then
      deallocate(psf_kind,psf_sigma,psf_iten)
   end if

 end subroutine psf_stop

 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 subroutine psf_setup()
   use initial_parameters    , only : conversion_factor
   use random_gauss_generator, only : random_gauss_seed
 !----------------------------------------------------------------------
   integer (kind=i4b) :: i,j

   print*,"  ** Setting up PSF module"
   print*,"  * How many different psf's?"
   read *, psf_n
   print*,"   ",psf_n
   allocate(psf_kind  (psf_n))

   do i=1,psf_n
     print*,"  * How many gaussians does the ",i,"psf consist of?"
     read *, psf_kind(i)
     print*, psf_kind(i)
     if (psf_kind(i) < 1) stop "gaussian value too low"
   end do

   allocate(psf_sigma(maxval(psf_kind(:)),psf_n))
   allocate(psf_iten (maxval(psf_kind(:)),psf_n))

   do i=1,psf_n
    print*,"   Intensity, sigma of the gauss for PSF ",i
    do j=1,psf_kind(i)
      read *,psf_iten(j,i),psf_sigma(j,i)
      print*,psf_iten(j,i),psf_sigma(j,i)
    end do
   end do

    ! convert sizes arcsec to km
    psf_sigma(:,:) = psf_sigma(:,:)*conversion_factor
    call random_gauss_seed()
    call psf_sigma_map()

    print*,"  ** PSF module setup Finished"

  end subroutine psf_setup

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine psf_gaussian(pf,vec,gaus)
    use random_gauss_generator
    integer (kind=i4b),intent(in)               :: pf
    ! input vectors (n,2)
    real    (kind=dp),dimension(:,:),intent(in) :: vec
    ! output vectors (n,2)
    real    (kind=dp),dimension(:,:),intent(out)::gaus
  !----------------------------------------------------------------------
    real (kind=sp), dimension(size(vec,1)) :: t
    integer (kind=i4b), dimension(size(vec,1)) :: ind
    integer (kind=i4b) :: j

    
    if (psf_kind(pf)==1) then
        ! One gaussian in this psf
       if (psf_sigma(1,pf) > 1.0_dp) then
          call random_gauss(gaus(:,:))
          gaus(:,:) = vec(:,:) + gaus(:,:)*psf_sigma(1,pf)
       else
          ! psf size is tiny, so no convolution is done.
          gaus(:,:) = vec(:,:)
       end if
    else
       ! MGE PSF. Use the randomsigma to convolve these points
       ! Each sigma has a chance of being used proprotional
       ! to the weight of the corresponding Gaussian component.
       ! M. Cappellari, 14 January 2003
       call random_gauss(gaus(:,:))
       call random_number(t(:))
       ind = t*(size(vec,1)-1) + 1 ! n=size(vec,1) random integers in [1,n]
       forall (j=1:2)
          gaus(:,j) = vec(:,j) + gaus(:,j)*psf_randomsigma(ind(:),pf)
       end forall
       
    end if

  end subroutine psf_gaussian

 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine psf_sigma_map()
    use integrator , only : integrator_points
    use projection  , only : projection_symmetry
  !----------------------------------------------------------------------

    integer (kind=i4b)                          :: pf
    ! input vectors (n,2)
    integer (kind=i4b)                          :: i,j,sizex,k,o
    real    (kind=dp ),dimension(:),allocatable :: weightfl
    integer (kind=i4b ),dimension(:),allocatable :: weightint
    ! random sigma's
    real    (kind=dp ) :: offset,total

    print*,"  * Making vectors filled of sigmas for psf convolution."
    sizex = integrator_points*projection_symmetry
    allocate (psf_randomsigma(sizex,psf_n))
    psf_randomsigma(:,:)=0.0_dp

    do pf=1,psf_n
       allocate (weightfl(psf_kind(pf)),weightint(psf_kind(pf)+1))

       ! The weight of each PSF gaussian
       do i=1,psf_kind(pf)
          weightfl(i) = abs(psf_iten(i,pf))
       end do
       do i=1,psf_kind(pf)
          ! normalized cumulative sum
       weightint(i+1) = nint(sum(weightfl(1:i))*((sizex-1)/sum(weightfl(:))))+1 
       enddo
       ! range [1,sizex]
       weightint(1)=1_i4b
       weightint(psf_kind(pf)+1)=sizex

       ! Now we generate an array with the sigmas. Each sigma occurs a
       ! relative weighted amount of times in the array.
       do i=1,psf_kind(pf)
          do j=weightint(i),weightint(i+1)
             psf_randomsigma(j,pf) = psf_sigma(i,pf)
          enddo
       enddo
       print*,'Weight divided for psf',pf,':'
       print*,weightint(:)
       deallocate(weightfl,weightint)
    end do
  end subroutine psf_sigma_map

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine psf_cal_sigma(pf,sigma)
  integer (kind=i4b) , intent(in) :: pf
  real    (kind= dp) , intent(out):: sigma
  !----------------------------------------------------------------------
    sigma = maxval(psf_sigma(:,pf))

  end subroutine psf_cal_sigma

end module psf

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! July 2002 Sterrewacht Leiden.

module aperture
  use numeric_kinds
  implicit none
  private

  ! Total number of apertures
  integer (kind=i4b),public                          :: aperture_n
  ! type of aperture (1=poly,2=box)
  integer (kind=i4b),public,allocatable,dimension(:) :: aperture_type

  ! number of bins in aperture
  integer (kind=i4b),public,allocatable,dimension(:) :: aperture_size
  ! Starting point of the aperture in flat array.
  integer (kind=i4b),public,allocatable,dimension(:) :: aperture_start
  ! To which psf does this aperture belong?
  integer (kind=i4b),public,allocatable,dimension(:) :: aperture_psf
  public :: aper_stop

contains

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
subroutine aper_stop()
!----------------------------------------------------------------------
  print*,"  * Stopping aperture module"
  if (allocated(aperture_type)) then
     deallocate(aperture_type)
     deallocate(aperture_size)
     deallocate(aperture_start)
  end if
  print*,"  * Aperture module stopped"

end subroutine aper_stop

end module aperture

!######################################################################
!######################################################################
!######################################################################

module aperture_polygon
  ! module with the functions for the polygon apertures.
  use numeric_kinds
  implicit none
  private

  ! aperture data
  real (kind=dp)    , Dimension (:,:),private,allocatable :: polygon
  integer (kind=i4b), Dimension (:,:),private,allocatable :: polygon_struct

  ! Input routine
  public :: aperture_poly_readfile

  ! Functions for find points in polygons
  public :: aperture_poly_find

  public :: aper_poly_stop

  private :: aperture_single_polygon

  public :: aperture_poly_field
contains

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine aper_poly_stop()
  !----------------------------------------------------------------------
    if (allocated(polygon)) then
       deallocate(polygon)
       deallocate(polygon_struct)
    end if

  end subroutine aper_poly_stop

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine aperture_poly_readfile(handle,aper_n)
    use initial_parameters , only : conversion_factor
    use aperture, only: aperture_type,aperture_size ,aperture_start
    integer (kind=i4b),intent(in) :: handle
    integer (kind=i4b),intent(in) :: aper_n
  !----------------------------------------------------------------------
    integer (kind=i4b),save       :: pol_n=1,pol_s_n=1
    integer (kind=i4b)            :: i,k,count
    !temporary array's
    real (kind=dp), Dimension (:,:),allocatable :: tr
    integer (kind=i4b), Dimension (:,:),allocatable :: ti

    print*, "  * Reading Polygonal aperture file."

    ! set aperture type
    aperture_type(aper_n)=1

    ! Read in # polygons
    read (unit=handle,fmt = *) i
    aperture_size(aper_n)=i
    aperture_start(aper_n)=pol_s_n
    print*, "  * File contains ",aperture_size(aper_n)," polygons"

    if (allocated(polygon_struct)) then
       ! funky reallocate. this is the way to do it in ifc.
       allocate(ti(size(polygon_struct,1),size(polygon,2)))
       ti(:,:)=polygon_struct(:,:)
       deallocate(polygon_struct)
       allocate(polygon_struct(pol_s_n+i,2))
       polygon_struct(1:size(ti,1) ,1:size(ti,2) ) = ti(1:size(ti,1)&
            &,1:size(ti,2))
       deallocate(ti)
    else
       allocate ( polygon_struct(pol_s_n+i,2))
    end if

    polygon_struct(1,1)=1
    do k=pol_s_n , i+pol_s_n-1
       read (unit=handle,fmt=*) polygon_struct(k,2)
    end do

    count=0
    do k=pol_s_n,i+pol_s_n-1

       polygon_struct(k,1) = (pol_n+count)
       count=count+polygon_struct(k,2)
    end do

    pol_s_n=i+pol_s_n
    polygon_struct(pol_s_n,1)=count
    if (allocated(polygon)) then
       ! funky reallocate. this is the way to do it in ifc.
       allocate(tr(size(polygon,1),size(polygon,2)))
       tr(:,:)=polygon(:,:)
       deallocate(polygon)
       allocate(polygon(pol_n+count,2))
       polygon(1:size(tr,1) ,1:size(tr,2) ) = tr(1:size(tr,1)&
            &,1:size(tr,2))
       deallocate(tr)
    else
       allocate ( polygon(pol_n+count,2) )
    end if
    print*, "  * Total amount of vertexes :" ,count

    read (unit=handle,fmt=*) (polygon(i,1),polygon(i,2), i=pol_n,count+pol_n-1)
    ! convert arcsec to km
    polygon (pol_n:count+pol_n-1,:)=polygon(pol_n:count+pol_n-1,:)* &
         & conversion_factor
    pol_n=pol_n+count+1
    print*,"  * Finished reading file"
    print*,"  "
    print*,"  * Aperture file ",aper_n," contained :"
    print*,"  *   #pol       #ver      1.x "
    do i=aperture_start(aper_n),aperture_start(aper_n)+aperture_size(aper_n)-1
       print*,"    ",i, "  " , polygon_struct(i,2), "  ", &
            &polygon(polygon_struct(i,1),1),polygon_struct(i,1)
    end do

  end subroutine aperture_poly_readfile

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine aperture_poly_find(vec,ap,res)
    use aperture, only: aperture_size, aperture_type,aperture_start
    real (kind=dp),dimension(:,:),intent(in)                         :: vec
    integer (kind=i4b)             ,intent(in)                       :: ap
    integer (kind=i4b),intent(out),dimension(size(vec,1))            :: res
  !----------------------------------------------------------------------
    integer (kind=i4b)                                               :: i,k
    logical                                                          :: found

    !DEBUG
    if (aperture_type(ap)/=1) stop "FIXME: BUG in aperture_find_m"

    res(:)=0
    do k=1,size(vec,1)
          do i=0,aperture_size(ap)
             call aperture_single_polygon(i+aperture_start(ap),vec(k,1), &
                  vec(k,2),found)
             if (found) then
                res(k)=i+1
                exit
             end if
          end do
    end do

  end subroutine aperture_poly_find

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine aperture_single_polygon(k,x,y,found)
    integer (kind=i4b),intent(in)  :: k
    real (kind=dp)    ,intent(in)  :: x,y
    logical           ,intent(out) :: found
  !----------------------------------------------------------------------
  integer (kind=i4b)             :: i,j

    found=.false.
    j=polygon_struct(k,1)+polygon_struct(k,2)-1
    do i=polygon_struct(k,1),polygon_struct(k,1)+polygon_struct(k,2)-1
       if ( (polygon(i,2)<=y .and. y<polygon(j,2)) .or. (polygon(j,2)<=y &
            & .and. y<polygon(i,2))) then
          if (x<( (polygon(j,1)-polygon(i,1)) * (y - polygon(i,2) ) / &
               & (polygon(j,2) -polygon(i,2)))+polygon(i,1) ) found=.not.found
       end if
       j=i
    end do

  end subroutine aperture_single_polygon

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine aperture_poly_field(ap,x,y)
    use aperture, only : aperture_size,aperture_start
    integer (kind=i4b),intent(in ) :: ap
    real    (kind=dp ),intent(out),dimension(:) :: x,y
  !----------------------------------------------------------------------
  integer (kind=i4b) :: i
    real    (kind=dp ) :: d,e
    x(:)=0.0_dp
    y(:)=0.0_dp
    ! This do is an example of bad datastructure design.
    do i=polygon_struct(aperture_start(ap),1), &
         & polygon_struct(aperture_start(ap)+aperture_size(ap)-1 ,1) + &
         & polygon_struct(aperture_start(ap)+aperture_size(ap)-1 ,2) -1
       d=polygon(i,1)
       e=polygon(i,2)
       x(1)=min(d,x(1))
       y(1)=min(e,y(1))
       x(2)=max(d,x(2))
       y(2)=max(e,x(2))
    end do

  end subroutine aperture_poly_field

end module aperture_polygon

!######################################################################
!######################################################################
!######################################################################

module aperture_boxed
  !contains the aperture functions for the square pixel boxed apertures
  use numeric_kinds
  implicit none
  private

  real (kind=dp),private,dimension(:,:),allocatable :: ap_box_size,ap_box_begin
  real (kind=dp),private,dimension(:)  ,allocatable :: ap_box_idx,ap_box_idy
  real (kind=dp),private,dimension(:)  ,allocatable :: ap_box_rot
  integer (kind=i4b),private,dimension(:),allocatable :: ap_box_bx

  ! read in boxed aperture file
  public :: aperture_boxed_readfile

  !figure out in which aperture the points fit.
  public :: aperture_boxed_find

  public :: aper_boxed_stop

  public :: aperture_boxed_field

contains

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine aper_boxed_stop()
  !----------------------------------------------------------------------
    if (allocated(ap_box_size)) then
       deallocate(ap_box_size,ap_box_begin,ap_box_idx,ap_box_idy,ap_box_rot)
       deallocate(ap_box_bx)
    end if

  end subroutine aper_boxed_stop

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine aperture_boxed_readfile(handle,aper_n)
    use initial_parameters , only : conversion_factor
    use aperture, only : aperture_type,aperture_size,aperture_start
    integer (kind=i4b),intent(in) :: handle,aper_n
  !----------------------------------------------------------------------
    integer (kind=i4b),save       :: amount=0
    integer (kind=i4b)            :: biny
    !temporary array's
    real (kind=dp), Dimension (:,:),allocatable     :: tr
    integer (kind=i4b), Dimension (:,:),allocatable :: ti

    print*, "  * Reading boxed aperture file."

    amount=amount+1

    if (allocated(ap_box_size)) then
       allocate(tr(amount,7),ti(amount,1))
       tr(:,:)  = 0
       ti(:,:)  = 0
       tr(1:amount-1,1:2) = ap_box_size (:,1:2)
       tr(1:amount-1,3:4) = ap_box_begin(:,1:2)
       tr(1:amount-1,5)   = ap_box_idx  (:)
       tr(1:amount-1,6)   = ap_box_idy  (:)
       tr(1:amount-1,7)   = ap_box_rot  (:)
       ti(1:amount-1,1)   = ap_box_bx  (:)

       deallocate(ap_box_size ,ap_box_begin ,ap_box_bx)
       deallocate(ap_box_idx  ,ap_box_idy   ,ap_box_rot)

       allocate(ap_box_size(amount,2), ap_box_begin(amount,2))
       allocate(ap_box_bx(amount)    , ap_box_idx(amount))
       allocate(ap_box_idy(amount)   , ap_box_rot(amount))

       ap_box_size (:,1:2) = tr(:,1:2)
       ap_box_begin(:,1:2) = tr(:,3:4)
       ap_box_idx  (:)     = tr(:,5)
       ap_box_idy  (:)     = tr(:,6)
       ap_box_rot  (:)     = tr(:,7)
       ap_box_bx  (:)      = ti(:,1)

       deallocate (tr,ti)
    else
       allocate(ap_box_size(1,2), ap_box_begin(1,2), ap_box_bx(1))
       allocate(ap_box_idx(1), ap_box_idy(1), ap_box_rot(1))
    end if
    ! set aperture type
    aperture_type(aper_n)=2

    print*,"  *  Reading box info"
    print*,"  *  Order: begin(x,y)"
    read(unit=handle,fmt=*) ap_box_begin(amount,1:2)
    print*,"      size(x,y) "
    read(unit=handle,fmt=*) ap_box_size(amount,1:2)
    print*,"      rotation"
    read(unit=handle,fmt=*) ap_box_rot(amount)
    ap_box_rot(amount)=ap_box_rot(amount)*(pi_d/180.0_dp)
    print*,"      bin(x,y)"
    read(unit=handle,fmt=*) ap_box_bx(amount),biny

    ! convert arcsec into km
    ap_box_begin(amount,:)=ap_box_begin(amount,:)*conversion_factor
    ap_box_size (amount,:)=ap_box_size (amount,:)*conversion_factor

    ap_box_idx(amount) =  ( ap_box_bx(amount) / ap_box_size(amount,1) )
    ap_box_idy(amount) =  ( biny / ap_box_size(amount,2) )

    aperture_start(aper_n)=amount
    aperture_size(aper_n)=ap_box_bx(amount)*biny

    print*,"   Total bins " , aperture_size(aper_n)
    print*,"   begin      " , ap_box_begin(amount,:)
    print*,"   size       " , ap_box_size(amount,:)
    print*,"   rotation   " , ap_box_rot(amount)
    print*,"   binx       " , ap_box_bx(amount)
    print*,"   idx,y      " , ap_box_idx(amount),ap_box_idy(amount)
    print*," "
    print*,"  * Finished reading aperture"

  end subroutine aperture_boxed_readfile

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine aperture_boxed_find(ap,vec,res)
    ! vec is a n*m*2 matrix with vectors.
    ! res is an n*m matrix with has the resulting pixel of each vector
    ! ap is the aperture number.
    use aperture , only : aperture_start, aperture_type
    !use initial_parameters, only : psi_view
    use projection, only : psi_proj
    integer (kind=i4b), intent(in)                          :: ap
    real (kind=dp), dimension(:,:), intent(in)              :: vec
    integer (kind=i4b), dimension(size(vec,1)), intent(out) :: res
  !----------------------------------------------------------------------
    integer (kind=i4b) :: n,j,bx
    real (kind=dp) :: r1,r2,b1,b2,idx,idy,sx,sy,x,y,t,q
    !real (kind=dp), dimension(size(vec,1)) :: t, q, x, y

    !DEBUG
    if (aperture_type(ap)/=2) stop "FIXME: BUG in aperture_boxed_find"

    ! The number of this aperture in the memory
    n = aperture_start(ap)

    r1 = cos(-ap_box_rot(n)+ pio2_d-psi_proj)
    r2 = sin(-ap_box_rot(n)+ pio2_d-psi_proj)

    b1 = ap_box_size(n,1)
    b2 = ap_box_size(n,2)
    idx = ap_box_idx(n)
    idy = ap_box_idy(n)
    bx = ap_box_bx(n)
    sx = ap_box_begin(n,1)
    sy = ap_box_begin(n,2)

! Perform shift after rotation MC, 19/APR/2004
! Meanning of ap_box_begin has changed!

    do j=1,size(vec,1)
       t = vec(j,1)
       q = vec(j,2)
       x = t*r1 - q*r2 - sx
       res(j) = 0!_i4b
       if (x > 0.0_dp .and. x < b1 ) then
          y = t*r2 + q*r1 - sy
          if ( y > 0.0_dp .and. y < b2 ) then
             res(j) = int(x*idx) + int(y*idy) * bx + 1!_i4b
          end if
       end if
    end do

 end subroutine aperture_boxed_find

 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 subroutine aperture_boxed_field(ap,x,y)
   use aperture, only : aperture_start
   integer (kind=i4b),intent(in ) :: ap
   real    (kind=dp ),intent(out),dimension(:) :: x,y
 !----------------------------------------------------------------------
 integer (kind=i4b) :: i,j,n
   real (kind=dp ) :: d,e,f,g,r1,r2

   ! The number of this aperture in the memory
   n = aperture_start(ap)
   r1 = cos(ap_box_rot(n))
   r2 = sin(ap_box_rot(n))
   x(:) = 0.0_dp
   y(:) = 0.0_dp
   do i=1,2
      f=(i-1)*ap_box_size(n,1) + ap_box_begin(n,1)
      do j=1,2
         g = (j-1)*ap_box_size(n,2) + ap_box_begin(n,2)
         d = r1*f - r2*g
         e = r2*f + r1*g
         x(1) = min(d,x(1))
         y(1) = min(e,y(1))
         x(2) = max(d,x(2))
         y(2) = max(e,y(2))
      end do
   end do

 end subroutine aperture_boxed_field

end module aperture_boxed

!######################################################################
!######################################################################
!######################################################################

module aperture_routines
  ! Basic aperture routines
  ! This module is the overhead to call the aperture_* functions
  use numeric_kinds
  use aperture
  implicit none
  private

  public :: aperture_setup

  public :: aperture_stop

  ! Finds aperture numbers corresponding to the VECtors.
  public :: aperture_find

  ! Finds the boundaries (on the sky) of an aperture.
  public :: aperture_field

contains

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine aperture_setup()
    use aperture_polygon, only : aperture_poly_readfile
    use aperture_boxed,only : aperture_boxed_readfile
    use psf , only : psf_n
  !----------------------------------------------------------------------
    integer (kind=i4b)  :: i,handle=11
    character(len = 80) :: file,string
    print*,"  **Aperture setup module"
    print*,"  * How many different apertures?  :"
    read *, aperture_n

    allocate (aperture_size (aperture_n))
    allocate (aperture_start(aperture_n))
    allocate (aperture_type (aperture_n))
    allocate (aperture_psf  (aperture_n))
    print*,"  * using ",aperture_n," aperture(s)"

    do i=1,aperture_n
       print*,"  * What's the filename of the ",i," aperture file ? :"
       read*, file
       print*, "  * Reading ", file

       open (unit=handle,file=file,action="read",status="old"&
            &,position="rewind")
       print*,"  * Checking type."
       read(unit=handle,fmt=*) string

       select case (string)
       case ("#counterrotation_polygon_aperturefile_version_1")
          call aperture_poly_readfile(handle,i)
       case ("#counter_rotation_boxed_aperturefile_version_2")
          call aperture_boxed_readfile(handle,i)
       case default
          print*,"  * Sorry, can only handle:"
          print*,"     #counterrotation_polygon_aperturefile_version_1"
          print*,"     #counter_rotation_boxed_aperturefile_version_2"
          print*,"    This file is of type:"
          print*,"  ", string
          stop " program ended because of wrong input."
       end select

       close (unit=handle)
       print*,"  * To which psf does this aperture belong?"
       read *,aperture_psf(i)
       if ( aperture_psf(i) < 1 .or. aperture_psf(i) > psf_n ) then
          stop " That PSF does not exist!"
       end if
    end do
    print*,"  ** aperture setup finished"

  end subroutine aperture_setup

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine aperture_stop()
    use aperture         , only : aper_stop
    use aperture_polygon , only : aper_poly_stop
    use aperture_boxed   , only : aper_boxed_stop
  !----------------------------------------------------------------------
    call aper_stop      ()
    call aper_poly_stop ()
    call aper_boxed_stop()

  end subroutine aperture_stop

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine aperture_find(ap,v_m,poly)
    use aperture         , only : aperture_type
    use aperture_boxed   , only : aperture_boxed_find
    use aperture_polygon , only : aperture_poly_find
    integer (kind=i4b)                       , intent(in ) :: ap
    real    (kind=dp ),dimension(:,:)        , intent(in ) :: v_m
    integer (kind=i4b),dimension(size(v_m,1)), intent(out) :: poly
  !----------------------------------------------------------------------
    select case (aperture_type(ap))
    case (1)
       call aperture_poly_find(v_m,ap,poly)
    case (2)
       call aperture_boxed_find(ap,v_m,poly)
    case default
       print*," aperture type :",ap," found"
       stop " Wrong aperture type in aperture_find"
    end select

  end subroutine aperture_find

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine aperture_field(pf,minx,maxx,miny,maxy)
    use aperture        , only : aperture_n,aperture_type,aperture_psf
    use aperture_boxed  , only : aperture_boxed_field
    use aperture_polygon, only : aperture_poly_field
    use psf             , only : psf_n
    integer (kind=i4b),intent(in ) :: pf
    real    (kind=dp ),intent(out) :: maxx,minx,miny,maxy
  !----------------------------------------------------------------------
    logical, save :: initialized=.false.
    real    (kind=dp ),dimension(:,:),allocatable,save :: f_x,f_y
    integer (kind=i4b) :: i,pfn
    real    (kind=dp ),dimension(2) :: x,y

    if (.not. initialized) then
       allocate(f_x(psf_n,2),f_y(psf_n,2))
       f_x(:,:)=0.0_dp
       f_y(:,:)=0.0_dp
       do i=1,aperture_n
          pfn=aperture_psf(i)
          select case (aperture_type(i))
          case (1)
             call aperture_poly_field (i,x,y)
          case (2)
             call aperture_boxed_field(i,x,y)
          case default
             print*," aperture type :",i," found"
             stop " Wrong aperture type in aperture_field"
          end select
          f_x(pfn,1)=min(f_x(pfn,1) , x(1))
          f_x(pfn,2)=max(f_x(pfn,2) , x(2))
          f_y(pfn,1)=min(f_y(pfn,1) , y(1))
          f_y(pfn,2)=max(f_y(pfn,2) , y(2))
       end do
       initialized=.true.
    end if

    minx=f_x(pf,1)
    miny=f_y(pf,1)
    maxx=f_x(pf,2)
    maxy=f_y(pf,2)

  end subroutine aperture_field

end module aperture_routines

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! Sterrenwacht Leiden, The Netherlands

! This Module provides the binning of seperate histgrams.
! Type 0 : Do nothing.
! Type 1 : Sum all the bins with the same order number.

! This module was written to accomodate the Sauron pixel binning.

module binning
  ! Extension to the histogram module.
  ! This module takes care of possible binning of the histogram.
  use numeric_kinds
  implicit none
  private

  ! set's up the binning array's
  public :: binning_setup

  ! deallocate memory
  public :: binning_stop

  ! bin the aperture
  public :: binning_bin

  ! function for binning of type 1
  private :: binning_add_it_up

  ! Type of binning. (0=no binning) (1=simple binning)
  integer (kind=i4b), private, allocatable,dimension(:)   ::  bin_type

  ! The way the boxes should be binned (order,ap)
  integer (kind=i4b), private, allocatable,dimension(:,:) ::  bin_order

  ! The total amount of boxes in the binned boxes
  ! ( actually maxval(binning_order(ap)) )
  integer (kind=i4b), public, allocatable,dimension(:) :: bin_max

  ! size(bin_order(:,ap),1)
  integer (kind=i4b), private, allocatable,dimension(:)   ::  bin_size

contains

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine binning_stop()
  !----------------------------------------------------------------------
  if (allocated(bin_type)) then
       deallocate (bin_type )
       deallocate (bin_order)
       deallocate (bin_max  )
       deallocate (bin_size )
    end if

  end subroutine binning_stop

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine binning_setup()
    use aperture, only : aperture_n
  !----------------------------------------------------------------------
    integer (kind=i4b) :: i
    character (len=80) :: string
    print*,"  * Starting Binning setup"
    allocate(bin_type(aperture_n))
    allocate(bin_max (aperture_n))
    allocate(bin_size(aperture_n))
    bin_max (:)=0
    bin_size(:)=0

    do i=1,aperture_n
       print*,"  * What kind of binning for aperture ",i
       print*,"    0=none 1=added up"
       do
          read*,bin_type(i)
          if (bin_type(i) == 1 .or. bin_type(i) == 0 ) exit
          print*,"   - Input incorrect try again!"
       end do
       print*,"  * Type:",bin_type(i)
    end do

    print*,"  * Reading binning files"

    do i=1,aperture_n
       if (bin_type(i) == 1) then
          print*,"  * Aperture: ",i
          print*,"  * Give the filename of the binning file."
          read*,string
          print*,"  * Opening: ",string
          open (unit=30+i,file=string,action="read",status="old"&
            &,position="rewind")
          read (unit=30+i,fmt=*) string
          if (string /= "#Counterrotaton_binning_version_1") &
               stop " Wrong version of file"
          read (unit=30+i,fmt=*) bin_size(i)
          print*,"  * bins in this aperture:",bin_size(i)
       end if
    end do

    allocate(bin_order(maxval(bin_size(:)),aperture_n))

    bin_order(:,:)=0 
    
    do i=1,aperture_n
       if (bin_type(i) == 1) then
          print*,"  * Reading data of aperture:",i,bin_size(i)
          read (unit=30+i,fmt=*) bin_order(1:bin_size(i),i)
          close (unit=30+i)
       end if
    end do

    do i=1,aperture_n
       if (bin_type(i) == 1) then
          bin_max(i)=maxval(bin_order(:,i)) 
       end if
    end do
    print*,"  ** Binning module setup finished."

  end subroutine binning_setup

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine binning_bin(ap,h,newsize)
    integer (kind=i4b),intent(in)                     :: ap
    real    (kind=dp ),intent(in out) ,dimension(:,:) :: h
    integer (kind=i4b),intent(out)                    :: newsize
  !----------------------------------------------------------------------
    if (bin_type(ap) == 1) then                
       call binning_add_it_up(ap,h,newsize)
    else
       newsize=size(h,1)
    end if

  end subroutine binning_bin

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine binning_add_it_up(ap,h,newsize)
    integer (kind=i4b),intent(in)                        :: ap
    integer (kind=i4b),intent(out)                       :: newsize
    real    (kind=dp ),intent(in out) ,dimension(:,:)    :: h
  !----------------------------------------------------------------------
    real    (kind=dp ),dimension(0:bin_max(ap),size(h,2)) :: t
    integer (kind=i4b)                                    :: i
             
    newsize = bin_max(ap)
    t(:,:)  = 0.0_dp
    ! check boundaries
    if (newsize > size(h,1) ) stop "Error: binning_add_it_up: new bin&
         &s are bigger then the original "
    if ( size(h,1) /= bin_size(ap)) stop " Wrong number of bins in a bin"

    do i=1, size(h,1)
       t(bin_order(i,ap),:)=t(bin_order(i,ap),:)+h(i,:)
    end do

    ! If you assume nothing, there is no way to do this without
    ! copying it back.
    h(1:newsize,:)=t(1:newsize,:)

  end subroutine binning_add_it_up

end module binning

!######################################################################
!######################################################################
!######################################################################

module histograms
! Routines for histogram manipulation
use numeric_kinds
implicit none
private

! histogram data (aperture,vel)
real (kind=dp), Dimension (:,:),private,allocatable  :: histogram
! hist_basic(n,i) n=aperture number, i=width,center,#bins
real (kind=dp), Dimension (:,:),public ,allocatable  :: hist_basic
! Are the velocity bins all the same?
logical, public                                      :: hist_thesame
!h_beg,h_end : begin/end of histogram
!h_bin,width : amount of / width of histogram pixels
real (kind=dp), Dimension (:)  ,private,allocatable  :: h_beg,h_end,h_width
integer (kind=i4b), Dimension (:),private,allocatable:: h_bin
! h_start(n)  :  where start the first histogram of aperture n
integer (kind=i4b), Dimension (:),private,allocatable:: h_start
! number of polygons/bins in each histogram for each aperture
integer (kind=i4b), Dimension (:),private,allocatable:: h_blocks
! number of histograms
integer (kind=i4b),private                           :: h_n
! number of points stored in histogram ( Used in normalising. )
real (kind=dp),Dimension (:),private,allocatable     :: h_n_stored
! total number of histograms/constraints  after binning
integer (kind=i4b),private                           :: h_nconstr

! routines for writing histogram part of output files
public :: histogram_write,histogram_setup_write
public :: histogram_write_compat_sparse,histogram_setup_write_mass

! Store velocities in the histogram(n).
public :: histogram_store

! Calculate the velocity bin from the losvd
public :: histogram_velbin

! function to reset the histogram for the next orbit
public :: histogram_reset

public :: histogram_stop

public :: histogram_setup

contains

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine histogram_reset()
  !----------------------------------------------------------------------
    histogram (:,:)= 0.0_dp
    h_n_stored(:)  = 0.0_dp

  end subroutine histogram_reset

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine histogram_setup_write(handle)
    integer (kind=i4b),intent(in) :: handle
  !----------------------------------------------------------------------
    integer (kind=i4b) :: t1
    !write information about the kinematical constraints and velocity histogram
    ! original names: nconstr,nvcube,dvcube
    t1 = hist_basic(1,3)/2.0_sp ! corrected by Remco 20/JAN/2003
    write (unit=handle) h_nconstr, t1, hist_basic(1,1)/hist_basic(1,3)

  end subroutine histogram_setup_write

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine histogram_setup_write_mass(handle)
    integer (kind=i4b),intent(in) :: handle
  !----------------------------------------------------------------------
    write (unit=handle, fmt="(i5)") h_nconstr

  end subroutine histogram_setup_write_mass

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine histogram_write(handle)
    use binning   , only : binning_bin
    integer (kind=i4b),intent(in) :: handle
  !----------------------------------------------------------------------
    integer (kind=i4b)            :: i,bg,ed
    print*,"  * Normalising and Writing histogram data."

    where ( h_n_stored(:) > 0.0_dp )
       h_n_stored(:) = 1.0_dp/h_n_stored(:)
    elsewhere
       h_n_stored(:) = 0.0_dp
    end where

    do i=1,h_n   
       bg = h_start(i)
       ed = h_blocks(i)+h_start(i)-1
       call binning_bin(i,histogram(bg:ed,1:h_bin(i)),ed)
       ed = h_start(i)-1+ed
       !conversion normalizing    
       histogram(bg:ed,1:h_bin(i)) = h_n_stored(i)*histogram(bg:ed,1:h_bin(i))
       call histogram_write_compat_sparse(handle,histogram(bg:ed,1:h_bin(i)))
    end do  
  end subroutine histogram_write

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine histogram_write_compat_sparse(handle,t)
    integer (kind=i4b),intent(in) :: handle
    real (kind=dp),dimension(:,:),intent(in) :: t
  !----------------------------------------------------------------------
    integer (kind=i4b) :: ap,b,e,i,k,bout,eout
    do ap=1,size(t,1) 
       b = 2*hist_basic(1,3)
       e = -2*hist_basic(1,3)
       do i=1,size(t,2)
          if (t(ap,i) > 0.0_dp) then
             b = min(b,i)
             e = max(e,i)
          end if
       end do

       ! write the relevant information for all velocity histograms to file
       k = hist_basic(1,3)/2.0_sp + 1.0_sp
       bout=b-k
       eout=e-k
       write (unit=handle) bout, eout
       if (b <= e) write (unit=handle) t(ap,b:e)
    end do

  end subroutine histogram_write_compat_sparse

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine histogram_velbin(pf,vel,bin)
    use aperture , only : aperture_psf
    integer (kind=i4b),                      intent(in ) :: pf
    real    (kind=dp ),dimension(:),         intent(in ) :: vel
    integer (kind=i4b),dimension(size(vel)), intent(out) :: bin
  !----------------------------------------------------------------------
    integer (kind=i4b) :: i,ap,bins
    real    (kind= dp) :: v,beg,width,hend
    ! find an aperture which is in this pf
    do i=1,h_n
      if (aperture_psf(i)==pf) ap=i
    end do

    beg=h_beg(ap)
    hend=h_end(ap)
    width=h_width(ap)
    bins=h_bin(ap)
 
    do i=1,size(vel)
      v=vel(i)
      if (v>beg) then
        if (v<hend) then
          ! photon lies within the velocity range
          bin(i)=int(((v-beg)/width))+1
        else
          ! photon lies above the range
          ! Assign photon to the last velocity bin. 
          bin(i)=bins
        end if
      else
        ! photon lies below the velocity range
        ! assign to first bin
        bin(i)=1
      end if
    end do

  end subroutine histogram_velbin

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine histogram_store(ap,n,velb,tot)
    integer (kind=i4b)                     , intent(in)  :: ap
    integer (kind=i4b)                                   :: i,k,v
    integer (kind=i4b),dimension(:)        , intent(in)  :: n
    integer (kind=i4b),dimension(size(n,1)), intent(in)  :: velb
    integer (kind=i4b)                     , intent(in)  :: tot
  !----------------------------------------------------------------------
    !update number of points stored (including points not stored)
    ! For normalising.
    h_n_stored(ap)=h_n_stored(ap)+tot

       do i=1,size(n,1)
          k = n(i)
          if (k /=0) then
             k = k + h_start(ap)-1
             v = velb(i)
             histogram(k, v) = histogram(k, v) + 1.0_dp
          end if
       end do
       
  end subroutine histogram_store

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine histogram_stop()
    use binning, only: binning_stop
  !----------------------------------------------------------------------
    if (allocated (h_bin)) then
       deallocate(hist_basic,h_beg,h_end,h_bin,h_width,h_start,histogram)
    end if
    call binning_stop()

  end subroutine histogram_stop

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine histogram_setup()
    use aperture  , only : aperture_n,aperture_size,aperture_psf
    use binning   , only : binning_setup,bin_max
    use psf       , only : psf_n
  !----------------------------------------------------------------------
    integer (kind=i4b)  :: i,j,ap
    real    (kind=dp )  :: width,center,bins

    print*,"  * Starting Histogram module"
    h_n=aperture_n
    allocate(hist_basic(h_n,3),h_beg(h_n),h_end(h_n),h_bin(h_n))
    allocate(h_width(h_n),h_start(h_n),h_n_stored(h_n),h_blocks(h_n))

    do i=1,psf_n
       print*,"  * Give for psf ",i," the histogram width, center and"
       print*,"    amount of bins"
       read *, width,center,bins
       print*, width,center,bins
       if (width <= 0 ) stop " Width to small"
       if (bins  <  1 ) stop " Too few bins"
       do j=1,h_n
         if (aperture_psf(j)==i) then
           hist_basic(j,1)=width
           hist_basic(j,2)=center
           hist_basic(j,3)=bins
         end if
       end do
    end do

    h_beg(:)=hist_basic(:,2)-(0.5_dp*hist_basic(:,1))
    h_end(:)=hist_basic(:,2)+(0.5_dp*hist_basic(:,1))
    h_bin(:)=hist_basic(:,3)
    h_width(:)=hist_basic(:,1)/hist_basic(:,3)

    allocate(histogram(sum(aperture_size(:)),maxval(h_bin(:)) ))
    print*,"  * Histogram size : ",size(histogram),"=",size(histogram,1),"*",&
         & size(histogram,2)

    h_blocks(:)=aperture_size(:)
    i=1

    do ap=1,h_n
       h_start(ap)=i
       i=i+h_blocks(ap)
    end do

    call histogram_reset()
    call binning_setup()

    ! Figure out how many histograms there are.
    h_nconstr=0
    do ap=1,h_n
       if (bin_max(ap) == 0 ) then
          h_nconstr=h_nconstr+aperture_size(ap)
       else
          h_nconstr=h_nconstr+bin_max(ap)
       end if
    end do

    ! Figure out if all the velocityhistograms are the same.
    hist_thesame=.true.
    width = hist_basic(1,1)
    center= hist_basic(1,2)
    bins  = hist_basic(1,3)
    do ap=2,h_n
      if ( width  /= hist_basic(ap,1) ) hist_thesame = .false.
      if ( center /= hist_basic(ap,2) ) hist_thesame = .false.
      if ( bins   /= hist_basic(ap,3) ) hist_thesame = .false.
    end do
    if (hist_thesame) then
      print*,"  * All velocity-bins are the same"
    else
      print*,"  * Velocity-bins are not the same. The standard NNLS will not"
      print*,"  * Understand the ouput correctly."
    end if
    print*,"  ** Histogram module setup finished"

  end subroutine histogram_setup

end module histograms

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! Sterrewacht Leiden, The Netherlands


module quadrantgrid
  use numeric_kinds
  implicit none
  private

  real (kind=dp),private,allocatable,dimension(:,:,:,:) :: quadrant_light
  real (kind=dp),private,allocatable,dimension(:) :: quad_lr,quad_lr2
  real (kind=dp),private,allocatable,dimension(:) :: quad_lth,quad_ltan2th
  real (kind=dp),private,allocatable,dimension(:) :: quad_lph,quad_ltanph

  public  :: qgrid_stop
  public  :: qgrid_write
  public  :: qgrid_setup_write
  public  :: qgrid_reset
  ! Store points in the grid.
  public  :: qgrid_store
  public  :: qgrid_setup
contains

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine qgrid_stop()
  !----------------------------------------------------------------------
    if (allocated(quadrant_light)) then
       deallocate (quadrant_light)
       deallocate (quad_lr,quad_lth,quad_lph)
       deallocate (quad_lr2,quad_ltan2th,quad_ltanph)
    end if  

  end subroutine qgrid_stop
 
  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine qgrid_reset()
  !----------------------------------------------------------------------
    quadrant_light(:,:,:,:) = 0.0_dp
  end subroutine qgrid_reset


  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine qgrid_setup()
    use initial_parameters, only :   nEner,nI2,nI3,rLogMin,rLogMax,sigobs_km &
                                     , conversion_factor
    use integrator        , only :   integrator_dithering
  !----------------------------------------------------------------------
    integer (kind=i4b) :: i,quad_nr,quad_nth,quad_nph
    real    (kind=dp)  :: inR,psfsize
    print*,"  ** Octant grid module setup"

    quad_nr  = 10   !10 !15 ! int(NEner / integrator_dithering*0.55 )  
    quad_nth = 6    !4  !4 ! int(nI2   / integrator_dithering ) - 1 ! towards middle axis
    quad_nph = 6    ! 5 !5 ! int(nI3   / integrator_dithering ) - 1 ! towards minor axis

    print*,"  ** Grid dimension:"
    print*,quad_nr,quad_nth,quad_nph

    allocate (quadrant_light(16,quad_nph,quad_nth,quad_nr))
    allocate (quad_lr (quad_nr +1),quad_lr2 (quad_nr +1))
    allocate (quad_lth(quad_nth+1),quad_ltan2th(quad_nth+1))
    allocate (quad_lph(quad_nph+1),quad_ltanph(quad_nph+1))

    ! Define a grid in such a way that the boundaries define all possible bins
    ! This also means that there are N+1 boundaries for N bins.
 
    do i=2,quad_nr
       quad_lr(i)=10.0_dp**(rlogmin+  (rLogMax-rlogmin+alog10(0.5)) * (i-1.0) &
            /(quad_nr-0.0))
    end do
    quad_lr(          1) = 0.0_dp
    quad_lr(quad_nr  +1) = max(10.0_dp**rLogMax*100.0_dp,maxval(sigobs_km)*10.0_dp)

    ! make a lr_squared array for quick computation
    quad_lr2(:) = quad_lr(:)**2_dp

    ! Define the angular bins 
    do i=2,quad_nth
       quad_lth(i) = pio2_d * (i-1.0_dp) / (quad_nth)
    end do
    quad_lth(         1) = 0.0_dp
    quad_lth(quad_nth+1) = pio2_d 

    ! define the angular bins 
    do i=2,quad_nph
       quad_lph(i) = pio2_d * (i-1.0_dp) / (quad_nph)
    end do
    quad_lph(         1) = 0.0_dp
    quad_lph(quad_nph+1) = pio2_d 

    ! make a lr_squared and tan arrays for quick computation
    quad_lr2   (:)  =     quad_lr (:)  ** 2.0_dp
    quad_ltanph(:)  = tan(quad_lph(:)) 
    quad_ltan2th(:) = tan(quad_lth(:)) ** 2.0_dp

    call qgrid_reset()

  end subroutine qgrid_setup

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine qgrid_store(proj,vel,type)
    ! proj (n, (x,y,z) )
    real(kind=dp),dimension(:,:),intent(in) :: proj,vel
    integer (kind=i4b),intent(in)                       :: type
    !----------------------------------------------------------------------
    real(kind=dp)      :: r2,theta,phi,x,y,z,vx,vy,vz
    integer (kind=i4b) :: i,j,n1,n2,n3,store_type
    integer (kind=i4b),save ::ir=1,ith=1,iph=1

    ! Signs of the (vx,vy,vz) for each Projection and type of Orbit
    real (kind=dp),dimension(3,8,5),parameter :: vsgn= reshape((/  &
                                ! X tubes
         1 , 1 , 1    ,-1 , 1 , 1  , -1 , 1 ,-1  ,  1 , 1 , -1 , & 
         1 ,-1 , 1    ,-1 ,-1 , 1  , -1 ,-1 ,-1  ,  1 ,-1 , -1 , & 
                                ! Y tubes
         1 , 1 , 1    , 1 , 1 ,-1  ,  1 ,-1 ,-1  ,  1 ,-1 , 1 , & 
        -1 , 1 , 1    ,-1 , 1 ,-1  , -1 ,-1 ,-1  , -1 ,-1 , 1 , & 
                                ! Z tubes
         1 , 1 , 1    , 1 ,-1 , 1  , -1 ,-1 , 1  , -1 , 1 , 1 , & 
         1 , 1 ,-1    , 1 ,-1 ,-1  , -1 ,-1 ,-1  , -1 , 1 ,-1 , & 
                                ! Boxed 
         1 , 1 , 1    ,-1 , 1 , 1  , -1 ,-1 , 1  ,  1 ,-1 , 1 , & 
         1 , 1 ,-1    ,-1 , 1 ,-1  , -1 ,-1 ,-1  ,  1 ,-1 ,-1 , & 
                                ! Stochastic
         1 , 1 , 1    ,-1 , 1 , 1  , -1 ,-1 , 1  ,  1 ,-1 , 1 , & 
         1 , 1 ,-1    ,-1 , 1 ,-1  , -1 ,-1 ,-1  ,  1 ,-1 ,-1 /),(/3,8,5/))

    !Signs of the x,y,z for each projection  :psgn( [x,y,z], project )  
    real (kind=dp),dimension(3,8),parameter :: psgn= reshape((/  &   
         1 , 1 , 1   , -1 , 1 , 1  , -1 , -1 , 1 ,  1 , -1 , 1 , & 
         1 , 1 ,-1   , -1 , 1 ,-1  , -1 , -1 ,-1 ,  1 , -1 ,-1 /),(/3,8/))


    ! Hunt assumes open boundaries, but our boundaries are closed
    ! So we dont give the outer boundaries to hunt.

    n1 =  size(quad_lr ) - 1
    n2 =  size(quad_lth) - 1 
    n3 =  size(quad_lph) - 1 

    select case ( type )
    case (1)
       store_type = 0
    case (3)
       store_type = 1
    case default
       store_type = 2
    end select

    do i=1,size(proj,1) ! loop over photons

       do j=1,8            ! loop over projections symmetries
          ! Find the one projection that is in the positive octant.
          ! FIXME: Doing this with a loop is stupid.

          x  = proj(i,1) * psgn(1,j)
          y  = proj(i,2) * psgn(2,j)
          z  = proj(i,3) * psgn(3,j)

          ! only store when the photon is in the positive octant
          ! x==0 and z==0 will throw a divide by zero error.
          if ( x>0.0_dp .and. y>=0.0_dp .and. z>0.0_dp ) then
             ! this if is only passed once for every photon.   

             vx = vel (i,1) * vsgn(1,j,type)
             vy = vel (i,2) * vsgn(2,j,type)
             vz = vel (i,3) * vsgn(3,j,type) 

             r2     = (x*x + y*y + z*z)
             theta  = (x*x + y*y)/(z*z) ! sqrt atan 
             phi    = y/x               ! atan

             call hunt (quad_lr2    (2:n1), n1-1, r2   , ir )
             call hunt (quad_ltan2th(2:n2), n2-1, theta, ith)
             call hunt (quad_ltanph (2:n3), n3-1, phi  , iph)

             ! store properties of the photon in the grid
             quadrant_light(1:13,iph+1,ith+1,ir+1) = &
                  quadrant_light(1:13,iph+1,ith+1,ir+1) + &
             (/ 1.0_dp,x,y,z,vx,vy,vz,vx*vx,vy*vy,vz*vz,vx*vy,vy*vz,vz*vx /)
             
             ! store orbit type
             quadrant_light(14+store_type,iph+1,ith+1,ir+1) = &
                  quadrant_light(14+store_type,iph+1,ith+1,ir+1) + 1 
          end if
       end do
    end do

  end subroutine qgrid_store

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine qgrid_setup_write(hdl)
    integer (kind=i4b),intent(in) :: hdl
  !----------------------------------------------------------------------
    ! Write the information about the meridional plane grid. .

    ! remember that N bins have N+1 boundaries
    write (unit=hdl) size(quadrant_light,1),size(quad_lph)-1,size(quad_lth)-1,size(quad_lr)-1
    write (unit=hdl) quad_lr (:)
    write (unit=hdl) quad_lth(:)
    write (unit=hdl) quad_lph(:)

  end subroutine qgrid_setup_write

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine qgrid_write(hdl)
    integer (kind=i4b) ,intent(in):: hdl
    real (kind=dp) :: norm
    integer (kind=i4b) :: i 
  !----------------------------------------------------------------------

    print*,"  * Writing intrisic moment octant"

    where (quadrant_light(1,:,:,:) /= 0.0_dp)
      quadrant_light( 2,:,:,:)=quadrant_light( 2,:,:,:)/quadrant_light(1,:,:,:)
      quadrant_light( 3,:,:,:)=quadrant_light( 3,:,:,:)/quadrant_light(1,:,:,:)
      quadrant_light( 4,:,:,:)=quadrant_light( 4,:,:,:)/quadrant_light(1,:,:,:)
      quadrant_light( 5,:,:,:)=quadrant_light( 5,:,:,:)/quadrant_light(1,:,:,:)
      quadrant_light( 6,:,:,:)=quadrant_light( 6,:,:,:)/quadrant_light(1,:,:,:)
      quadrant_light( 7,:,:,:)=quadrant_light( 7,:,:,:)/quadrant_light(1,:,:,:)
      quadrant_light( 8,:,:,:)=quadrant_light( 8,:,:,:)/quadrant_light(1,:,:,:)
      quadrant_light( 9,:,:,:)=quadrant_light( 9,:,:,:)/quadrant_light(1,:,:,:)
      quadrant_light(10,:,:,:)=quadrant_light(10,:,:,:)/quadrant_light(1,:,:,:)
      quadrant_light(11,:,:,:)=quadrant_light(11,:,:,:)/quadrant_light(1,:,:,:)
      quadrant_light(12,:,:,:)=quadrant_light(12,:,:,:)/quadrant_light(1,:,:,:)
      quadrant_light(13,:,:,:)=quadrant_light(13,:,:,:)/quadrant_light(1,:,:,:)
    end where

    ! Properly normalize the light
    ! by dividing by the total number of photons
    ! contributing to each grid element.
    
    norm = sum (quadrant_light(1,:,:,:))

    where (quadrant_light(1,:,:,:) /= 0.0_dp)
       quadrant_light(1 ,:,:,:) = quadrant_light(1 ,:,:,:) /norm
       quadrant_light(14,:,:,:) = quadrant_light(14,:,:,:) /norm ! orbtype 
       quadrant_light(15,:,:,:) = quadrant_light(15,:,:,:) /norm ! orbtype 
       quadrant_light(16,:,:,:) = quadrant_light(16,:,:,:) /norm ! orbtype 
    end where

    ! write the light quadrant information
    write(unit=hdl) quadrant_light(:,:,:,:)

  end subroutine qgrid_write

end module quadrantgrid

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! July 2002 Sterrewacht Leiden.

module output
! Module doing all the output of the program
use numeric_kinds
implicit none
private

integer   (kind=i4b),private :: out_handle=0_i4b
character (len = 80),public  :: out_file
character (len = 84),private :: out_tmp_file

public :: output_setup

public :: output_close

public :: output_write

contains

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine output_setup()
    use integrator  , only : integrator_setup_write,integrator_set_current,&
         &                   integrator_current
    use histograms  , only : histogram_setup_write
    use histograms  , only :  histogram_setup_write_mass
    use quadrantgrid,only : qgrid_setup_write
  !----------------------------------------------------------------------
    character(len = 8 )  :: d
    character(len =10 )  :: t
    character(len=  5 )  :: g
    integer  (kind=i4b)  :: error,tmp

    print*,"  ** Setting up output module"
    print*,"  * Give the name of the histogram outputfile:"
    read (unit=*, fmt="(a80)"),out_file

    out_file=adjustl(out_file)
    print*,out_file
    
    out_tmp_file=out_file
    out_tmp_file(len_trim(out_file)+1:len_trim(out_file)+4)=".tmp"
    print*,out_tmp_file

    call date_and_time(date=d,time=t,zone=g)
    print*,"  * Date : ",d," ",t," ",g

    out_handle=50
    error=0
    ! Check status and setup files
    open (unit=out_handle+1,iostat=error,file=out_tmp_file,action="write", &
         & status="new",position="rewind")
    if (error==0) then

       if (error/=0) stop "  Error opening file."
       ! Write orbit library header in *binary* (typically orblib.dat)
       open (unit=out_handle,iostat=error,file=out_file,action="write", &
            status="new",form="unformatted")
       call integrator_setup_write(out_handle)
       call qgrid_setup_write   (out_handle)
       call histogram_setup_write  (out_handle)
       close(unit=out_handle,iostat=error)
       if (error/=0) stop "  Error closing file."

       ! Write status file
       write(unit=out_handle+1,fmt=*,iostat=error) integrator_current
       if (error/=0) stop "  Error writing to status file."
       close(unit=out_handle+1,iostat=error)
       if (error/=0) stop "  Error closing status file."
    else
       print*,"  * Trying to resume previous calculations"
       ! Try to read the status file
       open (unit=out_handle+1,iostat=error,file=out_tmp_file,action="read", &
            & status="old",position="rewind")
       if (error/=0) stop "  Error: Inconsistent status file."
       read (unit=out_handle+1,fmt=*) tmp
       if ( tmp==-1 ) stop " Error: Orbit library already finished or orbit &
            & library in inconsistent state"
       call integrator_set_current(tmp)
       close(unit=out_handle+1,iostat=error)
       if (error/=0) stop "  Error closing status file."

       ! Checking if orbit library file exists
       open (unit=out_handle,iostat=error,file=out_file,action="write", &
            & status="old",position="append",form="unformatted")
       if (error/=0) stop "  Error opening library file. Does it exist?"
       close(unit=out_handle,iostat=error)
       if (error/=0) stop "  Error closing library file."
       print*,"  * Resuming with orbit :",tmp+1
    end if

    open (unit=30,file=trim(out_file)//"_orbclass.out", status="replace", &
      action="write")

 
    print*,"  ** Ouput file setup finished."

  end subroutine output_setup

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine output_close()
    use integrator , only : integrator_current
  !----------------------------------------------------------------------
    integer :: error
    print*,"  * Closing files and stopping output module"
    if (out_handle/=0) then
       open (unit=out_handle,iostat=error,file=out_file,action="write", &
            & status="old",position="append",form="unformatted")
       if (error/=0) stop "  Error opening file."
       write(unit=out_handle,iostat=error) " "
       if (error/=0) stop "  Error writing to file. Disk full?"
       close(unit=out_handle,iostat=error)
       if (error/=0) stop "  Error closing file."
    end if

    ! Update the temp file to finished status
    open (unit=out_handle+1,iostat=error,file=out_tmp_file,action="write", &
         & status="old",position="rewind")
    if (error/=0) stop "  Error opening status file."
    write(unit=out_handle+1,fmt=*,iostat=error) -1_i4b, "orbit library &
         & finished ", integrator_current
    if (error/=0) stop "  Error writing to status file."
    close(unit=out_handle+1,iostat=error)
    if (error/=0) stop "  Error closing status file."

    print*," * Finished closing files"

  end subroutine output_close

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine output_write()
    use histograms , only : histogram_write
    use quadrantgrid ,only : qgrid_write
    use integrator , only : integrator_write,integrator_current
  !----------------------------------------------------------------------
    integer :: error
    ! Update the temp file to writing status
    open (unit=out_handle+1,iostat=error,file=out_tmp_file,action="write", &
         & status="old",position="rewind")
    if (error/=0) stop "  Error opening status file."
    write(unit=out_handle+1,fmt=*,iostat=error) -1_i4b,  "Writing orbit: ", &
         & integrator_current-1
    if (error/=0) stop "  Error writing to status file."
    close(unit=out_handle+1,iostat=error)
    if (error/=0) stop "  Error closing status file."

    ! Write the orbit to the *binary* output file (typically orblib.dat).
    open (unit=out_handle,iostat=error,file=out_file,action="write", &
         & status="old",position="append",form="unformatted")
    if (error/=0) stop "  Error opening file."
    call integrator_write(out_handle)
    call qgrid_write   (out_handle)
    call histogram_write  (out_handle)
    close(unit=out_handle,iostat=error)
    if (error/=0) stop "  Error closing file."

    ! Update the temp file to intermediate status
    open (unit=out_handle+1,iostat=error,file=out_tmp_file,action="write", &
         & status="old",position="rewind")
    if (error/=0) stop "  Error opening status file."
    write(unit=out_handle+1,fmt=*,iostat=error) integrator_current
    if (error/=0) stop "  Error writing to status file."
    close(unit=out_handle+1,iostat=error)
    if (error/=0) stop "  Error closing status file."

  end subroutine output_write

end module output

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! July 2002 Sterrenwacht Leiden.

module high_level
  use numeric_kinds
  implicit none
  private

! setup/run/stop the program.
public :: setup,run,stob

contains

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine setup()
    use integrator         , only : integrator_setup
    use projection         , only : projection_setup
    use quadrantgrid       , only : qgrid_setup
    use aperture_routines  , only : aperture_setup
    use histograms         , only : histogram_setup
    use psf                , only : psf_setup
    use output             , only : output_setup
  !----------------------------------------------------------------------
    character(len = 80) :: string
    print *,"  ** Start Setup"
    print *,"  * Give setup version info: [U for unspecified]"
    read *, string
    if (string == "#counterrotation_setupfile_version_1" .or. string=="U") then
       print*,"  * Setupfile is Version 1"
       call integrator_setup()
       call projection_setup()
       call qgrid_setup()
       call psf_setup()
       call aperture_setup()
       call histogram_setup()
       call output_setup()
    else
       print*, "This version is not understood by this program"
       STOP "program terminated in high_level:setup"
    end if

    print *,"  ** Setup Finished"

  end subroutine setup

  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine run()
    use histograms  , only : histogram_reset,hist_thesame, &
         histogram_velbin,histogram_store
    use projection  , only : project,projection_symmetry
    use integrator  , only : integrator_integrate,integrator_points
    use output      , only : output_write
    use quadrantgrid, only : qgrid_reset,qgrid_store
    use psf         , only : psf_n,psf_gaussian
    use aperture         , only : aperture_n,aperture_psf
    use aperture_routines, only : aperture_find

    !----------------------------------------------------------------------
    logical :: done,first,alldone
    real (kind=dp),dimension(integrator_points,3) :: pos
    real (kind=dp),dimension(integrator_points,3) :: vel
    real (kind=dp),dimension(integrator_points*projection_symmetry,2):: proj,vec_gauss
    real (kind=dp),dimension(integrator_points*projection_symmetry  ):: losvel
    integer (kind=i4b),dimension(integrator_points*projection_symmetry):: velb,poly 
    integer (kind=i4b)                                          :: ap,i,pf


    integer (kind=i4b) :: type
    real (kind=dp) :: t1,t2
    alldone=.false.
    print*,"  ** Starting Orbit Calculations"
    do  ! for each orbit
      
       call cpu_time(t1)

       call histogram_reset()
       call qgrid_reset()
       first=.true.
       do ! for all dithers
          call integrator_integrate(pos,vel,type,done,first,alldone)
          first=.false.
          if (done .or. alldone) exit

          call qgrid_store(pos(:,:),vel(:,:),type)
          first = .true.
          do ! for all projections
             call project(type,pos,vel,proj,losvel,done,first)
             if (done) exit
             first = .false.

             if (hist_thesame) call histogram_velbin(1,losvel,velb)
             do i=1,psf_n
                if (.not. hist_thesame) call histogram_velbin(i,losvel,velb)
                   call psf_gaussian(i,proj,vec_gauss)
                do ap=1,aperture_n
                   if ( i == aperture_psf(ap) ) then
                      call aperture_find  (ap,vec_gauss,poly)
                      call histogram_store(ap,poly,velb,size(proj,1))
                   end if
                end do
             end do
          end do
       end do
       if (alldone) exit
       call output_write()
       call cpu_time(t2)
       print*,"  * Time spent one orbit:",t2-t1," seconds"
    end do
    print*,"  ** Finished Orbit Calculations"

  end subroutine run


  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  subroutine stob()
    use integrator        , only : integrator_stop
    use projection        , only : projection_stop
    use histograms        , only : histogram_stop
    use psf               , only : psf_stop
    use aperture_routines , only : aperture_stop
    use output            , only : output_close
  !----------------------------------------------------------------------
    call output_close    ()
    call integrator_stop ()
    call projection_stop ()
    call aperture_stop   ()
    call psf_stop        ()
    call histogram_stop  ()

  end subroutine stob

end module high_level
