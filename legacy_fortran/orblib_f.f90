!######################################################################
!
! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! Sterrewacht Leiden, The Netherlands
!
! HISTORY:
!
! V1.4: MC Verification of intrinsic velocity moments calculation.
!     Fixed significant bug in mergrid_store. Slightly revised
!     implementation
!     to make it easier to check. Independent test of the results
!      still needed
! V2.0: RvdB. Fork for the Triaxial orbit library code.
! V2.0.1 : Changed quadrant grid bins to have more bins.
! V2.0.2 : fix 10**rlogmax in bin setup of qgrid_setup
!          add internal moments
! V2.0.3 : change the zeroth moment grid
! V2.0.4 : add zero psf routine
!          fixed projection
! V3.0.0 : Make intrinisic grid size recipe to be able to numerically
!          Fit the intrinsic mass.
!     RvdB, Leiden, oktober/2005
!
!######################################################################
! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! Sterrewacht Leiden, The Netherlands

module random_gauss_generator
    use numeric_kinds
    implicit none
    private

    ! Seeds the NR random generator
    public :: random_gauss_seed

    ! F version of the gaussian random generator
    ! generate gaussians for a n*m*o array with a width
    public :: random_gauss

    !Generate one 2d gaussian deviate with sigma "width"
    private :: gaussdev

contains

! adapted from NR2.
! Internal computation in SP for speed
    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine gaussdev(x)
        real(kind=dp), intent(out), dimension(:) :: x
        !----------------------------------------------------------------------
        real(kind=sp), dimension(2) :: v
        real(kind=sp) :: rsq
        real(kind=dp) :: ran1

        do
            v(1) = ran1(1)
            v(2) = ran1(1)
!         call random_number(v)
            v = 2.0_sp*v - 1.0_sp
            rsq = sum(v**2)
            if (rsq > 0.0_sp .and. rsq < 1.0_sp) exit
        end do
        x = v*sqrt(-2.0_sp*log(rsq)/rsq)

    end subroutine gaussdev

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine random_gauss_seed()
        !----------------------------------------------------------------------
        logical, save :: initialized = .false.

        print *, "  * Seeding native Random generator"
        if (.not. initialized) then
            ! START reproducible orbit library
            ! uncomment the following line for stochastic orbit library creation
            !call random_seed()
            ! END reproducible orbit library
            print *, "  * Internal Compiler random functions needs to be checked."
            initialized = .true.
        end if

    end subroutine random_gauss_seed

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine random_gauss(t)
        real(kind=dp), dimension(:, :), intent(out) :: t
        !----------------------------------------------------------------------
        integer(kind=i4b)                              :: k

        do k = 1, size(t, 1)
            call gaussdev(t(k, :))
        end do

    end subroutine random_gauss

end module random_gauss_generator

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $
! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! Sterrewacht Leiden, The Netherlands

module integrator
    ! Integrator module. Integrates a point in the MGE potential
    use numeric_kinds
    implicit none
    private

    public  :: integrator_integrate

    public  :: integrator_setup, integrator_set_current

    public  :: integrator_stop, integrator_find_orbtype

    public  :: integrator_setup_write, integrator_write

    private :: real_integrator

    ! current orbit
    integer(kind=i4b), public :: integrator_current

    ! contains the number of points generated by the integrator
    integer(kind=i4b), public :: integrator_points

    ! Starting point to begin with
    integer(kind=i4b), private :: integrator_start

    ! Number of different orbits
    integer(kind=i4b), private :: integrator_number

    ! Number of orbits to integrate for each orbit
    real(kind=dp), private :: integrator_n_orbits

    ! accuracy of integrator
    real(kind=dp), private :: integrator_accuracy

    ! Number of orbit ditherings
    integer(kind=i4b), public :: integrator_dithering

    ! is the current orbital set not regularizble?
    integer(kind=i4b), public :: totalnotregularizable

    ! temporary pos and velocity array for the dense output of the integrator
    real(kind=dp), private, allocatable, dimension(:, :) :: vel_t, pos_t

    ! functions and variables copied from original orblib
    private :: integrator_whichorbit, derivs, SOLOUT
    public :: ini_integ

    ! information about the initial conditions for the orbit integration,
    ! and the grid in integral space.
    real(kind=dp), private, allocatable, dimension(:) :: xini, yini, zini
    real(kind=dp), private, allocatable, dimension(:) :: vxini, vzini
    real(kind=dp), public, allocatable, dimension(:) :: vyini, rcirc
    real(kind=dp), private, allocatable, dimension(:) :: vcirc, tcirc
    integer(kind=i4b), private, allocatable, dimension(:) :: regurizable

    integer(kind=i4b), private, allocatable, dimension(:) :: gEner, gI2, gI3

    integer(kind=i4b), public ::  nEner, nI2, nI3

    integer(kind=i4b), dimension(:), allocatable, private :: integrator_orbittypes
    real(kind=dp), private, allocatable, dimension(:, :)  ::  integrator_moments

    ! store the previously integrated orbit
    real(kind=dp), private, allocatable, dimension(:, :) :: pos_old, vel_old

contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine integrator_set_current(orbit)
        integer(kind=i4b), intent(in):: orbit
        !----------------------------------------------------------------------
        integrator_current = orbit
        Print *, "  * Starting at orbit", orbit + 1
        if (orbit < 0) stop " Can't start at that orbit"
        if (orbit > (nEner*nI2*nI3/integrator_dithering**3) - 1) &
            stop " Not so many orbits"

    end subroutine integrator_set_current

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine integrator_setup()
        use initial_parameters, only: iniparam, orbit_dithering
        !use triaxpotent, only : tp_setup
        use interpolpot, only: ip_setup
        !----------------------------------------------------------------------
        integer(kind=i4b) :: ndith3
        print *, "  ** Setting up integrator module"
        print *, "  * Calling MGE setup"
        call iniparam()
        call ip_setup()
        call ini_integ()
        print *, "  * How many orbits should be integrated?"
        read *, integrator_n_orbits
        print *, "    ", integrator_n_orbits
        if (integrator_n_orbits < 1) stop " Too few orbits"
        print *, "  * How many points should be generated per starting point?"
        read *, integrator_points
        print *, "    ", integrator_points
        integrator_dithering = orbit_dithering
        ndith3 = integrator_dithering**3
        allocate (integrator_orbittypes(ndith3))
        allocate (integrator_moments(5, ndith3))
        if (integrator_points < 1) stop " Too few points"
        print *, "  * At which starting point should be started?"
        read *, integrator_start
        print *, "    ", integrator_start
        call integrator_set_current(integrator_start - 1)
        print *, "  * How many starting points should be integrated?"
        read *, integrator_number
        print *, "    ", integrator_number
        if (integrator_number == -1) integrator_number = &
            (nEner*nI2*nI3/integrator_dithering**3)

        if (integrator_number < 1) stop " To few starting points"
        if (integrator_number > &
             (nEner*nI2*nI3/integrator_dithering**3)) &
             & stop " Too many orbits in total"
        print *, "  * How great should te accuracy be of the integrator?"
        read *, integrator_accuracy
        print *, "    ", integrator_accuracy
        if (integrator_accuracy < 0 .or. 0.5 < integrator_accuracy) &
          & stop " wrong accuracy"

        print *, "  ** integrator module setup finished"

    end subroutine integrator_setup

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine integrator_stop()
        !----------------------------------------------------------------------
        if (allocated(xini)) then
            deallocate (xini, yini, zini, vxini, vyini, vzini, gener, gi2, gi3, &
                        vcirc, tcirc, rcirc, regurizable, vel_old, pos_old)
        end if

        if (allocated(pos_old)) then
            deallocate (pos_old, vel_old)
            deallocate (pos_t, vel_t)
        end if

        close (unit=30)
    end subroutine integrator_stop

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine integrator_integrate(pos, vel, otype, done, first, alldone)
        logical, intent(out):: done, alldone
        logical, intent(in):: first
        real(kind=dp), intent(out), dimension(integrator_points, 3) :: pos
        real(kind=dp), intent(out), dimension(integrator_points, 3) :: vel
        integer(kind=i4b), intent(out) :: otype
        integer(kind=i4b), save :: dith = 0
        integer(kind=i4b)    :: temporbit
        real(kind=dp), dimension(5) :: moments
        !----------------------------------------------------------------------
        alldone = .false.
        if (first) then
            integrator_current = integrator_current + 1
            dith = 0
            totalnotregularizable = 0
            print *, "  * Starting integrating :", integrator_current
        end if
        dith = dith + 1
        if (dith <= integrator_dithering**3 .and. &
            integrator_current <= integrator_number) then

            call integrator_whichorbit(integrator_current, dith, temporbit)

            ! check if there is an unregurizable compenent in this set
            if (regurizable(temporbit) == 1) totalnotregularizable = 1
            !print*,"  * Starting integrating :",integrator_current,dith,temporbit
            call real_integrator(temporbit, pos, vel)
            call integrator_find_orbtype(otype, moments, pos, vel)
            integrator_orbittypes(dith) = otype
            integrator_moments(:, dith) = moments
            done = .false.
        else
            ! integrating done. Set 'done' to true and return.
            pos(:, :) = 0.0_dp
            vel(:, :) = 0.0_dp
            done = .true.
        end if

        if (integrator_current > integrator_number) alldone = .true.

    end subroutine integrator_integrate

!  !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!  subroutine integrator_integrate_nodith(pos,vel,otype,done,first,alldone)
!    logical           ,intent(out):: done,alldone
!    logical           ,intent(in):: first
!    real    (kind=dp ),intent(out),dimension(integrator_points,3) :: pos
!    real    (kind=dp ),intent(out),dimension(integrator_points,3) :: vel
!    integer (kind=i4b),intent(out) :: otype
!    integer (kind=i4b),save :: dith=0
!    integer (kind=i4b)    :: temporbit
!  !----------------------------------------------------------------------
!    if (first) then
!       integrator_current=integrator_current+1
!       dith=(integrator_dithering**3)/2+1
!       totalnotregularizable=0
!       print*,"  * Starting integrating :",integrator_current
!    endif
!    if (first .and. &
!         integrator_current <= integrator_number) then
!
!       call integrator_whichorbit(integrator_current,dith,temporbit)
!
!       ! check if there is an unregurizable compenent in this set
!       if (regurizable(temporbit) == 1) totalnotregularizable=1
!       print*,"  * Starting integrating :",integrator_current,dith,temporbit
!       call real_integrator (temporbit,pos,vel)
!       call integrator_find_orbtype(otype,pos,vel)
!       integrator_orbittypes(dith)=otype
!       done=.false.
!    else
!       ! integrating done. Set 'done' to true and return.
!       pos(:,:)=0.0_dp
!       vel(:,:)=0.0_dp
!       done=.true.
!    end if
!
!    if (integrator_current > integrator_number) alldone=.true.
!
!  end subroutine integrator_integrate_nodith

! This routines finds the orbit dither number
    subroutine integrator_whichorbit(orbit, dith, dithorbit)
        integer(kind=i4b), intent(in)      :: orbit, dith
        integer(kind=i4b), intent(out)     :: dithorbit
        integer(kind=i4b) :: E1, I2, I3, nd
        integer(kind=i4b) :: d1, d2, d3, DO1, DO2, DO3

        nd = integrator_dithering
        ! Reconstruct E, I2 and I3 number from orbit number:
        I3 = modulo((orbit - 1), nI3/nd) + 1
        I2 = modulo(((orbit - 1)/(nI3/nd)), nI2/nd) + 1
        E1 = ((orbit - 1)/(nI3*nI2/(nd*nd))) + 1
        ! Find which orbit dither we are currently at:
        d3 = modulo((dith - 1), nd) + 1
        d2 = modulo(((dith - 1)/nd), nd) + 1
        d1 = ((dith - 1)/(nd*nd)) + 1
        ! combine previous results to find the undithered orbit number
        DO3 = (I3 - 1)*nd + d3
        DO2 = (I2 - 1)*nd + d2
        DO1 = (E1 - 1)*nd + d1
        dithorbit = DO3 + ((DO2 - 1)*nI3) + ((do1 - 1)*nI3*nI2)
    end subroutine integrator_whichorbit

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine real_integrator(orbit, pos, vel)
        integer(kind=i4b), intent(in)                                :: orbit
        real(kind=dp), intent(out), dimension(integrator_points, 3) :: pos
        real(kind=dp), intent(out), dimension(integrator_points, 3) :: vel
        !----------------------------------------------------------------------
        integer(kind=i4b) :: IOUT, IDID, ITOL, i, l
        integer(kind=i4b), parameter :: N = 6, NRDENS = 6, LWORK = 11*N + 8*NRDENS + 21
        integer(kind=i4b), parameter :: LIWORK = NRDENS + 21
        real(kind=dp) :: X, Xend, RTOL, ATOL
        real(kind=dp), dimension(6) :: Y
        real(kind=dp), dimension(lwork) :: WORK
        integer(kind=i4b), dimension(liwork) :: IWORK
        real(kind=dp), dimension(2) :: RPAR
        integer(kind=i4b), dimension(1) :: IPAR
        real(kind=dp), save :: stepsize = 0.0_dp
        real(kind=dp) :: Ebeg, Eend
        integer(kind=i4b), save :: stored_orbit = 0

        if (.NOT. allocated(pos_old)) then
            ! setting up the array for storing the points.
            allocate (pos_old(integrator_points, 3), vel_old(integrator_points, 3))
            allocate (pos_t(integrator_points, 3), vel_t(integrator_points, 3))

        else
            if (integrator_points /= size(pos_old, 1)) then
                deallocate (pos_old, vel_old, pos_t, vel_t)
                allocate (pos_old(integrator_points, 3), vel_old(integrator_points, 3))
                allocate (pos_t(integrator_points, 3), vel_t(integrator_points, 3))
                ! Reset the flag to indicate that we do not have an orbit stored.
                stored_orbit = 0
            end if
        end if

        ! --- REQUIRED TOLERANCE
        ! The integrator keeps the local error on Y(I)
        ! below RTOL(I)*ABS(Y(I)) + ATOL(I).
        ITOL = 0 ! Tolerances are scalars
        RTOL = integrator_accuracy
        ATOL = integrator_accuracy!/10000.0_dp
        ! The Absolutie Tolerance used to be set-up as a vector
        ! ATOL= 1e-6* (/ rcirc(orbit), rcirc(orbit), rcirc(orbit), &
        !                   vcirc(orbit), vcirc(orbit), vcirc(orbit) /)

        Y(1) = xini(orbit)  !  x(0)
        Y(2) = yini(orbit)  !  y(0)
        Y(3) = zini(orbit)  !  z(0)
        Y(4) = vxini(orbit)  ! vx(0)
        Y(5) = vyini(orbit)  ! vy(0)
        Y(6) = vzini(orbit)  ! vz(0)

        ! Compute and store start energy at begin point
        call computer_energy(Y, Ebeg)

        DO  ! While integrating has not succeeded
            ! setting up the array for storing the points.
            ! --- DIMENSION OF THE SYSTEM
            IDID = 0
            ! --- OUTPUT ROUTINE (AND DENSE OUTPUT) IS USED DURING INTEGRATION
            IOUT = 2
            ! --- INITIAL VALUES
            X = 0.0

            Y(1) = xini(orbit)  !  x(0)
            Y(2) = yini(orbit)  !  y(0)
            Y(3) = zini(orbit)  !  z(0)
            Y(4) = vxini(orbit)  ! vx(0)
            Y(5) = vyini(orbit)  ! vy(0)
            Y(6) = vzini(orbit)  ! vz(0)

            ! --- ENDPOINT OF INTEGRATION
            XEND = integrator_n_orbits*tcirc(orbit)
            ! Stepsize. Make sure enough steps are in the integration by adding
            ! room for a couple of  extra steps. RvdB 19/12/04
            RPAR(2) = XEND/(integrator_points + 4)
            RPAR(1) = 0.0 ! Unused

            ! --- VALUES FOR PARAMETERS
            ! Default values are used when IWORK or WORK are zero
            IWORK(:) = 0
            WORK(:) = 0.0_dp
            ! Maximum of allowed steps (just really high) (100000)
            IWORK(1) = max(floor(min(dble(huge(1_i4b) - 1), 1.0_dp/RTOL*integrator_n_orbits/200), kind=i4b), 100000_i4b)
            !number of dense components needed. (all in our case)
            IWORK(5) = NRDENS
            !stiffness detection (negative --> do not try to detect)
            IWORK(4) = -1
            !give guess of stepsize
            WORK(7) = stepsize

            !CALL OF THE SUBROUTINE DOPRI8 ( The dop853 integrator.)
            CALL DOP853(N, derivs, X, Y, XEND, RTOL, ATOL, ITOL, SOLOUT, IOUT, &
                 &                  WORK, LWORK, IWORK, LIWORK, RPAR, IPAR, IDID)

!   IPAR(1)    COUNT   NUMBER OF STORED INTEGRATION STEPS IN pos_t AND vel_t
!   IWORK(17)  NFCN    NUMBER OF FUNCTION EVALUATIONS
!   IWORK(18)  NSTEP   NUMBER OF COMPUTED STEPS
!   IWORK(19)  NACCPT  NUMBER OF ACCEPTED STEPS
!   IWORK(20)  NREJCT  NUMBER OF REJECTED STEPS (DUE TO ERROR TEST),
!                      (STEP REJECTIONS IN THE FIRST STEP ARE NOT COUNTED)
!   print*,"  * Integrator output"
!   print*,iwork(17:20)

            ! compute final energy
            call computer_energy(Y, Eend)

            select case (IDID)
            case (-1)
                stop "integrator:  INPUT IS NOT CONSISTENT,"
            case (-2)
                print *, "integrator:  LARGER NMAX IS NEEDED,"
            case (-3)
                print *, "integrator:  STEP SIZE BECOMES TOO SMALL."
            case (-4)
                stop "integrator:  PROBLEM IS PROBABLY STIFF (INTERRUPTED)."
            case default
                ! Integrating went ok!

                if (abs((Ebeg - Eend)/Ebeg) .lt. 0.01) then
                    ! If Integration conserved energy within 1 percent then do
                    !   - Store pos and vel as failsafe for next orbit integration
                    !   - Swap the points to the correct array.
                    pos(:, :) = pos_t(:, :)
                    pos_old(:, :) = pos_t(:, :)
                    vel_old(:, :) = vel_t(:, :)
                    vel(:, :) = vel_t(:, :)
                    stored_orbit = 1
                    stepsize = work(7)  ! Store integrater stepsize for next itegration
                    EXIT  ! integration was succesfull
                end if
                print *, "Energy conserved to ", (Ebeg - Eend)/Ebeg*100.0_dp, ", Increasing integrator accuracy"
            end select

            if (RTOL .lt. 1e-12_dp) then
                print *, '  * orbit ', orbit, ' failed. Energy conserved up to ', (Ebeg - Eend)/Ebeg*100.0_dp
                ! Orbit integration unsuccesfull even at higher accuracy
                if (stored_orbit .eq. 0) stop 'Abort, No backup orbit stored'
                pos_t(:, :) = pos_old(:, :)
                vel_t(:, :) = vel_old(:, :)
                EXIT ! Integration not succesfull
            end if

            ! Increase accuracy and try again.
            RTOL = RTOL*0.1_dp
            ATOL = ATOL*0.1_dp

            print *, '  * Retrying orbit', orbit
        end do

    end subroutine real_integrator

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine integrator_setup_write(handle)
        integer(kind=i4b), intent(in) :: handle
        integer(kind=i4b)            :: t1, t2, t3, t4
        !----------------------------------------------------------------------
        print *, "  * Writing integrator output header"
        t1 = (nEner*nI2*nI3/integrator_dithering**3)
        t2 = nEner/integrator_dithering
        t3 = nI2/integrator_dithering
        t4 = nI3/integrator_dithering
        write (unit=handle) t1, t2, t3, t4, integrator_dithering

        write (unit=30, fmt=*) Nener*ni2*ni3, integrator_dithering**3

    end subroutine integrator_setup_write

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine integrator_write(hdl)
        integer(kind=i4b), intent(in) :: hdl
        !----------------------------------------------------------------------
        integer(kind=i4b)            :: nd, orbit, I3, I2, E1
        orbit = integrator_current

        nd = integrator_dithering
        ! Reconstruct E, I2 and I3 number from orbit number:
        I3 = modulo((orbit - 1), nI3/nd) + 1
        I2 = modulo(((orbit - 1)/(nI3/nd)), nI2/nd) + 1
        E1 = ((orbit - 1)/(nI3*nI2/(nd*nd))) + 1

        ! write information about the orbit
        write (unit=hdl) orbit, E1, I2, I3, totalnotregularizable
        write (unit=hdl) integrator_orbittypes(:)

        write (unit=30, fmt="(25es13.5)") integrator_moments(:, :)
    end subroutine integrator_write

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine ini_integ()
        !----------------------------------------------------------------------
        character(len=30) :: infil
        integer(kind=i4b) :: i

        print *, "  * Give name of file with begin conditions"
        read (unit=*, fmt="(a30)") infil
        print *, "   ", infil
        open (unit=31, file=infil, status="OLD", action="read", position="rewind")

        read (unit=31, fmt=*) nEner, nI2, nI3

        i = nEner*nI2*nI3

        print *, " * Orbits in the input file"
        print *, nEner, nI2, nI3, i

        IF (.NOT. ALLOCATED(xini)) &
            allocate (xini(i), yini(i), zini(i), vxini(i), vyini(i), vzini(i), rcirc(i), &
                      tcirc(i), vcirc(i), gEner(i), gI2(i), gI3(i), regurizable(i))

        read (unit=31, fmt="(3I5,9ES30.10,I4)") (gener(i), gi2(i), gi3(i), xini(i), &
                                                 yini(i), zini(i), vxini(i), vyini(i), vzini(i), rcirc(i), tcirc(i), &
                                                 vcirc(i), regurizable(i), &
                                                 i=1, nEner*nI2*nI3)

        close (unit=31)

    end subroutine ini_integ

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine derivs(N, xin, yin, dydx, RPAR, IPAR)
        use interpolpot, only: ip_accel
        !use triaxpotent, only : tp_accel
        integer, intent(in)              :: N
        real(kind=dp), intent(in)              :: xin
        real(kind=dp), intent(in), dimension(6) :: yin
        real(kind=dp), intent(out), dimension(6) :: dydx
        real(kind=dp), intent(inout), dimension(2) :: RPAR
        integer(kind=i4b), intent(inout), dimension(1) :: IPAR
        !----------------------------------------------------------------------

        ! subroutine which returns the right-hand side derivatives.
        !   x      = t
        !   yin(1) = x
        !   yin(2) = y
        !   yin(3) = z
        !   yin(4) = dx/dt
        !   yin(5) = dy/dt
        !   yin(6) = dz/dt

        ! First calculate the true accelerations at the given position
        dydx(1:3) = yin(4:6)
        call ip_accel(yin(1), yin(2), yin(3), dydx(4), dydx(5), dydx(6))

    end subroutine derivs

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    SUBROUTINE SOLOUT(NR, XOLD, X, Y, N, CON, ICOMP, ND, RPAR, IPAR, IRTRN)
        ! --- PRINTS SOLUTION AT EQUIDISTANT OUTPUT-POINTS
        ! --- BY USING "CONTD8", THE CONTINUOUS COLLOCATION SOLUTION
        integer, intent(in)    :: NR, N, ND
        real(kind=dp), intent(in)    :: XOLD, X
        integer, intent(inout) :: IRTRN
        real(kind=dp), intent(in), dimension(N)    :: Y
        real(kind=dp), intent(in), dimension(8*ND) :: CON
        integer(kind=i4b), intent(in), dimension(ND)   :: ICOMP
        real(kind=dp), intent(inout), dimension(2)    :: RPAR
        integer(kind=i4b), intent(inout), dimension(1)    :: IPAR
        !----------------------------------------------------------------------
        real(kind=dp), save          :: XOUT
        integer(kind=i4b), save          :: count = 0
        real(kind=dp)               :: contd8, step, rnd
        real(kind=dp)               :: ran1
        step = RPAR(2)
        IF (NR == 1) THEN
            ! Start storing the orbit after 1+? steps to avoid aliasing
            rnd = ran1(1)
!         call random_number(rnd) ! 0 < rnd < 1
            XOUT = X + step*(1.0_dp + rnd)
            count = 0
            IPAR(1) = 0
        ELSE
            do
                ! Make sure count > integrator_points to make sure we do not
                ! go out of bounds on pos_t(:,:). RvdB, DK 16/06/03
                IF (X < XOUT .or. count >= integrator_points) exit
                count = count + 1
                IPAR(1) = count
                pos_t(count, 1) = CONTD8(1, XOUT, CON, ICOMP, ND)
                pos_t(count, 2) = CONTD8(2, XOUT, CON, ICOMP, ND)
                pos_t(count, 3) = CONTD8(3, XOUT, CON, ICOMP, ND)
                vel_t(count, 1) = CONTD8(4, XOUT, CON, ICOMP, ND)
                vel_t(count, 2) = CONTD8(5, XOUT, CON, ICOMP, ND)
                vel_t(count, 3) = CONTD8(6, XOUT, CON, ICOMP, ND)
                XOUT = XOUT + step
            end do
        END IF
    END SUBROUTINE SOLOUT

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine integrator_find_orbtype(type, moments, pos, vel)
        integer(kind=i4b), intent(out) :: type
        real(kind=dp), intent(out), dimension(:) :: moments
        real(kind=dp), intent(in), dimension(:, :) :: pos
        real(kind=dp), intent(in), dimension(size(pos, 1), 3) :: vel
        !----------------------------------------------------------------------
        real(kind=dp) :: lxc, lyc, lzc
        real(kind=dp), dimension(size(pos, 1)) :: t
        real(kind=dp), parameter :: nul = 0.0_dp
        !  Lx = y*Vz-z*Vy
        t = pos(:, 2)*vel(:, 3) - pos(:, 3)*vel(:, 2)
        lxc = maxval(t)*minval(t)
        moments(1) = sum(t)/size(pos, 1)

        !  Ly = z*Vx-x*Vz
        t = pos(:, 3)*vel(:, 1) - pos(:, 1)*vel(:, 3)
        lyc = maxval(t)*minval(t)
        moments(2) = sum(t)/size(pos, 1)

        !  Lz = x*Vy-y*Vx
        t = pos(:, 1)*vel(:, 2) - pos(:, 2)*vel(:, 1)
        lzc = maxval(t)*minval(t)
        moments(3) = sum(t)/size(pos, 1)

        ! assume orbit is chaotic, unless proven otherwise.
        type = 5

        ! X tube
        if (lxc > nul .and. lyc < nul .and. lzc < nul) type = 1
        ! Y tube
        if (lxc < nul .and. lyc > nul .and. lzc < nul) type = 2
        ! Z tube
        if (lxc < nul .and. lyc < nul .and. lzc > nul) type = 3
        ! Box
        if (lxc < nul .and. lyc < nul .and. lzc < nul) type = 4

        ! vector lenghts should be equal, otherwise DIM  is wrong
        !print*,size(sum(pos(:,:)**2,dim=2)) ,  size(pos,1)

        ! mean radius
        moments(4) = sum(sqrt(sum(pos(:, :)**2, dim=2)))/size(pos, 1)

        ! second moment = vxx+vyy+vzz + 2vxy + 2vyz +2vzx
        moments(5) = sum(sum(vel(:, :)**2, dim=2) &
                         + 2*(vel(:, 1)*vel(:, 2) &
                              + vel(:, 2)*vel(:, 3) &
                              + vel(:, 3)*vel(:, 1)))/size(pos, 1)

        !print*,moments(3),moments(5),moments(3)/moments(4)/sqrt(moments(5))
    end subroutine integrator_find_orbtype

    subroutine computer_energy(Y, E)
! Compute the energy of a particle.
        use interpolpot, only: ip_potent
        real(kind=dp), intent(in), dimension(6) :: Y
        real(kind=dp), intent(out) :: E
        real(kind=dp) :: ep
        call ip_potent(y(1), y(2), y(3), Ep)
        E = ep - 0.5_dp*(y(4)**2 + y(5)**2 + y(6)**2)
    end subroutine computer_energy

end module integrator

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! july 2002 Sterrewacht Leiden.

module projection
    ! module doing the circular projection of the orbit.
    use numeric_kinds
    implicit none
    private

    ! Number of projections around axis
    integer(kind=i4b), private :: proj_number

    ! Readin the number of rotation to be done.
    public :: projection_setup, projection_change_direction

    ! stop projection module
    public :: projection_stop

    ! Project pos(3,:),vel(3,:) to proj(2,:),lofvel(:)
    ! Using the n'th projection
    private :: project_n

    ! Project pos(3,:),vel(3,:) to proj(2,:),lofvel(:)
    !Done is set to .true. if all projections are finished
    public :: project

    ! amount of symmetry multipication. ( for triaxial galaxies there are
    ! 8 symmetries per orbit, but we do one (1) at a time.)
    integer(kind=i4b), public, parameter :: projection_symmetry = 1

    real(kind=dp), public :: theta_proj, phi_proj, psi_proj

contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine projection_setup()
        use initial_parameters, only: theta_view, phi_view, psi_view
        !----------------------------------------------------------------------
        print *, "  ** Projection setup"
        print *, "  * 8 Projections for Triaxial model"
        proj_number = 8
        print *, "  * Inclination of the model is (theta,phi): ", theta_view, phi_view, psi_view
        theta_proj = theta_view
        phi_proj = phi_view
        psi_proj = psi_view
        print *, theta_proj, phi_proj, psi_proj
        print *, "  ** Projection setup finished"

    end subroutine projection_setup

    subroutine projection_change_direction()
        !----------------------------------------------------------------------
        real(kind=dp)              :: t1, t2, t3
        print *, "  ** Projection change direction"
        print *, "  * deprojection angles are (theta,phi,psi): ", &
            theta_proj/(pi_d/180.0_dp), phi_proj/(pi_d/180.0_dp), &
            psi_proj/(pi_d/180.0_dp)
        print *, "  * Give new angles (theta, phi, psi):"
        print *, "  * Anwser -501 0 0 to keep current values"
        read *, t1, t2, t3
        print *, t1, t2, t3
        if (t1 > -500) then
            theta_proj = t1*(pi_d/180.0_dp)
            phi_proj = t2*(pi_d/180.0_dp)
            psi_proj = t3*(pi_d/180.0_dp)
        end if
        print *, "  * New deprojection angles are (theta,phi,psi): ", &
            theta_proj/(pi_d/180.0_dp), phi_proj/(pi_d/180.0_dp), &
            psi_proj/(pi_d/180.0_dp)

        print *, theta_proj, phi_proj, psi_proj

    end subroutine projection_change_direction

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine projection_stop()
        !----------------------------------------------------------------------
        ! empty function

    end subroutine projection_stop

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine project_n(type, pos, vel, proj, losvel, n)
!  use initial_parameters, only : theta_view, phi_view
        ! pos( :, (r,z) )
        real(kind=dp), intent(in), dimension(:, :)   :: pos
        ! vel (:, (r,z,theta))
        real(kind=dp), intent(in), dimension(size(pos, 1), 3) :: vel
        ! proj(:,(x',y'))
        real(kind=dp), intent(out), dimension(size(pos, 1), 2)           :: proj
        ! losvd (:)
        real(kind=dp), intent(out), dimension(size(pos, 1))             :: losvel
        integer(kind=i4b), intent(in)                       :: type, n
        !----------------------------------------------------------------------
        real(kind=dp)              :: t1, t2, t3, theta, phi

        ! Signs of the (vx,vy,vz) for each Projection and type of Orbit
        real(kind=dp), dimension(3, 8, 5), &
            parameter :: vsgn = reshape((/ &
                                        ! X tubes
                                        1, 1, 1, -1, 1, 1, -1, 1, -1, 1, 1, -1, &
                                        1, -1, 1, -1, -1, 1, -1, -1, -1, 1, -1, -1, &
                                        ! Y tubes
                                        1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, &
                                        -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, &
                                        ! Z tubes
                                        1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, &
                                        1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, &
                                        ! Boxed
                                        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, &
                                        1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, &
                                        ! Stochastic
                                        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, &
                                        1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1/), (/3, 8, 5/))

        !Signs of the x,y,z for each projection  :psgn( [x,y,z], project )
        real(kind=dp), dimension(3, 8), &
            parameter :: psgn = reshape((/ &
                                        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, &
                                        1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1/), (/3, 8/))

        theta = theta_proj
        phi = phi_proj

        ! check orbit type
        if (type > 5 .or. type < 1) stop "project_n: Wrong orbit type"

        ! Use sign matrix for the symmetries.
        ! Using the inverse (transpose) of the projection (eq. 4) of Thesis Ellen.

        ! x'
        t1 = -sin(phi)*psgn(1, n)
        t2 = cos(phi)*psgn(2, n)
        proj(:, 1) = t1*pos(:, 1) + t2*pos(:, 2)

        ! y'
        t1 = -cos(theta)*cos(phi)*psgn(1, n)
        t2 = -cos(theta)*sin(phi)*psgn(2, n)
        t3 = sin(theta)*psgn(3, n)
        proj(:, 2) = t1*pos(:, 1) + t2*pos(:, 2) + t3*pos(:, 3)

        ! v_LOS
        t1 = sin(theta)*cos(phi)*vsgn(1, n, type)
        t2 = sin(theta)*sin(phi)*vsgn(2, n, type)
        t3 = cos(theta)*vsgn(3, n, type)
        losvel(:) = t1*vel(:, 1) + t2*vel(:, 2) + t3*vel(:, 3)

        !xaa = (-sin(phi)*x+cos(phi)*y)*sin(psi)-(-cos(theta)*cos(phi)*x-cos(theta)*sin(phi)*y+sin(theta)*z)*cos(psi);
        !yaa = (-sin(phi)*x+cos(phi)*y)*cos(psi)+(-cos(theta)*cos(phi)*x-cos(theta)*sin(phi)*y+sin(theta)*z)*sin(psi);

        !  t1 = sin(phi)
        !  t3 = cos(phi)
        !  t5 = -t1*x+t3*y
        !  t6 = sin(psi)
        !  t8 = cos(theta)
        !  t13 = sin(theta)
        !  t15 = -t8*t3*x-t8*t1*y+t13*z
        !  t16 = cos(psi)
        !  v(1) = t5*t6-t15*t16
        !  v(2) = t5*t16+t15*t6

        !  v(1) = x*sin(psi)-y*cos(psi)
        !  v(2) = x*cos(psi)+y*sin(psi)

    end subroutine project_n

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine project(type, pos, vel, proj, lofvel, done, first)
        integer(kind=i4b), intent(in)                        :: type
        real(kind=dp), intent(in), dimension(:, :) :: pos
        real(kind=dp), intent(in), dimension(size(pos, 1), 3) :: vel
        real(kind=dp), intent(out), dimension(size(pos, 1)*projection_symmetry, 2) &
             & :: proj
        real(kind=dp), intent(out), dimension(size(pos, 1)*projection_symmetry) &
             & :: lofvel
        logical, intent(out)                          :: done
        logical, intent(in)                          :: first
        !----------------------------------------------------------------------
        integer(kind=i4b), save :: count = 0

        ! reset counter if this is the first projection for this orbit
        if (first) count = 0
        count = count + 1
        done = .false.

        if (count <= proj_number) then
            call project_n(type, pos, vel, proj, lofvel, count)
        else
            count = proj_number + 1
            done = .true.
            proj(:, :) = 0.0_dp
            lofvel(:) = 0.0_dp
        end if

    end subroutine project

end module projection

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! Sterrewacht Leiden, The Netherlands

module psf
    use numeric_kinds
    implicit none
    private

! * Module for the PSF generation.
! The way PSF are done in this program is quite simple. We just
! take the original point and modify it with a configurable
! random gaussian offset (psf_size).

! how many psf are there?
    integer(kind=i4b), public                           :: psf_n
! kind of psf(psf_n)
    integer(kind=i4b), private, allocatable, dimension(:) :: psf_kind
! size of psf for (n,psf)
    real(kind=dp), private, allocatable, dimension(:, :) :: psf_sigma
! intensity of the psf(n,psf)
    real(kind=dp), private, allocatable, dimension(:, :) :: psf_iten
! (i,j,pf) contains a sigma's in random order for psf pf
    real(kind=dp), private, allocatable, dimension(:, :) :: psf_randomsigma
! setupup of psf variables
    public :: psf_setup
! generate gaussian psf points of input array.
    public :: psf_gaussian

    public :: psf_stop

! Find the sigma of the psf number #.
    public :: psf_cal_sigma

! Generates an array with proportionals sigma's of a MGE-PSF
    private:: psf_sigma_map

contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine psf_stop()
        !----------------------------------------------------------------------
        if (allocated(psf_kind)) then
            deallocate (psf_kind, psf_sigma, psf_iten)
        end if

    end subroutine psf_stop

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine psf_setup()
        use initial_parameters, only: conversion_factor
        use random_gauss_generator, only: random_gauss_seed
        !----------------------------------------------------------------------
        integer(kind=i4b) :: i, j

        print *, "  ** Setting up PSF module"
        print *, "  * How many different psf's?"
        read *, psf_n
        print *, "   ", psf_n
        allocate (psf_kind(psf_n))

        do i = 1, psf_n
            print *, "  * How many gaussians does the ", i, "psf consist of?"
            read *, psf_kind(i)
            print *, psf_kind(i)
            if (psf_kind(i) < 1) stop "gaussian value too low"
        end do

        allocate (psf_sigma(maxval(psf_kind(:)), psf_n))
        allocate (psf_iten(maxval(psf_kind(:)), psf_n))

        do i = 1, psf_n
            print *, "   Intensity, sigma of the gauss for PSF ", i
            do j = 1, psf_kind(i)
                read *, psf_iten(j, i), psf_sigma(j, i)
                print *, psf_iten(j, i), psf_sigma(j, i)
            end do
        end do

        ! convert sizes arcsec to km
        psf_sigma(:, :) = psf_sigma(:, :)*conversion_factor
        call random_gauss_seed()
        call psf_sigma_map()

        print *, "  ** PSF module setup Finished"

    end subroutine psf_setup

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine psf_gaussian(pf, vec, gaus)
        use random_gauss_generator
        integer(kind=i4b), intent(in)               :: pf
        ! input vectors (n,2)
        real(kind=dp), dimension(:, :), intent(in) :: vec
        ! output vectors (n,2)
        real(kind=dp), dimension(:, :), intent(out)::gaus
        !----------------------------------------------------------------------
        real(kind=sp), dimension(size(vec, 1)) :: t
        integer(kind=i4b), dimension(size(vec, 1)) :: ind
        integer(kind=i4b) :: j
        real(kind=dp) :: ran1

        if (psf_kind(pf) == 1) then
            ! One gaussian in this psf
            if (psf_sigma(1, pf) > 1.0_dp) then
                call random_gauss(gaus(:, :))
                gaus(:, :) = vec(:, :) + gaus(:, :)*psf_sigma(1, pf)
            else
                ! psf size is tiny, so no convolution is done.
                gaus(:, :) = vec(:, :)
            end if
        else
            ! MGE PSF. Use the randomsigma to convolve these points
            ! Each sigma has a chance of being used proprotional
            ! to the weight of the corresponding Gaussian component.
            ! M. Cappellari, 14 January 2003
            call random_gauss(gaus(:, :))
            do j = 1, size(vec, 1) ! no forall, want this to be serialized...
                t(j) = ran1(1)
            end do
!         call random_number(t(:))
            ind = t*(size(vec, 1) - 1) + 1 ! n=size(vec,1) random integers in [1,n]
            forall (j=1:2)
                gaus(:, j) = vec(:, j) + gaus(:, j)*psf_randomsigma(ind(:), pf)
            end forall

        end if

    end subroutine psf_gaussian

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine psf_sigma_map()
        use integrator, only: integrator_points
        use projection, only: projection_symmetry
        !----------------------------------------------------------------------

        integer(kind=i4b)                          :: pf
        ! input vectors (n,2)
        integer(kind=i4b)                          :: i, j, sizex, k, o
        real(kind=dp), dimension(:), allocatable :: weightfl
        integer(kind=i4b), dimension(:), allocatable :: weightint
        ! random sigma's
        real(kind=dp) :: offset, total

        print *, "  * Making vectors filled of sigmas for psf convolution."
        sizex = integrator_points*projection_symmetry
        allocate (psf_randomsigma(sizex, psf_n))
        psf_randomsigma(:, :) = 0.0_dp

        do pf = 1, psf_n
            allocate (weightfl(psf_kind(pf)), weightint(psf_kind(pf) + 1))

            ! The weight of each PSF gaussian
            do i = 1, psf_kind(pf)
                weightfl(i) = abs(psf_iten(i, pf))
            end do
            do i = 1, psf_kind(pf)
                ! normalized cumulative sum
                weightint(i + 1) = nint(sum(weightfl(1:i))*((sizex - 1)/sum(weightfl(:)))) + 1
            end do
            ! range [1,sizex]
            weightint(1) = 1_i4b
            weightint(psf_kind(pf) + 1) = sizex

            ! Now we generate an array with the sigmas. Each sigma occurs a
            ! relative weighted amount of times in the array.
            do i = 1, psf_kind(pf)
                do j = weightint(i), weightint(i + 1)
                    psf_randomsigma(j, pf) = psf_sigma(i, pf)
                end do
            end do
            print *, 'Weight divided for psf', pf, ':'
            print *, weightint(:)
            deallocate (weightfl, weightint)
        end do
    end subroutine psf_sigma_map

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine psf_cal_sigma(pf, sigma)
        integer(kind=i4b), intent(in) :: pf
        real(kind=dp), intent(out):: sigma
        !----------------------------------------------------------------------
        sigma = maxval(psf_sigma(:, pf))

    end subroutine psf_cal_sigma

end module psf

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! July 2002 Sterrewacht Leiden.

module aperture
    use numeric_kinds
    implicit none
    private

    ! Total number of apertures
    integer(kind=i4b), public                          :: aperture_n
    ! type of aperture (1=poly,2=box)
    integer(kind=i4b), public, allocatable, dimension(:) :: aperture_type

    ! number of bins in aperture
    integer(kind=i4b), public, allocatable, dimension(:) :: aperture_size
    ! Starting point of the aperture in flat array.
    integer(kind=i4b), public, allocatable, dimension(:) :: aperture_start
    ! To which psf does this aperture belong?
    integer(kind=i4b), public, allocatable, dimension(:) :: aperture_psf
    public :: aper_stop

contains

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aper_stop()
!----------------------------------------------------------------------
        print *, "  * Stopping aperture module"
        if (allocated(aperture_type)) then
            deallocate (aperture_type)
            deallocate (aperture_size)
            deallocate (aperture_start)
        end if
        print *, "  * Aperture module stopped"

    end subroutine aper_stop

end module aperture

!######################################################################
!######################################################################
!######################################################################

module aperture_polygon
    ! module with the functions for the polygon apertures.
    use numeric_kinds
    implicit none
    private

    ! aperture data
    real(kind=dp), Dimension(:, :), private, allocatable :: polygon
    integer(kind=i4b), Dimension(:, :), private, allocatable :: polygon_struct

    ! Input routine
    public :: aperture_poly_readfile

    ! Functions for find points in polygons
    public :: aperture_poly_find

    public :: aper_poly_stop

    private :: aperture_single_polygon

    public :: aperture_poly_field
contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aper_poly_stop()
        !----------------------------------------------------------------------
        if (allocated(polygon)) then
            deallocate (polygon)
            deallocate (polygon_struct)
        end if

    end subroutine aper_poly_stop

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aperture_poly_readfile(handle, aper_n)
        use initial_parameters, only: conversion_factor
        use aperture, only: aperture_type, aperture_size, aperture_start
        integer(kind=i4b), intent(in) :: handle
        integer(kind=i4b), intent(in) :: aper_n
        !----------------------------------------------------------------------
        integer(kind=i4b), save       :: pol_n = 1, pol_s_n = 1
        integer(kind=i4b)            :: i, k, count
        !temporary array's
        real(kind=dp), Dimension(:, :), allocatable :: tr
        integer(kind=i4b), Dimension(:, :), allocatable :: ti

        print *, "  * Reading Polygonal aperture file."

        ! set aperture type
        aperture_type(aper_n) = 1

        ! Read in # polygons
        read (unit=handle, fmt=*) i
        aperture_size(aper_n) = i
        aperture_start(aper_n) = pol_s_n
        print *, "  * File contains ", aperture_size(aper_n), " polygons"

        if (allocated(polygon_struct)) then
            ! funky reallocate. this is the way to do it in ifc.
            allocate (ti(size(polygon_struct, 1), size(polygon, 2)))
            ti(:, :) = polygon_struct(:, :)
            deallocate (polygon_struct)
            allocate (polygon_struct(pol_s_n + i, 2))
            polygon_struct(1:size(ti, 1), 1:size(ti, 2)) = ti(1:size(ti, 1)&
                 &, 1:size(ti, 2))
            deallocate (ti)
        else
            allocate (polygon_struct(pol_s_n + i, 2))
        end if

        polygon_struct(1, 1) = 1
        do k = pol_s_n, i + pol_s_n - 1
            read (unit=handle, fmt=*) polygon_struct(k, 2)
        end do

        count = 0
        do k = pol_s_n, i + pol_s_n - 1

            polygon_struct(k, 1) = (pol_n + count)
            count = count + polygon_struct(k, 2)
        end do

        pol_s_n = i + pol_s_n
        polygon_struct(pol_s_n, 1) = count
        if (allocated(polygon)) then
            ! funky reallocate. this is the way to do it in ifc.
            allocate (tr(size(polygon, 1), size(polygon, 2)))
            tr(:, :) = polygon(:, :)
            deallocate (polygon)
            allocate (polygon(pol_n + count, 2))
            polygon(1:size(tr, 1), 1:size(tr, 2)) = tr(1:size(tr, 1)&
                 &, 1:size(tr, 2))
            deallocate (tr)
        else
            allocate (polygon(pol_n + count, 2))
        end if
        print *, "  * Total amount of vertexes :", count

        read (unit=handle, fmt=*) (polygon(i, 1), polygon(i, 2), i=pol_n, count + pol_n - 1)
        ! convert arcsec to km
        polygon(pol_n:count + pol_n - 1, :) = polygon(pol_n:count + pol_n - 1, :)* &
             & conversion_factor
        pol_n = pol_n + count + 1
        print *, "  * Finished reading file"
        print *, "  "
        print *, "  * Aperture file ", aper_n, " contained :"
        print *, "  *   #pol       #ver      1.x "
        do i = aperture_start(aper_n), aperture_start(aper_n) + aperture_size(aper_n) - 1
            print *, "    ", i, "  ", polygon_struct(i, 2), "  ", &
                 &polygon(polygon_struct(i, 1), 1), polygon_struct(i, 1)
        end do

    end subroutine aperture_poly_readfile

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aperture_poly_find(vec, ap, res)
        use aperture, only: aperture_size, aperture_type, aperture_start
        real(kind=dp), dimension(:, :), intent(in)                         :: vec
        integer(kind=i4b), intent(in)                       :: ap
        integer(kind=i4b), intent(out), dimension(size(vec, 1))            :: res
        !----------------------------------------------------------------------
        integer(kind=i4b)                                               :: i, k
        logical                                                          :: found

        !DEBUG
        if (aperture_type(ap) /= 1) stop "FIXME: BUG in aperture_find_m"

        res(:) = 0
        do k = 1, size(vec, 1)
            do i = 0, aperture_size(ap)
                call aperture_single_polygon(i + aperture_start(ap), vec(k, 1), &
                                             vec(k, 2), found)
                if (found) then
                    res(k) = i + 1
                    exit
                end if
            end do
        end do

    end subroutine aperture_poly_find

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aperture_single_polygon(k, x, y, found)
        integer(kind=i4b), intent(in)  :: k
        real(kind=dp), intent(in)  :: x, y
        logical, intent(out) :: found
        !----------------------------------------------------------------------
        integer(kind=i4b)             :: i, j

        found = .false.
        j = polygon_struct(k, 1) + polygon_struct(k, 2) - 1
        do i = polygon_struct(k, 1), polygon_struct(k, 1) + polygon_struct(k, 2) - 1
            if ((polygon(i, 2) <= y .and. y < polygon(j, 2)) .or. (polygon(j, 2) <= y &
                 & .and. y < polygon(i, 2))) then
                if (x < ((polygon(j, 1) - polygon(i, 1))*(y - polygon(i, 2))/ &
                     & (polygon(j, 2) - polygon(i, 2))) + polygon(i, 1)) found = .not. found
            end if
            j = i
        end do

    end subroutine aperture_single_polygon

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aperture_poly_field(ap, x, y)
        use aperture, only: aperture_size, aperture_start
        integer(kind=i4b), intent(in) :: ap
        real(kind=dp), intent(out), dimension(:) :: x, y
        !----------------------------------------------------------------------
        integer(kind=i4b) :: i
        real(kind=dp) :: d, e
        x(:) = 0.0_dp
        y(:) = 0.0_dp
        ! This do is an example of bad datastructure design.
        do i = polygon_struct(aperture_start(ap), 1), &
             & polygon_struct(aperture_start(ap) + aperture_size(ap) - 1, 1) + &
             & polygon_struct(aperture_start(ap) + aperture_size(ap) - 1, 2) - 1
            d = polygon(i, 1)
            e = polygon(i, 2)
            x(1) = min(d, x(1))
            y(1) = min(e, y(1))
            x(2) = max(d, x(2))
            y(2) = max(e, x(2))
        end do

    end subroutine aperture_poly_field

end module aperture_polygon

!######################################################################
!######################################################################
!######################################################################

module aperture_boxed
    !contains the aperture functions for the square pixel boxed apertures
    use numeric_kinds
    implicit none
    private

    real(kind=dp), private, dimension(:, :), allocatable :: ap_box_size, ap_box_begin
    real(kind=dp), private, dimension(:), allocatable :: ap_box_idx, ap_box_idy
    real(kind=dp), private, dimension(:), allocatable :: ap_box_rot
    integer(kind=i4b), private, dimension(:), allocatable :: ap_box_bx

    ! read in boxed aperture file
    public :: aperture_boxed_readfile

    !figure out in which aperture the points fit.
    public :: aperture_boxed_find

    public :: aper_boxed_stop

    public :: aperture_boxed_field

contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aper_boxed_stop()
        !----------------------------------------------------------------------
        if (allocated(ap_box_size)) then
            deallocate (ap_box_size, ap_box_begin, ap_box_idx, ap_box_idy, ap_box_rot)
            deallocate (ap_box_bx)
        end if

    end subroutine aper_boxed_stop

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aperture_boxed_readfile(handle, aper_n)
        use initial_parameters, only: conversion_factor
        use aperture, only: aperture_type, aperture_size, aperture_start
        integer(kind=i4b), intent(in) :: handle, aper_n
        !----------------------------------------------------------------------
        integer(kind=i4b), save       :: amount = 0
        integer(kind=i4b)            :: biny
        !temporary array's
        real(kind=dp), Dimension(:, :), allocatable     :: tr
        integer(kind=i4b), Dimension(:, :), allocatable :: ti

        print *, "  * Reading boxed aperture file."

        amount = amount + 1

        if (allocated(ap_box_size)) then
            allocate (tr(amount, 7), ti(amount, 1))
            tr(:, :) = 0
            ti(:, :) = 0
            tr(1:amount - 1, 1:2) = ap_box_size(:, 1:2)
            tr(1:amount - 1, 3:4) = ap_box_begin(:, 1:2)
            tr(1:amount - 1, 5) = ap_box_idx(:)
            tr(1:amount - 1, 6) = ap_box_idy(:)
            tr(1:amount - 1, 7) = ap_box_rot(:)
            ti(1:amount - 1, 1) = ap_box_bx(:)

            deallocate (ap_box_size, ap_box_begin, ap_box_bx)
            deallocate (ap_box_idx, ap_box_idy, ap_box_rot)

            allocate (ap_box_size(amount, 2), ap_box_begin(amount, 2))
            allocate (ap_box_bx(amount), ap_box_idx(amount))
            allocate (ap_box_idy(amount), ap_box_rot(amount))

            ap_box_size(:, 1:2) = tr(:, 1:2)
            ap_box_begin(:, 1:2) = tr(:, 3:4)
            ap_box_idx(:) = tr(:, 5)
            ap_box_idy(:) = tr(:, 6)
            ap_box_rot(:) = tr(:, 7)
            ap_box_bx(:) = ti(:, 1)

            deallocate (tr, ti)
        else
            allocate (ap_box_size(1, 2), ap_box_begin(1, 2), ap_box_bx(1))
            allocate (ap_box_idx(1), ap_box_idy(1), ap_box_rot(1))
        end if
        ! set aperture type
        aperture_type(aper_n) = 2

        print *, "  *  Reading box info"
        print *, "  *  Order: begin(x,y)"
        read (unit=handle, fmt=*) ap_box_begin(amount, 1:2)
        print *, "      size(x,y) "
        read (unit=handle, fmt=*) ap_box_size(amount, 1:2)
        print *, "      rotation"
        read (unit=handle, fmt=*) ap_box_rot(amount)
        ap_box_rot(amount) = ap_box_rot(amount)*(pi_d/180.0_dp)
        print *, "      bin(x,y)"
        read (unit=handle, fmt=*) ap_box_bx(amount), biny

        ! convert arcsec into km
        ap_box_begin(amount, :) = ap_box_begin(amount, :)*conversion_factor
        ap_box_size(amount, :) = ap_box_size(amount, :)*conversion_factor

        ap_box_idx(amount) = (ap_box_bx(amount)/ap_box_size(amount, 1))
        ap_box_idy(amount) = (biny/ap_box_size(amount, 2))

        aperture_start(aper_n) = amount
        aperture_size(aper_n) = ap_box_bx(amount)*biny

        print *, "   Total bins ", aperture_size(aper_n)
        print *, "   begin      ", ap_box_begin(amount, :)
        print *, "   size       ", ap_box_size(amount, :)
        print *, "   rotation   ", ap_box_rot(amount)
        print *, "   binx       ", ap_box_bx(amount)
        print *, "   idx,y      ", ap_box_idx(amount), ap_box_idy(amount)
        print *, " "
        print *, "  * Finished reading aperture"

    end subroutine aperture_boxed_readfile

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aperture_boxed_find(ap, vec, res)
        ! vec is a n*m*2 matrix with vectors.
        ! res is an n*m matrix with has the resulting pixel of each vector
        ! ap is the aperture number.
        use aperture, only: aperture_start, aperture_type
        !use initial_parameters, only : psi_view
        use projection, only: psi_proj
        integer(kind=i4b), intent(in)                          :: ap
        real(kind=dp), dimension(:, :), intent(in)              :: vec
        integer(kind=i4b), dimension(size(vec, 1)), intent(out) :: res
        !----------------------------------------------------------------------
        integer(kind=i4b) :: n, j, bx
        real(kind=dp) :: r1, r2, b1, b2, idx, idy, sx, sy, x, y, t, q
        !real (kind=dp), dimension(size(vec,1)) :: t, q, x, y

        !DEBUG
        if (aperture_type(ap) /= 2) stop "FIXME: BUG in aperture_boxed_find"

        ! The number of this aperture in the memory
        n = aperture_start(ap)

        r1 = cos(-ap_box_rot(n) + pio2_d - psi_proj)
        r2 = sin(-ap_box_rot(n) + pio2_d - psi_proj)

        b1 = ap_box_size(n, 1)
        b2 = ap_box_size(n, 2)
        idx = ap_box_idx(n)
        idy = ap_box_idy(n)
        bx = ap_box_bx(n)
        sx = ap_box_begin(n, 1)
        sy = ap_box_begin(n, 2)

! Perform shift after rotation MC, 19/APR/2004
! Meanning of ap_box_begin has changed!

        do j = 1, size(vec, 1)
            t = vec(j, 1)
            q = vec(j, 2)
            x = t*r1 - q*r2 - sx
            res(j) = 0!_i4b
            if (x > 0.0_dp .and. x < b1) then
                y = t*r2 + q*r1 - sy
                if (y > 0.0_dp .and. y < b2) then
                    res(j) = int(x*idx) + int(y*idy)*bx + 1!_i4b
                end if
            end if
        end do

    end subroutine aperture_boxed_find

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aperture_boxed_field(ap, x, y)
        use aperture, only: aperture_start
        integer(kind=i4b), intent(in) :: ap
        real(kind=dp), intent(out), dimension(:) :: x, y
        !----------------------------------------------------------------------
        integer(kind=i4b) :: i, j, n
        real(kind=dp) :: d, e, f, g, r1, r2

        ! The number of this aperture in the memory
        n = aperture_start(ap)
        r1 = cos(ap_box_rot(n))
        r2 = sin(ap_box_rot(n))
        x(:) = 0.0_dp
        y(:) = 0.0_dp
        do i = 1, 2
            f = (i - 1)*ap_box_size(n, 1) + ap_box_begin(n, 1)
            do j = 1, 2
                g = (j - 1)*ap_box_size(n, 2) + ap_box_begin(n, 2)
                d = r1*f - r2*g
                e = r2*f + r1*g
                x(1) = min(d, x(1))
                y(1) = min(e, y(1))
                x(2) = max(d, x(2))
                y(2) = max(e, y(2))
            end do
        end do

    end subroutine aperture_boxed_field

end module aperture_boxed

!######################################################################
!######################################################################
!######################################################################

module aperture_routines
    ! Basic aperture routines
    ! This module is the overhead to call the aperture_* functions
    use numeric_kinds
    use aperture
    implicit none
    private

    public :: aperture_setup

    public :: aperture_stop

    ! Finds aperture numbers corresponding to the VECtors.
    public :: aperture_find

    ! Finds the boundaries (on the sky) of an aperture.
    public :: aperture_field

contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aperture_setup()
        use aperture_polygon, only: aperture_poly_readfile
        use aperture_boxed, only: aperture_boxed_readfile
        use psf, only: psf_n
        !----------------------------------------------------------------------
        integer(kind=i4b)  :: i, handle = 11
        character(len=80) :: file, string
        print *, "  **Aperture setup module"
        print *, "  * How many different apertures?  :"
        read *, aperture_n

        allocate (aperture_size(aperture_n))
        allocate (aperture_start(aperture_n))
        allocate (aperture_type(aperture_n))
        allocate (aperture_psf(aperture_n))
        print *, "  * using ", aperture_n, " aperture(s)"

        do i = 1, aperture_n
            print *, "  * What's the filename of the ", i, " aperture file ? :"
            read *, file
            print *, "  * Reading ", file

            open (unit=handle, file=file, action="read", status="old"&
                 &, position="rewind")
            print *, "  * Checking type."
            read (unit=handle, fmt=*) string

            select case (string)
            case ("#counterrotation_polygon_aperturefile_version_1")
                call aperture_poly_readfile(handle, i)
            case ("#counter_rotation_boxed_aperturefile_version_2")
                call aperture_boxed_readfile(handle, i)
            case default
                print *, "  * Sorry, can only handle:"
                print *, "     #counterrotation_polygon_aperturefile_version_1"
                print *, "     #counter_rotation_boxed_aperturefile_version_2"
                print *, "    This file is of type:"
                print *, "  ", string
                stop " program ended because of wrong input."
            end select

            close (unit=handle)
            print *, "  * To which psf does this aperture belong?"
            read *, aperture_psf(i)
            if (aperture_psf(i) < 1 .or. aperture_psf(i) > psf_n) then
                stop " That PSF does not exist!"
            end if
        end do
        print *, "  ** aperture setup finished"

    end subroutine aperture_setup

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aperture_stop()
        use aperture, only: aper_stop
        use aperture_polygon, only: aper_poly_stop
        use aperture_boxed, only: aper_boxed_stop
        !----------------------------------------------------------------------
        call aper_stop()
        call aper_poly_stop()
        call aper_boxed_stop()

    end subroutine aperture_stop

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aperture_find(ap, v_m, poly)
        use aperture, only: aperture_type
        use aperture_boxed, only: aperture_boxed_find
        use aperture_polygon, only: aperture_poly_find
        integer(kind=i4b), intent(in) :: ap
        real(kind=dp), dimension(:, :), intent(in) :: v_m
        integer(kind=i4b), dimension(size(v_m, 1)), intent(out) :: poly
        !----------------------------------------------------------------------
        select case (aperture_type(ap))
        case (1)
            call aperture_poly_find(v_m, ap, poly)
        case (2)
            call aperture_boxed_find(ap, v_m, poly)
        case default
            print *, " aperture type :", ap, " found"
            stop " Wrong aperture type in aperture_find"
        end select

    end subroutine aperture_find

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine aperture_field(pf, minx, maxx, miny, maxy)
        use aperture, only: aperture_n, aperture_type, aperture_psf
        use aperture_boxed, only: aperture_boxed_field
        use aperture_polygon, only: aperture_poly_field
        use psf, only: psf_n
        integer(kind=i4b), intent(in) :: pf
        real(kind=dp), intent(out) :: maxx, minx, miny, maxy
        !----------------------------------------------------------------------
        logical, save :: initialized = .false.
        real(kind=dp), dimension(:, :), allocatable, save :: f_x, f_y
        integer(kind=i4b) :: i, pfn
        real(kind=dp), dimension(2) :: x, y

        if (.not. initialized) then
            allocate (f_x(psf_n, 2), f_y(psf_n, 2))
            f_x(:, :) = 0.0_dp
            f_y(:, :) = 0.0_dp
            do i = 1, aperture_n
                pfn = aperture_psf(i)
                select case (aperture_type(i))
                case (1)
                    call aperture_poly_field(i, x, y)
                case (2)
                    call aperture_boxed_field(i, x, y)
                case default
                    print *, " aperture type :", i, " found"
                    stop " Wrong aperture type in aperture_field"
                end select
                f_x(pfn, 1) = min(f_x(pfn, 1), x(1))
                f_x(pfn, 2) = max(f_x(pfn, 2), x(2))
                f_y(pfn, 1) = min(f_y(pfn, 1), y(1))
                f_y(pfn, 2) = max(f_y(pfn, 2), y(2))
            end do
            initialized = .true.
        end if

        minx = f_x(pf, 1)
        miny = f_y(pf, 1)
        maxx = f_x(pf, 2)
        maxy = f_y(pf, 2)

    end subroutine aperture_field

end module aperture_routines

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! Sterrenwacht Leiden, The Netherlands

! This Module provides the binning of seperate histgrams.
! Type 0 : Do nothing.
! Type 1 : Sum all the bins with the same order number.

! This module was written to accomodate the Sauron pixel binning.

module binning
    ! Extension to the histogram module.
    ! This module takes care of possible binning of the histogram.
    use numeric_kinds
    implicit none
    private

    ! set's up the binning array's
    public :: binning_setup

    ! deallocate memory
    public :: binning_stop

    ! bin the aperture
    public :: binning_bin

    ! function for binning of type 1
    private :: binning_add_it_up

    ! Type of binning. (0=no binning) (1=simple binning)
    integer(kind=i4b), private, allocatable, dimension(:)   ::  bin_type

    ! The way the boxes should be binned (order,ap)
    integer(kind=i4b), private, allocatable, dimension(:, :) ::  bin_order

    ! The total amount of boxes in the binned boxes
    ! ( actually maxval(binning_order(ap)) )
    integer(kind=i4b), public, allocatable, dimension(:) :: bin_max

    ! size(bin_order(:,ap),1)
    integer(kind=i4b), private, allocatable, dimension(:)   ::  bin_size

contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine binning_stop()
        !----------------------------------------------------------------------
        if (allocated(bin_type)) then
            deallocate (bin_type)
            deallocate (bin_order)
            deallocate (bin_max)
            deallocate (bin_size)
        end if

    end subroutine binning_stop

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine binning_setup()
        use aperture, only: aperture_n
        !----------------------------------------------------------------------
        integer(kind=i4b) :: i
        character(len=80) :: string
        print *, "  * Starting Binning setup"
        allocate (bin_type(aperture_n))
        allocate (bin_max(aperture_n))
        allocate (bin_size(aperture_n))
        bin_max(:) = 0
        bin_size(:) = 0

        do i = 1, aperture_n
            print *, "  * What kind of binning for aperture ", i
            print *, "    0=none 1=added up"
            do
                read *, bin_type(i)
                if (bin_type(i) == 1 .or. bin_type(i) == 0) exit
                print *, "   - Input incorrect try again!"
            end do
            print *, "  * Type:", bin_type(i)
        end do

        print *, "  * Reading binning files"

        do i = 1, aperture_n
            if (bin_type(i) == 1) then
                print *, "  * Aperture: ", i
                print *, "  * Give the filename of the binning file."
                read *, string
                print *, "  * Opening: ", string
                open (unit=30 + i, file=string, action="read", status="old"&
                  &, position="rewind")
                read (unit=30 + i, fmt=*) string
                if (string /= "#Counterrotaton_binning_version_1") &
                    stop " Wrong version of file"
                read (unit=30 + i, fmt=*) bin_size(i)
                print *, "  * bins in this aperture:", bin_size(i)
            end if
        end do

        allocate (bin_order(maxval(bin_size(:)), aperture_n))

        bin_order(:, :) = 0

        do i = 1, aperture_n
            if (bin_type(i) == 1) then
                print *, "  * Reading data of aperture:", i, bin_size(i)
                read (unit=30 + i, fmt=*) bin_order(1:bin_size(i), i)
                close (unit=30 + i)
            end if
        end do

        do i = 1, aperture_n
            if (bin_type(i) == 1) then
                bin_max(i) = maxval(bin_order(:, i))
            end if
        end do
        print *, "  ** Binning module setup finished."

    end subroutine binning_setup

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine binning_bin(ap, h, newsize)
        integer(kind=i4b), intent(in)                     :: ap
        real(kind=dp), intent(in out), dimension(:, :) :: h
        integer(kind=i4b), intent(out)                    :: newsize
        !----------------------------------------------------------------------
        if (bin_type(ap) == 1) then
            call binning_add_it_up(ap, h, newsize)
        else
            newsize = size(h, 1)
        end if

    end subroutine binning_bin

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine binning_add_it_up(ap, h, newsize)
        integer(kind=i4b), intent(in)                        :: ap
        integer(kind=i4b), intent(out)                       :: newsize
        real(kind=dp), intent(in out), dimension(:, :)    :: h
        !----------------------------------------------------------------------
        real(kind=dp), dimension(0:bin_max(ap), size(h, 2)) :: t
        integer(kind=i4b)                                    :: i

        newsize = bin_max(ap)
        t(:, :) = 0.0_dp
        ! check boundaries
        if (newsize > size(h, 1)) stop "Error: binning_add_it_up: new bin&
             &s are bigger then the original "
        if (size(h, 1) /= bin_size(ap)) stop " Wrong number of bins in a bin"

        do i = 1, size(h, 1)
            t(bin_order(i, ap), :) = t(bin_order(i, ap), :) + h(i, :)
        end do

        ! If you assume nothing, there is no way to do this without
        ! copying it back.
        h(1:newsize, :) = t(1:newsize, :)

    end subroutine binning_add_it_up

end module binning

!######################################################################
!######################################################################
!######################################################################

module histograms
! Routines for histogram manipulation
    use numeric_kinds
    implicit none
    private

! histogram data (aperture,vel)
    real(kind=dp), Dimension(:, :), private, allocatable  :: histogram
! hist_basic(n,i) n=aperture number, i=width,center,#bins
    real(kind=dp), Dimension(:, :), public, allocatable  :: hist_basic
! Are the velocity bins all the same?
    logical, public                                      :: hist_thesame
!h_beg,h_end : begin/end of histogram
!h_bin,width : amount of / width of histogram pixels
    real(kind=dp), Dimension(:), private, allocatable  :: h_beg, h_end, h_width
    integer(kind=i4b), Dimension(:), private, allocatable:: h_bin
! h_start(n)  :  where start the first histogram of aperture n
    integer(kind=i4b), Dimension(:), private, allocatable:: h_start
! number of polygons/bins in each histogram for each aperture
    integer(kind=i4b), Dimension(:), private, allocatable:: h_blocks
! number of histograms
    integer(kind=i4b), private                           :: h_n
! number of points stored in histogram ( Used in normalising. )
    real(kind=dp), Dimension(:), private, allocatable     :: h_n_stored
! total number of histograms/constraints  after binning
    integer(kind=i4b), private                           :: h_nconstr

! routines for writing histogram part of output files
    public :: histogram_write, histogram_setup_write
    public :: histogram_write_compat_sparse, histogram_setup_write_mass

! Store velocities in the histogram(n).
    public :: histogram_store

! Calculate the velocity bin from the losvd
    public :: histogram_velbin

! function to reset the histogram for the next orbit
    public :: histogram_reset

    public :: histogram_stop

    public :: histogram_setup

contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine histogram_reset()
        !----------------------------------------------------------------------
        histogram(:, :) = 0.0_dp
        h_n_stored(:) = 0.0_dp

    end subroutine histogram_reset

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine histogram_setup_write(handle)
        integer(kind=i4b), intent(in) :: handle
        !----------------------------------------------------------------------
        integer(kind=i4b) :: t1
        !write information about the kinematical constraints and velocity histogram
        ! original names: nconstr,nvcube,dvcube
        t1 = hist_basic(1, 3)/2.0_sp ! corrected by Remco 20/JAN/2003
        write (unit=handle) h_nconstr, t1, hist_basic(1, 1)/hist_basic(1, 3)

    end subroutine histogram_setup_write

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine histogram_setup_write_mass(handle)
        integer(kind=i4b), intent(in) :: handle
        !----------------------------------------------------------------------
        write (unit=handle, fmt="(i5)") h_nconstr

    end subroutine histogram_setup_write_mass

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine histogram_write(handle)
        use binning, only: binning_bin
        integer(kind=i4b), intent(in) :: handle
        !----------------------------------------------------------------------
        integer(kind=i4b)            :: i, bg, ed
        print *, "  * Normalising and Writing histogram data."

        where (h_n_stored(:) > 0.0_dp)
            h_n_stored(:) = 1.0_dp/h_n_stored(:)
        elsewhere
            h_n_stored(:) = 0.0_dp
        end where

        do i = 1, h_n
            bg = h_start(i)
            ed = h_blocks(i) + h_start(i) - 1
            call binning_bin(i, histogram(bg:ed, 1:h_bin(i)), ed)
            ed = h_start(i) - 1 + ed
            !conversion normalizing
            histogram(bg:ed, 1:h_bin(i)) = h_n_stored(i)*histogram(bg:ed, 1:h_bin(i))
            call histogram_write_compat_sparse(handle, histogram(bg:ed, 1:h_bin(i)))
        end do
    end subroutine histogram_write

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine histogram_write_compat_sparse(handle, t)
        integer(kind=i4b), intent(in) :: handle
        real(kind=dp), dimension(:, :), intent(in) :: t
        !----------------------------------------------------------------------
        integer(kind=i4b) :: ap, b, e, i, k, bout, eout
        do ap = 1, size(t, 1)
            b = 2*hist_basic(1, 3)
            e = -2*hist_basic(1, 3)
            do i = 1, size(t, 2)
                if (t(ap, i) > 0.0_dp) then
                    b = min(b, i)
                    e = max(e, i)
                end if
            end do

            ! write the relevant information for all velocity histograms to file
            k = hist_basic(1, 3)/2.0_sp + 1.0_sp
            bout = b - k
            eout = e - k
            write (unit=handle) bout, eout
            if (b <= e) write (unit=handle) t(ap, b:e)
        end do

    end subroutine histogram_write_compat_sparse

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine histogram_velbin(pf, vel, bin)
        use aperture, only: aperture_psf
        integer(kind=i4b), intent(in) :: pf
        real(kind=dp), dimension(:), intent(in) :: vel
        integer(kind=i4b), dimension(size(vel)), intent(out) :: bin
        !----------------------------------------------------------------------
        integer(kind=i4b) :: i, ap, bins
        real(kind=dp) :: v, beg, width, hend
        ! find an aperture which is in this pf
        do i = 1, h_n
            if (aperture_psf(i) == pf) ap = i
        end do

        beg = h_beg(ap)
        hend = h_end(ap)
        width = h_width(ap)
        bins = h_bin(ap)

        do i = 1, size(vel)
            v = vel(i)
            if (v > beg) then
                if (v < hend) then
                    ! photon lies within the velocity range
                    bin(i) = int(((v - beg)/width)) + 1
                else
                    ! photon lies above the range
                    ! Assign photon to the last velocity bin.
                    bin(i) = bins
                end if
            else
                ! photon lies below the velocity range
                ! assign to first bin
                bin(i) = 1
            end if
        end do

    end subroutine histogram_velbin

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine histogram_store(ap, n, velb, tot)
        integer(kind=i4b), intent(in)  :: ap
        integer(kind=i4b)                                   :: i, k, v
        integer(kind=i4b), dimension(:), intent(in)  :: n
        integer(kind=i4b), dimension(size(n, 1)), intent(in)  :: velb
        integer(kind=i4b), intent(in)  :: tot
        !----------------------------------------------------------------------
        !update number of points stored (including points not stored)
        ! For normalising.
        h_n_stored(ap) = h_n_stored(ap) + tot

        do i = 1, size(n, 1)
            k = n(i)
            if (k /= 0) then
                k = k + h_start(ap) - 1
                v = velb(i)
                histogram(k, v) = histogram(k, v) + 1.0_dp
            end if
        end do

    end subroutine histogram_store

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine histogram_stop()
        use binning, only: binning_stop
        !----------------------------------------------------------------------
        if (allocated(h_bin)) then
            deallocate (hist_basic, h_beg, h_end, h_bin, h_width, h_start, histogram)
        end if
        call binning_stop()

    end subroutine histogram_stop

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine histogram_setup()
        use aperture, only: aperture_n, aperture_size, aperture_psf
        use binning, only: binning_setup, bin_max
        use psf, only: psf_n
        !----------------------------------------------------------------------
        integer(kind=i4b)  :: i, j, ap
        real(kind=dp)  :: width, center, bins

        print *, "  * Starting Histogram module"
        h_n = aperture_n
        allocate (hist_basic(h_n, 3), h_beg(h_n), h_end(h_n), h_bin(h_n))
        allocate (h_width(h_n), h_start(h_n), h_n_stored(h_n), h_blocks(h_n))

        do i = 1, psf_n
            print *, "  * Give for psf ", i, " the histogram width, center and"
            print *, "    amount of bins"
            read *, width, center, bins
            print *, width, center, bins
            if (width <= 0) stop " Width to small"
            if (bins < 1) stop " Too few bins"
            do j = 1, h_n
                if (aperture_psf(j) == i) then
                    hist_basic(j, 1) = width
                    hist_basic(j, 2) = center
                    hist_basic(j, 3) = bins
                end if
            end do
        end do

        h_beg(:) = hist_basic(:, 2) - (0.5_dp*hist_basic(:, 1))
        h_end(:) = hist_basic(:, 2) + (0.5_dp*hist_basic(:, 1))
        h_bin(:) = hist_basic(:, 3)
        h_width(:) = hist_basic(:, 1)/hist_basic(:, 3)

        allocate (histogram(sum(aperture_size(:)), maxval(h_bin(:))))
        print *, "  * Histogram size : ", size(histogram), "=", size(histogram, 1), "*",&
             & size(histogram, 2)

        h_blocks(:) = aperture_size(:)
        i = 1

        do ap = 1, h_n
            h_start(ap) = i
            i = i + h_blocks(ap)
        end do

        call histogram_reset()
        call binning_setup()

        ! Figure out how many histograms there are.
        h_nconstr = 0
        do ap = 1, h_n
            if (bin_max(ap) == 0) then
                h_nconstr = h_nconstr + aperture_size(ap)
            else
                h_nconstr = h_nconstr + bin_max(ap)
            end if
        end do

        ! Figure out if all the velocityhistograms are the same.
        hist_thesame = .true.
        width = hist_basic(1, 1)
        center = hist_basic(1, 2)
        bins = hist_basic(1, 3)
        do ap = 2, h_n
            if (width /= hist_basic(ap, 1)) hist_thesame = .false.
            if (center /= hist_basic(ap, 2)) hist_thesame = .false.
            if (bins /= hist_basic(ap, 3)) hist_thesame = .false.
        end do
        if (hist_thesame) then
            print *, "  * All velocity-bins are the same"
        else
            print *, "  * Velocity-bins are not the same. The standard NNLS will not"
            print *, "  * Understand the ouput correctly."
        end if
        print *, "  ** Histogram module setup finished"

    end subroutine histogram_setup

end module histograms

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! Sterrewacht Leiden, The Netherlands

module quadrantgrid
    use numeric_kinds
    implicit none
    private

    real(kind=dp), private, allocatable, dimension(:, :, :, :) :: quadrant_light
    real(kind=dp), private, allocatable, dimension(:) :: quad_lr, quad_lr2
    real(kind=dp), private, allocatable, dimension(:) :: quad_lth, quad_ltan2th
    real(kind=dp), private, allocatable, dimension(:) :: quad_lph, quad_ltanph

    public  :: qgrid_stop
    public  :: qgrid_write
    public  :: qgrid_setup_write
    public  :: qgrid_reset
    ! Store points in the grid.
    public  :: qgrid_store
    public  :: qgrid_setup
contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine qgrid_stop()
        !----------------------------------------------------------------------
        if (allocated(quadrant_light)) then
            deallocate (quadrant_light)
            deallocate (quad_lr, quad_lth, quad_lph)
            deallocate (quad_lr2, quad_ltan2th, quad_ltanph)
        end if

    end subroutine qgrid_stop

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine qgrid_reset()
        !----------------------------------------------------------------------
        quadrant_light(:, :, :, :) = 0.0_dp
    end subroutine qgrid_reset

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine qgrid_setup()
        use initial_parameters, only: nEner, nI2, nI3, rLogMin, rLogMax, sigobs_km &
                                      , conversion_factor
        use integrator, only: integrator_dithering
        !----------------------------------------------------------------------
        integer(kind=i4b) :: i, quad_nr, quad_nth, quad_nph
        real(kind=dp)  :: inR, psfsize
        print *, "  ** Octant grid module setup"

        quad_nr = 10   !10 !15 ! int(NEner / integrator_dithering*0.55 )
        quad_nth = 6    !4  !4 ! int(nI2   / integrator_dithering ) - 1 ! towards middle axis
        quad_nph = 6    ! 5 !5 ! int(nI3   / integrator_dithering ) - 1 ! towards minor axis

        print *, "  ** Grid dimension:"
        print *, quad_nr, quad_nth, quad_nph

        allocate (quadrant_light(16, quad_nph, quad_nth, quad_nr))
        allocate (quad_lr(quad_nr + 1), quad_lr2(quad_nr + 1))
        allocate (quad_lth(quad_nth + 1), quad_ltan2th(quad_nth + 1))
        allocate (quad_lph(quad_nph + 1), quad_ltanph(quad_nph + 1))

        ! Define a grid in such a way that the boundaries define all possible bins
        ! This also means that there are N+1 boundaries for N bins.

        do i = 2, quad_nr
            quad_lr(i) = 10.0_dp**(rlogmin + (rLogMax - rlogmin + alog10(0.5))*(i - 1.0) &
                                   /(quad_nr - 0.0))
        end do
        quad_lr(1) = 0.0_dp
        quad_lr(quad_nr + 1) = max(10.0_dp**rLogMax*100.0_dp, maxval(sigobs_km)*10.0_dp)

        ! make a lr_squared array for quick computation
        quad_lr2(:) = quad_lr(:)**2_dp

        ! Define the angular bins
        do i = 2, quad_nth
            quad_lth(i) = pio2_d*(i - 1.0_dp)/(quad_nth)
        end do
        quad_lth(1) = 0.0_dp
        quad_lth(quad_nth + 1) = pio2_d

        ! define the angular bins
        do i = 2, quad_nph
            quad_lph(i) = pio2_d*(i - 1.0_dp)/(quad_nph)
        end do
        quad_lph(1) = 0.0_dp
        quad_lph(quad_nph + 1) = pio2_d

        ! make a lr_squared and tan arrays for quick computation
        quad_lr2(:) = quad_lr(:)**2.0_dp
        quad_ltanph(:) = tan(quad_lph(:))
        quad_ltan2th(:) = tan(quad_lth(:))**2.0_dp

        call qgrid_reset()

    end subroutine qgrid_setup

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine qgrid_store(proj, vel, type)
        ! proj (n, (x,y,z) )
        real(kind=dp), dimension(:, :), intent(in) :: proj, vel
        integer(kind=i4b), intent(in)                       :: type
        !----------------------------------------------------------------------
        real(kind=dp)      :: r2, theta, phi, x, y, z, vx, vy, vz
        integer(kind=i4b) :: i, j, n1, n2, n3, store_type
        integer(kind=i4b), save ::ir = 1, ith = 1, iph = 1

        ! Signs of the (vx,vy,vz) for each Projection and type of Orbit
        real(kind=dp), dimension(3, 8, 5), &
            parameter :: vsgn = reshape((/ &
                                        ! X tubes
                                        1, 1, 1, -1, 1, 1, -1, 1, -1, 1, 1, -1, &
                                        1, -1, 1, -1, -1, 1, -1, -1, -1, 1, -1, -1, &
                                        ! Y tubes
                                        1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, &
                                        -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, &
                                        ! Z tubes
                                        1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, &
                                        1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, &
                                        ! Boxed
                                        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, &
                                        1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, &
                                        ! Stochastic
                                        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, &
                                        1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1/), (/3, 8, 5/))

        !Signs of the x,y,z for each projection  :psgn( [x,y,z], project )
        real(kind=dp), dimension(3, 8), &
            parameter :: psgn = reshape((/ &
                                        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, &
                                        1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1/), (/3, 8/))

        ! Hunt assumes open boundaries, but our boundaries are closed
        ! So we dont give the outer boundaries to hunt.

        n1 = size(quad_lr) - 1
        n2 = size(quad_lth) - 1
        n3 = size(quad_lph) - 1

        select case (type)
        case (1)
            store_type = 0
        case (3)
            store_type = 1
        case default
            store_type = 2
        end select

        do i = 1, size(proj, 1) ! loop over photons

            do j = 1, 8            ! loop over projections symmetries
                ! Find the one projection that is in the positive octant.
                ! FIXME: Doing this with a loop is stupid.

                x = proj(i, 1)*psgn(1, j)
                y = proj(i, 2)*psgn(2, j)
                z = proj(i, 3)*psgn(3, j)

                ! only store when the photon is in the positive octant
                ! x==0 and z==0 will throw a divide by zero error.
                if (x > 0.0_dp .and. y >= 0.0_dp .and. z > 0.0_dp) then
                    ! this if is only passed once for every photon.

                    vx = vel(i, 1)*vsgn(1, j, type)
                    vy = vel(i, 2)*vsgn(2, j, type)
                    vz = vel(i, 3)*vsgn(3, j, type)

                    r2 = (x*x + y*y + z*z)
                    theta = (x*x + y*y)/(z*z) ! sqrt atan
                    phi = y/x               ! atan

                    call hunt(quad_lr2(2:n1), n1 - 1, r2, ir)
                    call hunt(quad_ltan2th(2:n2), n2 - 1, theta, ith)
                    call hunt(quad_ltanph(2:n3), n3 - 1, phi, iph)

                    ! store properties of the photon in the grid
                    quadrant_light(1:13, iph + 1, ith + 1, ir + 1) = &
                        quadrant_light(1:13, iph + 1, ith + 1, ir + 1) + &
                        (/1.0_dp, x, y, z, vx, vy, vz, vx*vx, vy*vy, vz*vz, vx*vy, vy*vz, vz*vx/)

                    ! store orbit type
                    quadrant_light(14 + store_type, iph + 1, ith + 1, ir + 1) = &
                        quadrant_light(14 + store_type, iph + 1, ith + 1, ir + 1) + 1
                end if
            end do
        end do

    end subroutine qgrid_store

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine qgrid_setup_write(hdl)
        integer(kind=i4b), intent(in) :: hdl
        !----------------------------------------------------------------------
        ! Write the information about the meridional plane grid. .

        ! remember that N bins have N+1 boundaries
        write (unit=hdl) size(quadrant_light, 1), size(quad_lph) - 1, size(quad_lth) - 1, size(quad_lr) - 1
        write (unit=hdl) quad_lr(:)
        write (unit=hdl) quad_lth(:)
        write (unit=hdl) quad_lph(:)

    end subroutine qgrid_setup_write

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine qgrid_write(hdl)
        integer(kind=i4b), intent(in):: hdl
        real(kind=dp) :: norm
        integer(kind=i4b) :: i
        !----------------------------------------------------------------------

        print *, "  * Writing intrisic moment octant"

        where (quadrant_light(1, :, :, :) /= 0.0_dp)
            quadrant_light(2, :, :, :) = quadrant_light(2, :, :, :)/quadrant_light(1, :, :, :)
            quadrant_light(3, :, :, :) = quadrant_light(3, :, :, :)/quadrant_light(1, :, :, :)
            quadrant_light(4, :, :, :) = quadrant_light(4, :, :, :)/quadrant_light(1, :, :, :)
            quadrant_light(5, :, :, :) = quadrant_light(5, :, :, :)/quadrant_light(1, :, :, :)
            quadrant_light(6, :, :, :) = quadrant_light(6, :, :, :)/quadrant_light(1, :, :, :)
            quadrant_light(7, :, :, :) = quadrant_light(7, :, :, :)/quadrant_light(1, :, :, :)
            quadrant_light(8, :, :, :) = quadrant_light(8, :, :, :)/quadrant_light(1, :, :, :)
            quadrant_light(9, :, :, :) = quadrant_light(9, :, :, :)/quadrant_light(1, :, :, :)
            quadrant_light(10, :, :, :) = quadrant_light(10, :, :, :)/quadrant_light(1, :, :, :)
            quadrant_light(11, :, :, :) = quadrant_light(11, :, :, :)/quadrant_light(1, :, :, :)
            quadrant_light(12, :, :, :) = quadrant_light(12, :, :, :)/quadrant_light(1, :, :, :)
            quadrant_light(13, :, :, :) = quadrant_light(13, :, :, :)/quadrant_light(1, :, :, :)
        end where

        ! Properly normalize the light
        ! by dividing by the total number of photons
        ! contributing to each grid element.

        norm = sum(quadrant_light(1, :, :, :))

        where (quadrant_light(1, :, :, :) /= 0.0_dp)
            quadrant_light(1, :, :, :) = quadrant_light(1, :, :, :)/norm
            quadrant_light(14, :, :, :) = quadrant_light(14, :, :, :)/norm ! orbtype
            quadrant_light(15, :, :, :) = quadrant_light(15, :, :, :)/norm ! orbtype
            quadrant_light(16, :, :, :) = quadrant_light(16, :, :, :)/norm ! orbtype
        end where

        ! write the light quadrant information
        write (unit=hdl) quadrant_light(:, :, :, :)

    end subroutine qgrid_write

end module quadrantgrid

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! July 2002 Sterrewacht Leiden.

module output
! Module doing all the output of the program
    use numeric_kinds
    implicit none
    private

    integer(kind=i4b), private :: out_handle = 0_i4b
    character(len=80), public  :: out_file
    character(len=84), private :: out_tmp_file

    public :: output_setup

    public :: output_close

    public :: output_write

contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine output_setup()
        use integrator, only: integrator_setup_write, integrator_set_current,&
             &                   integrator_current
        use histograms, only: histogram_setup_write
        use histograms, only: histogram_setup_write_mass
        use quadrantgrid, only: qgrid_setup_write
        !----------------------------------------------------------------------
        character(len=8)  :: d
        character(len=10)  :: t
        character(len=5)  :: g
        integer(kind=i4b)  :: error, tmp

        print *, "  ** Setting up output module"
        print *, "  * Give the name of the histogram outputfile:"
        read (unit=*, fmt="(a80)"), out_file

        out_file = adjustl(out_file)
        print *, out_file

        out_tmp_file = out_file
        out_tmp_file(len_trim(out_file) + 1:len_trim(out_file) + 4) = ".tmp"
        print *, out_tmp_file

        call date_and_time(date=d, time=t, zone=g)
        print *, "  * Date : ", d, " ", t, " ", g

        out_handle = 50
        error = 0
        ! Check status and setup files
        open (unit=out_handle + 1, iostat=error, file=out_tmp_file, action="write", &
             & status="new", position="rewind")
        if (error == 0) then

            if (error /= 0) stop "  Error opening file."
            ! Write orbit library header in *binary* (typically orblib.dat)
            open (unit=out_handle, iostat=error, file=out_file, action="write", &
                  status="new", form="unformatted")
            call integrator_setup_write(out_handle)
            call qgrid_setup_write(out_handle)
            call histogram_setup_write(out_handle)
            close (unit=out_handle, iostat=error)
            if (error /= 0) stop "  Error closing file."

            ! Write status file
            write (unit=out_handle + 1, fmt=*, iostat=error) integrator_current
            if (error /= 0) stop "  Error writing to status file."
            close (unit=out_handle + 1, iostat=error)
            if (error /= 0) stop "  Error closing status file."
        else
            print *, "  * Trying to resume previous calculations"
            ! Try to read the status file
            open (unit=out_handle + 1, iostat=error, file=out_tmp_file, action="read", &
                 & status="old", position="rewind")
            if (error /= 0) stop "  Error: Inconsistent status file."
            read (unit=out_handle + 1, fmt=*) tmp
            if (tmp == -1) stop " Error: Orbit library already finished or orbit &
                 & library in inconsistent state"
            call integrator_set_current(tmp)
            close (unit=out_handle + 1, iostat=error)
            if (error /= 0) stop "  Error closing status file."

            ! Checking if orbit library file exists
            open (unit=out_handle, iostat=error, file=out_file, action="write", &
                 & status="old", position="append", form="unformatted")
            if (error /= 0) stop "  Error opening library file. Does it exist?"
            close (unit=out_handle, iostat=error)
            if (error /= 0) stop "  Error closing library file."
            print *, "  * Resuming with orbit :", tmp + 1
        end if

        open (unit=30, file=trim(out_file)//"_orbclass.out", status="replace", &
              action="write")

        print *, "  ** Ouput file setup finished."

    end subroutine output_setup

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine output_close()
        use integrator, only: integrator_current
        !----------------------------------------------------------------------
        integer :: error
        print *, "  * Closing files and stopping output module"
        if (out_handle /= 0) then
            open (unit=out_handle, iostat=error, file=out_file, action="write", &
                 & status="old", position="append", form="unformatted")
            if (error /= 0) stop "  Error opening file."
            write (unit=out_handle, iostat=error) " "
            if (error /= 0) stop "  Error writing to file. Disk full?"
            close (unit=out_handle, iostat=error)
            if (error /= 0) stop "  Error closing file."
        end if

        ! Update the temp file to finished status
        open (unit=out_handle + 1, iostat=error, file=out_tmp_file, action="write", &
             & status="old", position="rewind")
        if (error /= 0) stop "  Error opening status file."
        write (unit=out_handle + 1, fmt=*, iostat=error) - 1_i4b, "orbit library &
             & finished ", integrator_current
        if (error /= 0) stop "  Error writing to status file."
        close (unit=out_handle + 1, iostat=error)
        if (error /= 0) stop "  Error closing status file."

        print *, " * Finished closing files"

    end subroutine output_close

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine output_write()
        use histograms, only: histogram_write
        use quadrantgrid, only: qgrid_write
        use integrator, only: integrator_write, integrator_current
        !----------------------------------------------------------------------
        integer :: error
        ! Update the temp file to writing status
        open (unit=out_handle + 1, iostat=error, file=out_tmp_file, action="write", &
             & status="old", position="rewind")
        if (error /= 0) stop "  Error opening status file."
        write (unit=out_handle + 1, fmt=*, iostat=error) - 1_i4b, "Writing orbit: ", &
             & integrator_current - 1
        if (error /= 0) stop "  Error writing to status file."
        close (unit=out_handle + 1, iostat=error)
        if (error /= 0) stop "  Error closing status file."

        ! Write the orbit to the *binary* output file (typically orblib.dat).
        open (unit=out_handle, iostat=error, file=out_file, action="write", &
             & status="old", position="append", form="unformatted")
        if (error /= 0) stop "  Error opening file."
        call integrator_write(out_handle)
        call qgrid_write(out_handle)
        call histogram_write(out_handle)
        close (unit=out_handle, iostat=error)
        if (error /= 0) stop "  Error closing file."

        ! Update the temp file to intermediate status
        open (unit=out_handle + 1, iostat=error, file=out_tmp_file, action="write", &
             & status="old", position="rewind")
        if (error /= 0) stop "  Error opening status file."
        write (unit=out_handle + 1, fmt=*, iostat=error) integrator_current
        if (error /= 0) stop "  Error writing to status file."
        close (unit=out_handle + 1, iostat=error)
        if (error /= 0) stop "  Error closing status file."

    end subroutine output_write

end module output

!######################################################################
!######################################################################
!######################################################################

! $Id: orblib_f.f90,v 1.3 2011/10/25 08:48:45 bosch Exp $

! Written by Remco van den Bosch <bosch@strw.leidenuniv.nl>
! July 2002 Sterrenwacht Leiden.

module high_level
    use numeric_kinds
    implicit none
    private

! setup/run/stop the program.
    public :: setup, run, stob

contains

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine setup()
        use integrator, only: integrator_setup
        use projection, only: projection_setup
        use quadrantgrid, only: qgrid_setup
        use aperture_routines, only: aperture_setup
        use histograms, only: histogram_setup
        use psf, only: psf_setup
        use output, only: output_setup
        !----------------------------------------------------------------------
        character(len=80) :: string
        print *, "  ** Start Setup"
        print *, "  * Give setup version info: [U for unspecified]"
        read *, string
        if (string == "#counterrotation_setupfile_version_1" .or. string == "U") then
            print *, "  * Setupfile is Version 1"
            call integrator_setup()
            call projection_setup()
            call qgrid_setup()
            call psf_setup()
            call aperture_setup()
            call histogram_setup()
            call output_setup()
        else
            print *, "This version is not understood by this program"
            STOP "program terminated in high_level:setup"
        end if

        print *, "  ** Setup Finished"

    end subroutine setup

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine run()
        use histograms, only: histogram_reset, hist_thesame, &
                              histogram_velbin, histogram_store
        use projection, only: project, projection_symmetry
        use integrator, only: integrator_integrate, integrator_points
        use output, only: output_write
        use quadrantgrid, only: qgrid_reset, qgrid_store
        use psf, only: psf_n, psf_gaussian
        use aperture, only: aperture_n, aperture_psf
        use aperture_routines, only: aperture_find

        !----------------------------------------------------------------------
        logical :: done, first, alldone
        real(kind=dp), dimension(integrator_points, 3) :: pos
        real(kind=dp), dimension(integrator_points, 3) :: vel
        real(kind=dp), dimension(integrator_points*projection_symmetry, 2):: proj, vec_gauss
        real(kind=dp), dimension(integrator_points*projection_symmetry):: losvel
        integer(kind=i4b), dimension(integrator_points*projection_symmetry):: velb, poly
        integer(kind=i4b)                                          :: ap, i, pf

        integer(kind=i4b) :: type
        real(kind=dp) :: t1, t2
        alldone = .false.
        print *, "  ** Starting Orbit Calculations"
        do  ! for each orbit

            call cpu_time(t1)

            call histogram_reset()
            call qgrid_reset()
            first = .true.
            do ! for all dithers
                call integrator_integrate(pos, vel, type, done, first, alldone)
                first = .false.
                if (done .or. alldone) exit

                call qgrid_store(pos(:, :), vel(:, :), type)
                first = .true.
                do ! for all projections
                    call project(type, pos, vel, proj, losvel, done, first)
                    if (done) exit
                    first = .false.

                    if (hist_thesame) call histogram_velbin(1, losvel, velb)
                    do i = 1, psf_n
                        if (.not. hist_thesame) call histogram_velbin(i, losvel, velb)
                        call psf_gaussian(i, proj, vec_gauss)
                        do ap = 1, aperture_n
                            if (i == aperture_psf(ap)) then
                                call aperture_find(ap, vec_gauss, poly)
                                call histogram_store(ap, poly, velb, size(proj, 1))
                            end if
                        end do
                    end do
                end do
            end do
            if (alldone) exit
            call output_write()
            call cpu_time(t2)
            print *, "  * Time spent one orbit:", t2 - t1, " seconds"
        end do
        print *, "  ** Finished Orbit Calculations"

    end subroutine run

    !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    subroutine stob()
        use integrator, only: integrator_stop
        use projection, only: projection_stop
        use histograms, only: histogram_stop
        use psf, only: psf_stop
        use aperture_routines, only: aperture_stop
        use output, only: output_close
        !----------------------------------------------------------------------
        call output_close()
        call integrator_stop()
        call projection_stop()
        call aperture_stop()
        call psf_stop()
        call histogram_stop()

    end subroutine stob

end module high_level
