! *******************************************************************
! COPYRIGHT (c) 1995 Council for the Central Laboratory
!         of the Research Councils, RMCS, and NAG
! All rights reserved.
!
! None of the comments in this Copyright notice between the lines
! of asterisks shall be removed or altered in any way.
!
! This Package is intended for compilation without modification,
! so most of the embedded comments have been removed.
!
! ALL USE IS SUBJECT TO LICENCE. For full details of the ACADEMIC
! SOFTWARE LICENCE, see http://hsl.rl.ac.uk/hsl2007/cou/academic.html
!
! Please note that for an ACADEMIC Licence:
!
! 1. The Packages may only be used for academic research or teaching
!    purposes by the Licensee, and must not be copied by the Licensee for
!    use by any other persons. Use of the Packages in any commercial
!    application shall be subject to prior written agreement between
!    Hyprotech UK Limited and the Licensee on suitable terms and
!    conditions, which will include financial conditions.
! 2. All information on the Package is provided to the Licensee on the
!    understanding that the details thereof are confidential.
! 3. All publications issued by the Licensee that include results obtained
!    with the help of one or more of the Packages shall acknowledge the
!    use of the Packages. The Licensee will notify the Numerical Analysis
!    Group at Rutherford Appleton Laboratory (STFC) of any such publication.
! 4. The Packages may be modified by or on behalf of the Licensee
!    for such use in research applications but at no time shall such
!    Packages or modifications thereof become the property of the
!    Licensee. The Licensee shall make available free of charge to the
!    copyright holder for any purpose all information relating to
!    any modification.
! 5. Neither STFC nor Hyprotech UK Limited shall be liable for any
!    direct or consequential loss or damage whatsoever arising out of
!    the use of Packages by the Licensee.
! *******************************************************************
!
! Original date 7 Nov 2001
! 7 November 2001 Made threadsafe.

! 12th July 2004 Version 1.0.0. Version numbering added.

! 20th December 2005 Version 1.1.0. STAT initialized in FINALIZE.

MODULE HSL_AD02_FORWARD_DOUBLE
  IMPLICIT NONE
  PRIVATE
  INTEGER, PARAMETER :: WP = KIND(0D0)
  INTEGER, PARAMETER :: HEAP_SIZE=1000
  INTEGER, PARAMETER :: INIT_ERR = 1
  INTEGER, PARAMETER :: ALLOC_ERR = 3
  INTEGER, PARAMETER :: SQRT_ERR = 5
  INTEGER, PARAMETER :: POW1_ERR = 6
  INTEGER, PARAMETER :: POW2_ERR = 7
  INTEGER, PARAMETER :: SIGN_WARN = 8
  INTEGER, PARAMETER :: ABS_WARN = 9
  INTEGER, PARAMETER :: INT_WARN = 10
  INTEGER, PARAMETER :: AINT_WARN = 11
  INTEGER, PARAMETER :: NINT_WARN = 12
  INTEGER, PARAMETER :: ANINT_WARN = 13
  INTEGER, PARAMETER :: MAX_WARN = 14
  INTEGER, PARAMETER :: MIN_WARN = 15
  INTEGER, PARAMETER :: EQ_WARN = 16
  INTEGER, PARAMETER :: NE_WARN = 17
  INTEGER, PARAMETER :: GT_WARN = 18
  INTEGER, PARAMETER :: LT_WARN = 19
  INTEGER, PARAMETER :: GE_WARN = 20
  INTEGER, PARAMETER :: LE_WARN = 21
  INTEGER, PARAMETER :: UNDEF_WARN = 33
  INTEGER, PARAMETER :: ASSIGNMENT_WARN = 34
    INTEGER :: AD02_FLAG(40)=0
    INTEGER :: ERROR_MESSAGE_UNIT=6
    INTEGER :: WARNING_MESSAGE_UNIT=6
    INTEGER :: ERROR_PRINT_LEVEL=1
    INTEGER :: ERROR_STOP_LEVEL=1
  TYPE, PUBLIC :: AD02_DATA
!????    PRIVATE
    INTEGER LEVEL
    INTEGER, POINTER :: IBINCO(:,:)=>NULL()
    INTEGER, POINTER :: FLAGS(:)=>NULL()
    INTEGER :: ERROR_MESSAGE_UNIT = 6
    INTEGER :: WARNING_MESSAGE_UNIT = 6
    INTEGER :: ERROR_PRINT_LEVEL = 1
    INTEGER :: ERROR_STOP_LEVEL = 1
    REAL (WP), POINTER :: RHEAP(:)=>NULL()
    INTEGER, POINTER :: IHEAP(:)=>NULL()
    INTEGER, POINTER :: IPONT(:)=>NULL()
    INTEGER, POINTER :: RPTR(:)=>NULL()
    INTEGER, POINTER :: RLENG(:)=>NULL()
    INTEGER, POINTER :: NVARS(:)=>NULL()
    INTEGER DEAD_POINTER
    INTEGER IPTOS
    INTEGER IHTOS
    INTEGER IRTOS
    INTEGER SIZE_X
    INTEGER REAL_STRUCT_SIZE
    INTEGER SWITCH_POINT
    INTEGER :: CASE = -1
    INTEGER :: MAX_CASE = 1
  END TYPE AD02_DATA
  TYPE, PUBLIC :: AD02_REAL
    PRIVATE
    INTEGER :: P = -1
    INTEGER :: CASE
    TYPE(AD02_DATA), POINTER :: DATA => NULL()
  END TYPE AD02_REAL
  INTERFACE OPERATOR (+)
    MODULE PROCEDURE ADD_DD, ADD_RD, ADD_DR, ADD_ID, ADD_DI
    MODULE PROCEDURE ADD_DS, ADD_SD
  END INTERFACE
  PUBLIC OPERATOR (+)
  INTERFACE OPERATOR (-)
    MODULE PROCEDURE MINUS_D, MINUS_DD, MINUS_RD, MINUS_DR
    MODULE PROCEDURE MINUS_ID, MINUS_DI
    MODULE PROCEDURE MINUS_DS, MINUS_SD
  END INTERFACE
  PUBLIC OPERATOR (-)
  INTERFACE OPERATOR (*)
    MODULE PROCEDURE MULT_DD, MULT_RD, MULT_DR, MULT_ID, MULT_DI
    MODULE PROCEDURE MULT_DS, MULT_SD
  END INTERFACE
  PUBLIC OPERATOR (*)
  INTERFACE OPERATOR (/)
    MODULE PROCEDURE DIV_DD, DIV_RD, DIV_DR, DIV_ID, DIV_DI
    MODULE PROCEDURE DIV_DS, DIV_SD
  END INTERFACE
  PUBLIC OPERATOR (/)
  INTERFACE OPERATOR (**)
    MODULE PROCEDURE POW_DD, POW_RD, POW_DR, POW_DI, POW_ID
    MODULE PROCEDURE POW_DS, POW_SD
  END INTERFACE
  PUBLIC OPERATOR (**)
  INTERFACE OPERATOR (==)
    MODULE PROCEDURE EQ_DD, EQ_RD, EQ_DR, EQ_ID, EQ_DI
    MODULE PROCEDURE EQ_DS, EQ_SD
  END INTERFACE
  PUBLIC OPERATOR (==)
  INTERFACE OPERATOR (<=)
    MODULE PROCEDURE LE_DD, LE_RD, LE_DR, LE_ID, LE_DI
    MODULE PROCEDURE LE_DS, LE_SD
  END INTERFACE
  PUBLIC OPERATOR (<=)
  INTERFACE OPERATOR (<)
    MODULE PROCEDURE LT_DD, LT_RD, LT_DR, LT_DI, LT_ID
    MODULE PROCEDURE LT_DS, LT_SD
  END INTERFACE
  PUBLIC OPERATOR (<)
  INTERFACE OPERATOR (>=)
    MODULE PROCEDURE GE_DD, GE_RD, GE_DR, GE_ID, GE_DI
    MODULE PROCEDURE GE_DS, GE_SD
  END INTERFACE
  PUBLIC OPERATOR (>=)
  INTERFACE OPERATOR (>)
    MODULE PROCEDURE GT_DD, GT_RD, GT_DR, GT_DI, GT_ID
    MODULE PROCEDURE GT_DS, GT_SD
  END INTERFACE
  PUBLIC OPERATOR (>)
  INTERFACE OPERATOR (/=)
    MODULE PROCEDURE NE_DD, NE_RD, NE_DR, NE_ID, NE_DI
    MODULE PROCEDURE NE_DS, NE_SD
  END INTERFACE
  PUBLIC OPERATOR (/=)
  INTERFACE ASSIGNMENT (=)
    MODULE PROCEDURE ASSIGN_DR, ASSIGN_DD, ASSIGN_DI, ASSIGN_ID
    MODULE PROCEDURE ASSIGN_DS
    MODULE PROCEDURE ASSIGN_DD1, ASSIGN_DD2, ASSIGN_DD3
    MODULE PROCEDURE ASSIGN_DD4, ASSIGN_DD5, ASSIGN_DD6, ASSIGN_DD7
    MODULE PROCEDURE ASSIGN_DD10, ASSIGN_DD20, ASSIGN_DD30
    MODULE PROCEDURE ASSIGN_DD40, ASSIGN_DD50, ASSIGN_DD60, ASSIGN_DD70
  END INTERFACE
  PUBLIC ASSIGNMENT (=)
  INTERFACE AD02_CONTROL
    MODULE PROCEDURE CONTROL1,CONTROL2
  END INTERFACE
  PUBLIC AD02_CONTROL
  INTERFACE AD02_FLAGS
    MODULE PROCEDURE FLAGS1,FLAGS2,FLAGS3,FLAGS4
  END INTERFACE
  PUBLIC AD02_FLAGS
  INTERFACE AD02_DATA_UNDEFINED
    MODULE PROCEDURE DATA_UNDEFINED
  END INTERFACE
  PUBLIC AD02_DATA_UNDEFINED
  INTERFACE AD02_DERIVS
    MODULE PROCEDURE DERIVS_S
  END INTERFACE
  PUBLIC AD02_DERIVS
  INTERFACE AD02_FINALIZE_DATA
    MODULE PROCEDURE FINALIZE
  END INTERFACE
  PUBLIC AD02_FINALIZE_DATA
  INTERFACE AD02_GRAD
    MODULE PROCEDURE GRAD0, GRAD1
  END INTERFACE
  PUBLIC AD02_GRAD
  INTERFACE AD02_HESSIAN
    MODULE PROCEDURE HESSIAN0, HESSIAN1
  END INTERFACE
  PUBLIC AD02_HESSIAN
  INTERFACE AD02_INITIALIZE_COMP
    MODULE PROCEDURE INITIALIZE_0, INITIALIZE_11, INITIALIZE_10
  END INTERFACE
  PUBLIC AD02_INITIALIZE_COMP
  INTERFACE AD02_INITIALIZE_DATA
    MODULE PROCEDURE INITIALIZE_DATA
  END INTERFACE
  PUBLIC AD02_INITIALIZE_DATA
  INTERFACE AD02_TEMP
    MODULE PROCEDURE MAKE_TEMP
  END INTERFACE
  PUBLIC AD02_TEMP
  INTERFACE AD02_UNDEFINE
    MODULE PROCEDURE UNDEFINE_REAL0, UNDEFINE_REAL1
    MODULE PROCEDURE UNDEFINE_REAL2, UNDEFINE_REAL3
    MODULE PROCEDURE UNDEFINE_REAL4, UNDEFINE_REAL5
    MODULE PROCEDURE UNDEFINE_REAL6, UNDEFINE_REAL7
  END INTERFACE
  PUBLIC AD02_UNDEFINE
  INTERFACE AD02_UNDEFINED
    MODULE PROCEDURE UNDEFINED
  END INTERFACE
  PUBLIC AD02_UNDEFINED
  INTERFACE AD02_USER
    MODULE PROCEDURE USER
  END INTERFACE
  PUBLIC AD02_USER
  INTERFACE AD02_VALUE
    MODULE PROCEDURE VALUE_SCALAR, VALUE_ARRAY
  END INTERFACE
  PUBLIC AD02_VALUE
  INTERFACE ABS
    MODULE PROCEDURE ABS_D
  END INTERFACE
  PUBLIC ABS
  INTERFACE ACOS
    MODULE PROCEDURE ACOS_D
  END INTERFACE
  PUBLIC ACOS
  INTERFACE AINT
    MODULE PROCEDURE AINT_D
  END INTERFACE
  PUBLIC AINT
  INTERFACE ANINT
    MODULE PROCEDURE ANINT_D
  END INTERFACE
  PUBLIC ANINT
  INTERFACE ASIN
    MODULE PROCEDURE ASIN_D
  END INTERFACE
  PUBLIC ASIN
  INTERFACE ATAN
    MODULE PROCEDURE ATAN_D
  END INTERFACE
  PUBLIC ATAN
  INTERFACE ATAN2
    MODULE PROCEDURE ATAN2_DD, ATAN2_RD, ATAN2_DR
    MODULE PROCEDURE ATAN2_DS, ATAN2_SD
  END INTERFACE
  PUBLIC ATAN2
  INTERFACE COS
    MODULE PROCEDURE COS_D
  END INTERFACE
  PUBLIC COS
  INTERFACE COSH
    MODULE PROCEDURE COSH_D
  END INTERFACE
  PUBLIC COSH
  INTERFACE DERIVS
    MODULE PROCEDURE DERIVS_R, DERIVS_I
  END INTERFACE
  INTERFACE EXP
    MODULE PROCEDURE EXP_D
  END INTERFACE
  PUBLIC EXP
  INTERFACE INT
    MODULE PROCEDURE INT_D
  END INTERFACE
  PUBLIC INT
  INTERFACE LOG10
    MODULE PROCEDURE LOG10_D
  END INTERFACE
  PUBLIC LOG10
  INTERFACE LOG
    MODULE PROCEDURE LOG_D
  END INTERFACE
  PUBLIC LOG
  INTERFACE MAX
    MODULE PROCEDURE MAX_DD, MAX_DR, MAX_RD
    MODULE PROCEDURE MAX_DS, MAX_SD
  END INTERFACE
  PUBLIC MAX
  INTERFACE MIN
    MODULE PROCEDURE MIN_DD, MIN_DR, MIN_RD
    MODULE PROCEDURE MIN_DS, MIN_SD
  END INTERFACE
  PUBLIC MIN
  INTERFACE NINT
    MODULE PROCEDURE NINT_D
  END INTERFACE
  PUBLIC NINT
  INTERFACE SIGN
    MODULE PROCEDURE SIGN_DD, SIGN_DR, SIGN_RD
    MODULE PROCEDURE SIGN_DS, SIGN_SD
  END INTERFACE
  PUBLIC SIGN
  INTERFACE SIN
    MODULE PROCEDURE SIN_D
  END INTERFACE
  PUBLIC SIN
  INTERFACE SINH
    MODULE PROCEDURE SINH_D
  END INTERFACE
  PUBLIC SINH
  INTERFACE SQRT
    MODULE PROCEDURE SQRT_D
  END INTERFACE
  PUBLIC SQRT
  INTERFACE TAN
    MODULE PROCEDURE TAN_D
  END INTERFACE
  PUBLIC TAN
  INTERFACE TANH
    MODULE PROCEDURE TANH_D
  END INTERFACE
  PUBLIC TANH
  INTERFACE DABS
    MODULE PROCEDURE ABS_D
  END INTERFACE
  PUBLIC DABS
  INTERFACE DACOS
    MODULE PROCEDURE ACOS_D
  END INTERFACE
  PUBLIC DACOS
  INTERFACE DASIN
    MODULE PROCEDURE ASIN_D
  END INTERFACE
  PUBLIC DASIN
  INTERFACE DATAN
    MODULE PROCEDURE ATAN_D
  END INTERFACE
  PUBLIC DATAN
  INTERFACE DATAN2
    MODULE PROCEDURE ATAN2_DD, ATAN2_RD, ATAN2_DR
    MODULE PROCEDURE ATAN2_DS, ATAN2_SD
  END INTERFACE
  PUBLIC DATAN2
  INTERFACE DBLE
    MODULE PROCEDURE REAL_D
  END INTERFACE
  PUBLIC DBLE
  INTERFACE DCOS
    MODULE PROCEDURE COS_D
  END INTERFACE
  PUBLIC DCOS
  INTERFACE DCOSH
    MODULE PROCEDURE COSH_D
  END INTERFACE
  PUBLIC DCOSH
  INTERFACE DEXP
    MODULE PROCEDURE EXP_D
  END INTERFACE
  PUBLIC DEXP
  INTERFACE DINT
    MODULE PROCEDURE AINT_D
  END INTERFACE
  PUBLIC DINT
  INTERFACE DLOG10
    MODULE PROCEDURE LOG10_D
  END INTERFACE
  PUBLIC DLOG10
  INTERFACE DLOG
    MODULE PROCEDURE LOG_D
  END INTERFACE
  PUBLIC DLOG
  INTERFACE DMAX1
    MODULE PROCEDURE MAX_DD, MAX_DR, MAX_RD
    MODULE PROCEDURE MAX_DS, MAX_SD
  END INTERFACE
  PUBLIC DMAX1
  INTERFACE DMIN1
    MODULE PROCEDURE MIN_DD, MIN_DR, MIN_RD
    MODULE PROCEDURE MIN_DS, MIN_SD
  END INTERFACE
  PUBLIC DMIN1
  INTERFACE DNINT
    MODULE PROCEDURE ANINT_D
  END INTERFACE
  PUBLIC DNINT
  INTERFACE DSIGN
    MODULE PROCEDURE SIGN_DD, SIGN_DR, SIGN_RD
    MODULE PROCEDURE SIGN_DS, SIGN_SD
  END INTERFACE
  PUBLIC DSIGN
  INTERFACE DSIN
    MODULE PROCEDURE SIN_D
  END INTERFACE
  PUBLIC DSIN
  INTERFACE DSINH
    MODULE PROCEDURE SINH_D
  END INTERFACE
  PUBLIC DSINH
  INTERFACE DSQRT
    MODULE PROCEDURE SQRT_D
  END INTERFACE
  PUBLIC DSQRT
  INTERFACE DTAN
    MODULE PROCEDURE TAN_D
  END INTERFACE
  PUBLIC DTAN
  INTERFACE DTANH
    MODULE PROCEDURE TANH_D
  END INTERFACE
  PUBLIC DTANH
  INTERFACE IDINT
    MODULE PROCEDURE INT_D
  END INTERFACE
  PUBLIC IDINT
  INTERFACE IDNINT
    MODULE PROCEDURE NINT_D
  END INTERFACE
  PUBLIC IDNINT
CONTAINS
  FUNCTION ABS_D(A)
    TYPE (AD02_REAL) :: ABS_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    REAL (WP), ALLOCATABLE :: DERF(:)
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(ABS_D,A,'ABS')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(ABS_D,A,'ABS')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VA = DATA%RHEAP(DATA%RPTR(A%P))
      DERF(0) = ABS(VA)
      IF (ABS(VA)==0.0_WP) THEN
        CALL ERROR_HANDLER(DATA,ABS_WARN)
        CALL RANDOM_NUMBER(DERF(1))
        DERF(1) = (DERF(1)-0.5_WP)*2.0_WP
      ELSE
        DERF(1) = SIGN(1.0_WP,VA)
      END IF
      DERF(2:DATA%LEVEL) = 0.0_WP
      CALL UNARY(A,ABS_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION ABS_D
  FUNCTION ACOS_D(X)
    TYPE (AD02_REAL) :: ACOS_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I, N
    REAL (WP) VG, Z, ZH, T
    REAL (WP), ALLOCATABLE :: COEFF(:), NCOEFF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    REAL (WP), ALLOCATABLE :: DERF(:)
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ACOS_D,X,'ACOS')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ACOS_D,X,'ACOS')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      ALLOCATE(COEFF(DATA%LEVEL+1),NCOEFF(DATA%LEVEL+1))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
      DERF(0) = ACOS(VG)
      Z = (1.0_WP-VG**2)
      ZH = -1.0_WP/SQRT(Z)
      DERF(1) = ZH
      COEFF(1) = ZH
      DO N = 1, DATA%LEVEL - 1
        IF (MOD(N,2)==1) THEN
          NCOEFF(1) = COEFF(1)*N/Z
          DO I = 2, (N+1)/2 - 1
            NCOEFF(I) = COEFF(I)*(N+(I-1)*2)/Z + COEFF(I+1)*(I*2)
          END DO
          NCOEFF((N+1)/2) = COEFF((N+1)/2)*(2*N-1)/Z
        ELSE
          NCOEFF(1) = COEFF(1)
          DO I = 2, N/2
            NCOEFF(I) = COEFF(I-1)*(N+1+(I-2)*2)/Z + COEFF(I)*(I*2-1)
          END DO
          NCOEFF(N/2+1) = COEFF(N/2)*(2*N-1)/Z
        END IF
        T = 0.0_WP
        DO I = 1, N/2 + 1
          T = T + NCOEFF(I)*VG**(2*(I-1)+MOD(N,2))
          COEFF(I) = NCOEFF(I)
        END DO
        DERF(N+1) = T
      END DO
      CALL UNARY(X,ACOS_D,DERF)
      DEALLOCATE(DERF,COEFF,NCOEFF)
    END IF
  END FUNCTION ACOS_D
  FUNCTION ADD_DD(A,B)
    TYPE (AD02_REAL) :: ADD_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    INTEGER N1, N2, N3, I, J, I1, I2, I3, I4, I5, LEVEL, REAL_ST_SIZE
    INTEGER, ALLOCATABLE :: LVARS(:)
    INTEGER, ALLOCATABLE :: IREF1(:)
    INTEGER, ALLOCATABLE :: IREF2(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ADD_DD%DATA => DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(ADD_DD,A,B,'+')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(ADD_DD,A,B,'+')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(ADD_DD,A,B,'+')
    ELSE
      ADD_DD%CASE = -DATA%CASE
    LEVEL = DATA%LEVEL
    N1 = DATA%NVARS(A%P)
    N2 = DATA%NVARS(B%P)
    IF (N1==DATA%SIZE_X) THEN
      IF (N2==DATA%SIZE_X) THEN
      IF (A%CASE<0) THEN
        I1 = DATA%RPTR(A%P) - 1
        I2 = DATA%RPTR(B%P) - 1
        DO I = 1, DATA%REAL_STRUCT_SIZE
          DATA%RHEAP(I1+I) = DATA%RHEAP(I1+I) + DATA%RHEAP(I2+I)
        END DO
        ADD_DD%P = A%P
        ADD_DD%CASE = -DATA%CASE
        DATA%RPTR(ADD_DD%P) = DATA%RPTR(A%P)
        CALL USED(B)
      ELSE IF (B%CASE<0) THEN
        I1 = DATA%RPTR(A%P) - 1
        I2 = DATA%RPTR(B%P) - 1
        DO I = 1, DATA%REAL_STRUCT_SIZE
          DATA%RHEAP(I2+I) = DATA%RHEAP(I1+I) + DATA%RHEAP(I2+I)
        END DO
        ADD_DD%P = B%P
        ADD_DD%CASE = -DATA%CASE
        DATA%RPTR(ADD_DD%P) = DATA%RPTR(B%P)
      ELSE
        CALL GETMEM(0,DATA%REAL_STRUCT_SIZE,ADD_DD)
        DATA%RHEAP => DATA%RHEAP
        DATA%RPTR => DATA%RPTR
        DO I = 0, DATA%REAL_STRUCT_SIZE-1
          DATA%RHEAP(DATA%RPTR(ADD_DD%P)+I) = &
             DATA%RHEAP(DATA%RPTR(A%P)+I) + DATA%RHEAP(DATA%RPTR(B%P)+I)
        END DO
      END IF
      RETURN
      ELSE IF (A%CASE<0 .AND. DATA%LEVEL<=2) THEN
        I1 = DATA%RPTR(A%P)
        I2 = DATA%RPTR(B%P)
        I3 = DATA%IPONT(B%P) - 1
        DATA%RHEAP(I1) = DATA%RHEAP(I1) + DATA%RHEAP(I2)
        DO I = 1, N2
          I4 = DATA%IHEAP(I3+I)
          I2 = I2 + 1
          DATA%RHEAP(I1+I4) = DATA%RHEAP(I1+I4) + DATA%RHEAP(I2)
        END DO
        IF(LEVEL==2)THEN
          DO I = 1, N2
            I5 = I1 + DATA%SIZE_X + (DATA%IHEAP(I3+I)*(DATA%IHEAP(I3+I)-1))/2
            DO J = 1, I
              I4 = DATA%IHEAP(I3+J)
              I2 = I2 + 1
              DATA%RHEAP(I5+I4) = DATA%RHEAP(I5+I4) + DATA%RHEAP(I2)
            END DO
          END DO
        END IF
        ADD_DD%P = A%P
        ADD_DD%CASE = -DATA%CASE
        DATA%RPTR(ADD_DD%P) = DATA%RPTR(A%P)
        CALL USED(B)
        RETURN
      ELSE
        GO TO 10
      END IF
    END IF
10    I1 = DATA%IPONT(A%P)
      I2 = DATA%IPONT(B%P)
      ALLOCATE(LVARS(0:DATA%SIZE_X),IREF1(DATA%SIZE_X),IREF2(DATA%SIZE_X))
      CALL MERGE(I1,I2,N1,N2,DATA,LVARS,IREF1,IREF2)
      N3 = LVARS(0)
      REAL_ST_SIZE = DATA%IBINCO(LEVEL+N3,LEVEL)
      CALL GETMEM(N3,REAL_ST_SIZE,ADD_DD)
      J = DATA%IPONT(ADD_DD%P)
      DO I = 1, N3
          DATA%IHEAP(J) = LVARS(I)
          J = J + 1
      END DO
      J = DATA%RPTR(ADD_DD%P)
      DO I = 1, REAL_ST_SIZE
          DATA%RHEAP(J) = 0.0_WP
          J = J + 1
      END DO
      CALL EXPAND(IREF1(1:N1),N3,DATA)
      DO I = 1, DATA%RLENG(A%P)
        DATA%RHEAP(DATA%IHEAP(DATA%SIZE_X+I)+DATA%RPTR(ADD_DD%P)) = &
           DATA%RHEAP(DATA%RPTR(A%P)+I-1)
      END DO
      CALL EXPAND(IREF2(1:N2),N3,DATA)
      DO I = 1, DATA%RLENG(B%P)
         DATA%RHEAP(DATA%IHEAP(DATA%SIZE_X+I)+DATA%RPTR(ADD_DD%P)) = &
           DATA%RHEAP(DATA%IHEAP(DATA%SIZE_X+I)+DATA%RPTR(ADD_DD%P)) + &
           DATA%RHEAP(DATA%RPTR(B%P)+I-1)
     END DO
      IF ((N3>=DATA%SWITCH_POINT) .AND. (N3/=DATA%SIZE_X)) &
        CALL SPARSE_TO_FULL(ADD_DD)
      DEALLOCATE(LVARS,IREF1,IREF2)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION ADD_DD
  FUNCTION ADD_DI(A,B)
    TYPE (AD02_REAL) :: ADD_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    CALL COPY(ADD_DI,ADD_DR(A,REAL(B,WP)))
  END FUNCTION ADD_DI
  FUNCTION ADD_DR(A,B)
    TYPE (AD02_REAL) :: ADD_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ADD_DR%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(ADD_DR,A,'+')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(ADD_DR,A,'+')
    ELSE
      ADD_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
        DATA%RHEAP(DATA%RPTR(A%P)) = DATA%RHEAP(DATA%RPTR(A%P)) + B
        ADD_DR%P = A%P
        ADD_DR%CASE = -DATA%CASE
      ELSE
        CALL ADD_CONST(A,B,ADD_DR)
      END IF
    END IF
  END FUNCTION ADD_DR
  FUNCTION ADD_DS(A,B)
    TYPE (AD02_REAL) :: ADD_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(ADD_DS,ADD_DR(A,REAL(B,WP)))
  END FUNCTION ADD_DS
  FUNCTION ADD_ID(A,B)
    TYPE (AD02_REAL) :: ADD_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ADD_ID,ADD_DR(B,REAL(A,WP)))
  END FUNCTION ADD_ID
  FUNCTION ADD_RD(A,B)
    TYPE (AD02_REAL) :: ADD_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ADD_RD,ADD_DR(B,A))
  END FUNCTION ADD_RD
  FUNCTION ADD_SD(A,B)
    TYPE (AD02_REAL) :: ADD_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ADD_SD,ADD_DR(B,REAL(A,WP)))
  END FUNCTION ADD_SD
  FUNCTION AINT_D(A)
    TYPE (AD02_REAL) :: AINT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    AINT_D%DATA => DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AINT')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AINT')
    ELSE
      AINT_D%CASE = -DATA%CASE
      VA = DATA%RHEAP(DATA%RPTR(A%P))
      IF (VA==AINT(VA)) CALL ERROR_HANDLER(DATA,AINT_WARN)
      AINT_D = AINT(VA)
    END IF
  END FUNCTION AINT_D
  FUNCTION ANINT_D(A)
    TYPE (AD02_REAL) ANINT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ANINT_D%DATA => DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'ANINT')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'ANINT')
    ELSE
      ANINT_D%CASE = -DATA%CASE
      VA = DATA%RHEAP(DATA%RPTR(A%P))
      IF (ABS(VA-AINT(VA))*2.0_WP==1.0_WP) CALL ERROR_HANDLER(DATA,ANINT_WARN)
      ANINT_D = ANINT(VA)
    END IF
  END FUNCTION ANINT_D
  FUNCTION ASIN_D(X)
    TYPE (AD02_REAL) :: ASIN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I, N
    REAL (WP) VG, Z, ZH, T
    REAL (WP),ALLOCATABLE :: COEFF(:), NCOEFF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    REAL (WP), ALLOCATABLE :: DERF(:)
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ASIN_D,X,'ASIN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ASIN_D,X,'ASIN')
    ELSE
    ALLOCATE(COEFF(DATA%LEVEL+1),NCOEFF(DATA%LEVEL+1))
    ALLOCATE(DERF(0:DATA%LEVEL+4))
    VG = DATA%RHEAP(DATA%RPTR(X%P))
    DERF(0) = ASIN(VG)
    Z = (1.0_WP-VG**2)
    ZH = 1.0_WP/SQRT(Z)
    DERF(1) = ZH
    COEFF(1) = ZH
    DO N = 1, DATA%LEVEL - 1
      IF (MOD(N,2)==1) THEN
        NCOEFF(1) = COEFF(1)*N/Z
        DO I = 2, (N+1)/2 - 1
          NCOEFF(I) = COEFF(I)*(N+(I-1)*2)/Z + COEFF(I+1)*(I*2)
        END DO
        NCOEFF((N+1)/2) = COEFF((N+1)/2)*(2*N-1)/Z
      ELSE
        NCOEFF(1) = COEFF(1)
        DO I = 2, N/2
          NCOEFF(I) = COEFF(I-1)*(N+1+(I-2)*2)/Z + COEFF(I)*(I*2-1)
        END DO
        NCOEFF(N/2+1) = COEFF(N/2)*(2*N-1)/Z
      END IF
      T = 0.0_WP
      DO I = 1, N/2 + 1
        T = T + NCOEFF(I)*VG**(2*(I-1)+MOD(N,2))
        COEFF(I) = NCOEFF(I)
      END DO
      DERF(N+1) = T
    END DO
    CALL UNARY(X,ASIN_D,DERF)
    DEALLOCATE(DERF)
    END IF
  END FUNCTION ASIN_D
  SUBROUTINE ASSIGN_DD(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    INTEGER I,J,NI, NR
    LOGICAL :: OVERWRITE
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(A,B,'Assign')
      RETURN
    ELSE IF (DATA%CASE/=ABS(B%CASE) ) THEN
      CALL UNARY_WARNING(A,B,'Assign')
      RETURN
    END IF
    IF (A%P==-1) THEN
       OVERWRITE = .FALSE.
    ELSE IF (.NOT. ASSOCIATED(A%DATA,DATA)) THEN
       OVERWRITE = .FALSE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
       OVERWRITE = .FALSE.
    ELSE
       OVERWRITE = .TRUE.
    END IF
    IF (B%CASE<0) THEN
      IF (OVERWRITE) THEN
        DATA%IPONT(A%P) = DATA%DEAD_POINTER
        DATA%DEAD_POINTER = A%P
      END IF
      A%P = B%P
      A%CASE = DATA%CASE
      A%DATA => DATA
      RETURN
    END IF
    IF (.NOT.OVERWRITE) THEN
      A%DATA => DATA
      IF (DATA%DEAD_POINTER==-1) THEN
        IF (DATA%IPTOS>SIZE(DATA%IPONT)) CALL MORE_MEMORY(DATA)
        A%P = DATA%IPTOS
        DATA%IPTOS = DATA%IPTOS + 1
       ELSE
        A%P = DATA%DEAD_POINTER
        DATA%DEAD_POINTER = DATA%IPONT(DATA%DEAD_POINTER)
      END IF
    END IF
    A%CASE = DATA%CASE
    NI = DATA%NVARS(B%P)
    NR = DATA%RLENG(B%P)
    IF (NR+DATA%IRTOS>SIZE(DATA%RHEAP)) THEN
      CALL GC(0,NR,DATA)
      IF (DATA%CASE==0) RETURN
    END IF
    DATA%RLENG(A%P) = NR
    DATA%NVARS(A%P) = NI
    DATA%IPONT(A%P) = 1
    DATA%RPTR(A%P) = DATA%IRTOS
    J =  DATA%RPTR(B%P)
    DO I = 1, NR
       DATA%RHEAP(DATA%IRTOS+I-1) = DATA%RHEAP(J)
       J = J + 1
    END DO
    DATA%IRTOS = DATA%IRTOS + NR
    IF (NI/=DATA%SIZE_X) THEN
      IF (NI+DATA%IHTOS>SIZE(DATA%IHEAP)) THEN
        CALL GC(NI,0,DATA)
        IF (DATA%CASE==0) RETURN
      END IF
      DATA%IPONT(A%P) = DATA%IHTOS
      J =  DATA%IPONT(B%P)
      DO I = 1, NI
         DATA%IHEAP(DATA%IHTOS+I-1) = DATA%IHEAP(J)
         J = J + 1
      END DO
      DATA%IHTOS = DATA%IHTOS + NI
    END IF
  END SUBROUTINE ASSIGN_DD
  SUBROUTINE ASSIGN_DD1(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:)
    CALL ERROR_HANDLER(B(1)%DATA,ASSIGNMENT_WARN)
    CALL AD02_UNDEFINE(A,B(1)%DATA)
  END SUBROUTINE ASSIGN_DD1
  SUBROUTINE ASSIGN_DD10(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
    CALL AD02_UNDEFINE(A,B%DATA)
  END SUBROUTINE ASSIGN_DD10
  SUBROUTINE ASSIGN_DD2(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:)
    CALL AD02_UNDEFINE(A,B(1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD2
  SUBROUTINE ASSIGN_DD20(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD20
  SUBROUTINE ASSIGN_DD3(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD3
  SUBROUTINE ASSIGN_DD30(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD30
  SUBROUTINE ASSIGN_DD4(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD4
  SUBROUTINE ASSIGN_DD40(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD40
  SUBROUTINE ASSIGN_DD5(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD5
  SUBROUTINE ASSIGN_DD50(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD50
  SUBROUTINE ASSIGN_DD6(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD6
  SUBROUTINE ASSIGN_DD60(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD60
  SUBROUTINE ASSIGN_DD7(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD7
  SUBROUTINE ASSIGN_DD70(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    A%P = -1
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD70
  SUBROUTINE ASSIGN_DI(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF(.NOT.ASSOCIATED(DATA))THEN
      CALL AD02_UNDEFINE(A)
    ELSE
      A = DERIVS(B,DATA)
    END IF
  END SUBROUTINE ASSIGN_DI
  SUBROUTINE ASSIGN_DR(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF(.NOT.ASSOCIATED(DATA))THEN
      CALL AD02_UNDEFINE(A)
    ELSE
      A = DERIVS(B,DATA)
    END IF
  END SUBROUTINE ASSIGN_DR
  SUBROUTINE ASSIGN_DS(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    REAL, INTENT (IN) :: B
    CALL ASSIGN_DR(A,REAL(B,WP))
  END SUBROUTINE ASSIGN_DS
  SUBROUTINE ASSIGN_ID(A,B)
    INTEGER, INTENT (OUT) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'Assign')
      A = 0
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'Assign')
      A = 0
    ELSE
      A = DATA%RHEAP(DATA%RPTR(B%P))
      CALL USED(B)
    END IF
  END SUBROUTINE ASSIGN_ID
  FUNCTION ATAN_D(X)
    TYPE (AD02_REAL) :: ATAN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG, VD1
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ATAN_D,X,'ATAN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ATAN_D,X,'ATAN')
    ELSE
      VG = DATA%RHEAP(DATA%RPTR(X%P))
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      DERF(0) = ATAN(VG)
      VD1 = 1.0_WP/(1.0_WP+VG*VG)
      DERF(1) = VD1
      DERF(2) = -2.0_WP*VG*VD1*VD1
      DO I = 3, DATA%LEVEL
        DERF(I) = -I*VD1*((I-1)*DERF(I-2)+2.0_WP*VG*DERF(I-1))
      END DO
      CALL UNARY(X,ATAN_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION ATAN_D
  FUNCTION ATAN2_DD(Y,X)
    TYPE (AD02_REAL) :: ATAN2_DD
    TYPE (AD02_REAL), INTENT (IN) :: Y, X
    REAL (WP) VY, VX
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1 .OR. Y%P==-1) THEN
      CALL BINARY_WARNING(ATAN2_DD,X,Y,'ATAN2')
    ELSE IF (.NOT.ASSOCIATED(DATA,Y%DATA)) THEN
      CALL BINARY_WARNING(ATAN2_DD,X,Y,'ATAN2')
    ELSE IF (DATA%CASE/=ABS(X%CASE) .OR.DATA%CASE/=ABS(Y%CASE) ) THEN
      CALL BINARY_WARNING(ATAN2_DD,X,Y,'ATAN2')
    ELSE
      ATAN2_DD%CASE = -DATA%CASE
      VY = DATA%RHEAP(DATA%RPTR(Y%P))
      VX = DATA%RHEAP(DATA%RPTR(X%P))
      IF (ABS(VX)>ABS(VY)) THEN
        CALL COPY(ATAN2_DD,ATAN(Y/X))
      ELSE
        CALL COPY(ATAN2_DD,-ATAN(X/Y))
      END IF
      DATA%RHEAP(DATA%RPTR(ATAN2_DD%P)) = ATAN2(VY,VX)
    END IF
  END FUNCTION ATAN2_DD
  FUNCTION ATAN2_DR(Y,X)
    TYPE (AD02_REAL) :: ATAN2_DR
    TYPE (AD02_REAL), INTENT (IN) :: Y
    REAL (WP), INTENT (IN) :: X
    REAL (WP) VY
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => Y%DATA
    IF (Y%P==-1) THEN
      CALL UNARY_WARNING(ATAN2_DR,Y,'ATAN2')
    ELSE IF (DATA%CASE/=ABS(Y%CASE)) THEN
      CALL UNARY_WARNING(ATAN2_DR,Y,'ATAN2')
    ELSE
      VY = DATA%RHEAP(DATA%RPTR(Y%P))
      IF (ABS(X)>ABS(VY)) THEN
        CALL COPY(ATAN2_DR,ATAN(Y/X))
      ELSE
        CALL COPY(ATAN2_DR,-ATAN(X/Y))
      END IF
      DATA%RHEAP(DATA%RPTR(ATAN2_DR%P)) = ATAN2(VY,X)
    END IF
  END FUNCTION ATAN2_DR
  FUNCTION ATAN2_DS(A,B)
    TYPE (AD02_REAL) :: ATAN2_DS
    REAL, INTENT (IN) :: B
    TYPE (AD02_REAL), INTENT (IN) :: A
    CALL COPY(ATAN2_DS,ATAN2_DR(A,REAL(B,WP)))
  END FUNCTION ATAN2_DS
  FUNCTION ATAN2_RD(Y,X)
    TYPE (AD02_REAL) :: ATAN2_RD
    REAL (WP), INTENT (IN) :: Y
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VX
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ATAN2_RD,X,'ATAN2')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ATAN2_RD,X,'ATAN2')
    ELSE
      VX = DATA%RHEAP(DATA%RPTR(X%P))
      IF (ABS(VX)>ABS(Y)) THEN
        CALL COPY(ATAN2_RD,ATAN(Y/X))
      ELSE
        CALL COPY(ATAN2_RD,-ATAN(X/Y))
      END IF
      DATA%RHEAP(DATA%RPTR(ATAN2_RD%P)) = ATAN2(Y,VX)
    END IF
  END FUNCTION ATAN2_RD
  FUNCTION ATAN2_SD(A,B)
    TYPE (AD02_REAL) :: ATAN2_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ATAN2_SD,ATAN2_RD(REAL(A,WP),B))
  END FUNCTION ATAN2_SD
  FUNCTION COS_D(X)
    TYPE (AD02_REAL) :: COS_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG, VS, VC
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(COS_D,X,'COS')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(COS_D,X,'COS')
    ELSE
      VG = DATA%RHEAP(DATA%RPTR(X%P))
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VS = SIN(VG)
      VC = COS(VG)
      DO I = 0, DATA%LEVEL, 4
        DERF(I) = VC
        DERF(I+1) = -VS
        DERF(I+2) = -VC
        DERF(I+3) = VS
      END DO
      CALL UNARY(X,COS_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION COS_D
  FUNCTION COSH_D(X)
    TYPE (AD02_REAL) :: COSH_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG, VS, VC
    TYPE(AD02_DATA), POINTER :: DATA
    REAL (WP), ALLOCATABLE :: DERF(:)
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(COSH_D,X,'COSH')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(COSH_D,X,'COSH')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
      VS = SINH(VG)
      VC = COSH(VG)
      DO I = 0, DATA%LEVEL, 2
        DERF(I) = VC
        DERF(I+1) = VS
      END DO
      CALL UNARY(X,COSH_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION COSH_D
  FUNCTION DIV_DD(A,B)
    TYPE (AD02_REAL) :: DIV_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    INTEGER I, IR, I1, I2, I3, LEVEL,N(3), P(3), PR, L2, LAMBDA, R, J, INDEX
    INTEGER PB2, PBASE2, PBASE3, INDEX_A, INDEX_B, INDEX_C
    REAL (WP) VG
    INTEGER, ALLOCATABLE :: LVARS(:)
    INTEGER, ALLOCATABLE :: IREF1(:)
    INTEGER, ALLOCATABLE :: IREF2(:)
    INTEGER, ALLOCATABLE :: INV_IREF2(:)
    INTEGER, ALLOCATABLE :: MI(:,:)
    LOGICAL, ALLOCATABLE :: A_PRES(:), B_PRES(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    DIV_DD%DATA => DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(DIV_DD,A,B,'/')
      RETURN
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(DIV_DD,A,B,'/')
      RETURN
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE) ) THEN
      CALL BINARY_WARNING(DIV_DD,A,B,'/')
      RETURN
    END IF
    DIV_DD%CASE = -DATA%CASE
    DATA%IHEAP => DATA%IHEAP
    LEVEL = DATA%LEVEL
    N(1) = DATA%NVARS(A%P)
    N(2) = DATA%NVARS(B%P)
    IF ((N(1)==DATA%SIZE_X) .AND. (N(2)==DATA%SIZE_X)) THEN
      CALL GETMEM(0,DATA%REAL_STRUCT_SIZE,DIV_DD)
      SELECT CASE (LEVEL)
      CASE (0)
        DATA%RHEAP(DATA%RPTR(DIV_DD%P)) = &
           DATA%RHEAP(DATA%RPTR(A%P))/DATA%RHEAP(DATA%RPTR(B%P))
      CASE (1)
        DATA%RHEAP(DATA%RPTR(DIV_DD%P)) = &
           DATA%RHEAP(DATA%RPTR(A%P))/DATA%RHEAP(DATA%RPTR(B%P))
        DATA%RHEAP(DATA%RPTR(DIV_DD%P)+1:DATA%RPTR(DIV_DD%P)+DATA%SIZE_X) = &
           (DATA%RHEAP(DATA%RPTR(B%P))*&
           DATA%RHEAP(DATA%RPTR(A%P)+1:DATA%RPTR(A%P)+DATA%SIZE_X)-&
           DATA%RHEAP(DATA%RPTR( &
           A%P))*DATA%RHEAP(DATA%RPTR(B%P)+1:DATA%RPTR(B%P)+DATA%SIZE_X))/ &
           (DATA%RHEAP(DATA%RPTR(B%P))*DATA%RHEAP(DATA%RPTR(B%P)))
      CASE (2)
        DATA%RHEAP(DATA%RPTR(DIV_DD%P)) = &
           DATA%RHEAP(DATA%RPTR(A%P))/DATA%RHEAP(DATA%RPTR(B%P))
        DATA%RHEAP(DATA%RPTR(DIV_DD%P)+1:DATA%RPTR(DIV_DD%P)+DATA%SIZE_X) = &
          (DATA%RHEAP(DATA%RPTR( &
          B%P))*DATA%RHEAP(DATA%RPTR(A%P)+1:DATA%RPTR(A%P)+DATA%SIZE_X)-&
          DATA%RHEAP(DATA%RPTR( &
          A%P))*DATA%RHEAP(DATA%RPTR(B%P)+1:DATA%RPTR(B%P)+DATA%SIZE_X))/ &
          (DATA%RHEAP(DATA%RPTR(B%P))*DATA%RHEAP(DATA%RPTR(B%P)))
        INDEX = DATA%SIZE_X
        DO I = 1, DATA%SIZE_X
          DO J = 1, I - 1
            INDEX = INDEX + 1
            DATA%RHEAP(DATA%RPTR(DIV_DD%P)+INDEX) = &
            (DATA%RHEAP(DATA%RPTR(A%P)+INDEX)-DATA%RHEAP(DATA%RPTR( &
             DIV_DD%P))*DATA%RHEAP(DATA%RPTR(B%P)+INDEX)-DATA%RHEAP(DATA%RPTR( &
             DIV_DD%P)+J)*DATA%RHEAP(DATA%RPTR(B%P)+I)-DATA%RHEAP(DATA%RPTR( &
             DIV_DD%P)+I)*DATA%RHEAP(DATA%RPTR(B%P)+J))/&
             DATA%RHEAP(DATA%RPTR(B%P))
          END DO
          INDEX = INDEX + 1
          DATA%RHEAP(DATA%RPTR(DIV_DD%P)+INDEX) = &
            (DATA%RHEAP(DATA%RPTR(A%P)+INDEX)-DATA%RHEAP(DATA%RPTR( &
            DIV_DD%P))*DATA%RHEAP(DATA%RPTR(B%P)+INDEX)-DATA%RHEAP(DATA%RPTR( &
            DIV_DD%P)+I)*DATA%RHEAP(DATA%RPTR(B%P)+I))/&
            DATA%RHEAP(DATA%RPTR(B%P))
        END DO
      CASE DEFAULT
        ALLOCATE(MI(0:DATA%LEVEL+1,4))
        P(1) = DATA%RPTR(A%P)
        P(2) = DATA%RPTR(B%P)
        P(3) = DATA%RPTR(DIV_DD%P)
        L2 = DATA%REAL_STRUCT_SIZE
        DATA%RHEAP(P(3):P(3)+L2-1) = 0.0_WP
        VG = DATA%RHEAP(P(2))
        MI(0,1) = 0
        DO I = 0, DATA%REAL_STRUCT_SIZE - 1
          DATA%RHEAP(P(3)+I) = DATA%RHEAP(P(1)+I)/VG
        END DO
        PB2 = P(2) + 1
        DO LAMBDA = 1, LEVEL
          PBASE2 = PB2
          PBASE3 = P(3)
          MI(0,3) = 0
          DO R = 0, LAMBDA - 1
            DO I3 = 0, DATA%IBINCO(R+DATA%SIZE_X-1,R) - 1
              MI(0,2) = LAMBDA - R
              DO I = 1, LAMBDA - R
                MI(I,2) = 1
              END DO
              DO I2 = 0, DATA%IBINCO(LAMBDA-R+DATA%SIZE_X-1,LAMBDA-R) - 1
                CALL MIMERU(MI(1:MI(0,3),3),MI(1:MI(0,2),2),MI(0:LEVEL+1,4))
                PR = IRPOS(MI(0:LEVEL+1,4),DATA%SIZE_X,DATA) + P(3)
                DATA%RHEAP(PR) = DATA%RHEAP(PR) - &
                   DATA%RHEAP(PBASE2+I2)*DATA%RHEAP(PBASE3+I3)/VG
                CALL MIINC(LEVEL,MI(0:LEVEL+1,2),DATA%SIZE_X)
              END DO
              CALL MIINC(LEVEL,MI(0:LEVEL+1,3),DATA%SIZE_X)
            END DO
            PBASE3 = PBASE3 + DATA%IBINCO(R+DATA%SIZE_X-1,R)
            PBASE2 = PBASE2 - DATA%IBINCO(LAMBDA-R-2+DATA%SIZE_X,LAMBDA-R-1)
          END DO
          PB2 = PB2 + DATA%IBINCO(LAMBDA+DATA%SIZE_X-1,LAMBDA)
        END DO
        DEALLOCATE(MI)
      END SELECT
    ELSE
      ALLOCATE(LVARS(0:DATA%SIZE_X),IREF1(DATA%SIZE_X),IREF2(DATA%SIZE_X))
      I1 = DATA%IPONT(A%P)
      I2 = DATA%IPONT(B%P)
      CALL MERGE(I1,I2,N(1),N(2),DATA,LVARS,IREF1,IREF2)
      N(3) = LVARS(0)
      CALL GETMEM(N(3),DATA%IBINCO(LEVEL+N(3),LEVEL),DIV_DD)
      IR = DATA%IPONT(DIV_DD%P)
      DO I = 0, N(3) - 1
        DATA%IHEAP(IR+I) = LVARS(I+1)
      END DO
      P(1) = DATA%RPTR(A%P)
      P(2) = DATA%RPTR(B%P)
      P(3) = DATA%RPTR(DIV_DD%P)
      L2 = DATA%RLENG(B%P)
      DATA%RHEAP(P(3):P(3)+DATA%RLENG(DIV_DD%P)-1) = 0.0_WP
      VG = DATA%RHEAP(P(2))
      SELECT CASE (LEVEL)
      CASE (0)
        DATA%RHEAP(P(3)) = DATA%RHEAP(P(1))/VG
      CASE (1)
        DATA%RHEAP(P(3)) = DATA%RHEAP(P(1))/VG
        DO I = 1, N(1)
          DATA%RHEAP(P(3)+IREF1(I)) = VG*DATA%RHEAP(P(1)+I)
        END DO
        DO I = 1, N(2)
          DATA%RHEAP(P(3)+IREF2(I)) = DATA%RHEAP(P(3)+IREF2(I)) - &
            DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+I)
        END DO
        DATA%RHEAP(P(3)+1:P(3)+N(3)) = DATA%RHEAP(P(3)+1:P(3)+N(3))/(VG*VG)
      CASE (2)
        ALLOCATE (INV_IREF2(DATA%SIZE_X),A_PRES(DATA%SIZE_X),&
                 B_PRES(DATA%SIZE_X))
        A_PRES = .FALSE.
        DO I = 1, N(1)
          A_PRES(IREF1(I)) = .TRUE.
        END DO
        B_PRES = .FALSE.
        DO I = 1, N(2)
          B_PRES(IREF2(I)) = .TRUE.
          INV_IREF2(IREF2(I)) = I
        END DO
        DATA%RHEAP(P(3)) = DATA%RHEAP(P(1))/VG
        DO I = 1, N(1)
          DATA%RHEAP(P(3)+IREF1(I)) = VG*DATA%RHEAP(P(1)+I)
        END DO
        DO I = 1, N(2)
          DATA%RHEAP(P(3)+IREF2(I)) = DATA%RHEAP(P(3)+IREF2(I)) - &
            DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+I)
        END DO
        DATA%RHEAP(P(3)+1:P(3)+N(3)) = DATA%RHEAP(P(3)+1:P(3)+N(3))/(VG*VG)
        INDEX_A = 1 + N(1)
        INDEX_B = 1 + N(2)
        INDEX_C = 1 + N(3)
        DO I = 1, N(3)
          DO J = 1, I - 1
            DATA%RHEAP(P(3)+INDEX_C) = 0.0_WP
            IF ((A_PRES(I)) .AND. (A_PRES(J))) THEN
              DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                 DATA%RHEAP(P(1)+INDEX_A)
              IF (B_PRES(I)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) - &
                  DATA%RHEAP(P(3)+J)*DATA%RHEAP(P(2)+INV_IREF2(I))
                IF (B_PRES(J)) THEN
                  DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) - &
                    DATA%RHEAP(P(3))*DATA%RHEAP(P(2)+INDEX_B) - &
                    DATA%RHEAP(P(3)+I)*DATA%RHEAP(P(2)+INV_IREF2(J))
                  INDEX_B = INDEX_B + 1
                END IF
              ELSE IF (B_PRES(J)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) - &
                  DATA%RHEAP(P(3)+I)*DATA%RHEAP(P(2)+INV_IREF2(J))
              END IF
              INDEX_A = INDEX_A + 1
            ELSE
              IF (B_PRES(J)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) - &
                  DATA%RHEAP(P(3)+I)*DATA%RHEAP(P(2)+INV_IREF2(J))
                IF (B_PRES(I)) THEN
                  DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) - &
                    DATA%RHEAP(P(3))*DATA%RHEAP(P(2)+INDEX_B) - &
                    DATA%RHEAP(P(3)+J)*DATA%RHEAP(P(2)+INV_IREF2(I))
                  INDEX_B = INDEX_B + 1
                END IF
              ELSE
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) - &
                  DATA%RHEAP(P(3)+J)*DATA%RHEAP(P(2)+INV_IREF2(I))
              END IF
            END IF
            DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C)/VG
            INDEX_C = INDEX_C + 1
          END DO
          IF (A_PRES(I)) THEN
            IF (B_PRES(I)) THEN
              DATA%RHEAP(P(3)+INDEX_C) = (DATA%RHEAP(P(1)+INDEX_A)-&
                DATA%RHEAP(P(2)+INDEX_B)*DATA%RHEAP(P(3))-DATA%RHEAP(P(3)+I)&
                *DATA%RHEAP(P(2)+INV_IREF2(I)))/VG
              INDEX_A = INDEX_A + 1
              INDEX_B = INDEX_B + 1
            ELSE
              DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(1)+INDEX_A)/VG
              INDEX_A = INDEX_A + 1
            END IF
          ELSE
            DATA%RHEAP(P(3)+INDEX_C) = &
              -(DATA%RHEAP(P(2)+INDEX_B)*DATA%RHEAP(P(3))+DATA%RHEAP(P(3) &
              +I)*DATA%RHEAP(P(2)+INV_IREF2(I)))/VG
            INDEX_B = INDEX_B + 1
          END IF
          INDEX_C = INDEX_C + 1
        END DO
        DEALLOCATE(INV_IREF2,A_PRES, B_PRES)
      CASE DEFAULT
        ALLOCATE(MI(0:DATA%LEVEL+1,4))
        MI(0,1) = 0
        DO I = 0, DATA%RLENG(A%P) - 1
          PR = IRPOS2(MI(0:LEVEL+1,1),N(3),IREF1,DATA) + P(3)
          DATA%RHEAP(PR) = DATA%RHEAP(P(1)+I)/VG
          CALL MIINC(LEVEL,MI(0:LEVEL+1,1),N(1))
        END DO
        PB2 = P(2) + 1
        DO LAMBDA = 1, LEVEL
          PBASE2 = PB2
          PBASE3 = P(3) + 0
          MI(0,3) = 0
          DO R = 0, LAMBDA - 1
            DO I3 = 0, DATA%IBINCO(R+N(3)-1,R) - 1
              MI(0,2) = LAMBDA - R
              DO I = 1, LAMBDA - R
                MI(I,2) = 1
              END DO
              DO I2 = 0, DATA%IBINCO(LAMBDA-R+N(2)-1,LAMBDA-R) - 1
                CALL MIMERU &
                    (MI(1:MI(0,3),3),IREF2(MI(1:MI(0,2),2)),MI(0:LEVEL+1,4))
                PR = IRPOS(MI(0:LEVEL+1,4),N(3),DATA) + P(3)
                DATA%RHEAP(PR) = DATA%RHEAP(PR) - &
                  DATA%RHEAP(PBASE2+I2)*DATA%RHEAP(PBASE3+I3)/VG
                CALL MIINC(LEVEL,MI(0:LEVEL+1,2),N(2))
              END DO
              CALL MIINC(LEVEL,MI(0:LEVEL+1,3),N(3))
            END DO
            PBASE3 = PBASE3 + DATA%IBINCO(R+N(3)-1,R)
            PBASE2 = PBASE2 - DATA%IBINCO(LAMBDA-R-2+N(2),LAMBDA-R-1)
          END DO
          PB2 = PB2 + DATA%IBINCO(LAMBDA+N(2)-1,LAMBDA)
        END DO
        DEALLOCATE(MI)
      END SELECT
      DEALLOCATE(LVARS,IREF1,IREF2)
      IF ((DATA%NVARS(DIV_DD%P)>=DATA%SWITCH_POINT) .AND. (DATA%NVARS( &
        DIV_DD%P)/=DATA%SIZE_X)) &
        CALL SPARSE_TO_FULL(DIV_DD)
    END IF
    CALL USED(A)
    CALL USED(B)
  END FUNCTION DIV_DD
  FUNCTION DIV_DI(A,B)
    TYPE (AD02_REAL) :: DIV_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
      CALL COPY(DIV_DI,DIV_DR(A,REAL(B,WP)))
  END FUNCTION DIV_DI
  FUNCTION DIV_DR(A,B)
    TYPE (AD02_REAL) :: DIV_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    INTEGER I, NV, RL, IP1, IP2
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    DIV_DR%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(DIV_DR,A,'/')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(DIV_DR,A,'/')
    ELSE
      DIV_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
        DIV_DR%P = A%P
        DIV_DR%CASE = -DATA%CASE
        DO I = 1, DATA%RLENG(A%P)
          DATA%RHEAP(DATA%RPTR(A%P)+I-1) = DATA%RHEAP(DATA%RPTR(A%P)+I-1)/B
        END DO
      ELSE
        NV = DATA%NVARS(A%P)
        RL = DATA%RLENG(A%P)
        IF (NV/=DATA%SIZE_X) THEN
          CALL GETMEM(NV,RL,DIV_DR)
          IP1 = DATA%IPONT(A%P)
          IP2 = DATA%IPONT(DIV_DR%P)
          DATA%IHEAP(IP2:IP2+NV-1) = DATA%IHEAP(IP1:IP1+NV-1)
        ELSE
          CALL GETMEM(0,RL,DIV_DR)
        END IF
        DATA%RHEAP(DATA%RPTR(DIV_DR%P):DATA%RPTR(DIV_DR%P)+RL-1) = &
           DATA%RHEAP(DATA%RPTR(A%P):DATA%RPTR(A%P)+RL-1)/B
        CALL USED(A)
      END IF
    END IF
  END FUNCTION DIV_DR
  FUNCTION DIV_DS(A,B)
    TYPE (AD02_REAL) :: DIV_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(DIV_DS,DIV_DR(A,REAL(B,WP)))
  END FUNCTION DIV_DS
  FUNCTION DIV_ID(A,B)
    TYPE (AD02_REAL) :: DIV_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(DIV_ID,DIV_RD(REAL(A,WP),B))
  END FUNCTION DIV_ID
  FUNCTION DIV_RD(A,B)
    TYPE (AD02_REAL) :: DIV_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL (WP) RV
    INTEGER I
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    DIV_RD%DATA => DATA
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(DIV_RD,B,'/')
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(DIV_RD,B,'/')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      RV = 1.0_WP/DATA%RHEAP(DATA%RPTR(B%P))
      DERF(0) = A*RV
      DO I = 1, DATA%LEVEL
        DERF(I) = -(DERF(I-1)*RV*I)
      END DO
      CALL UNARY(B,DIV_RD,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION DIV_RD
  FUNCTION DIV_SD(A,B)
    TYPE (AD02_REAL) :: DIV_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(DIV_SD,DIV_RD(REAL(A,WP),B))
  END FUNCTION DIV_SD
  FUNCTION EQ_DD(A,B)
    LOGICAL :: EQ_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DD = .TRUE.
    ELSE
      EQ_DD = DATA%RHEAP(DATA%RPTR(A%P)) == DATA%RHEAP(DATA%RPTR(B%P))
      IF (EQ_DD) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION EQ_DD
  FUNCTION EQ_DI(A,B)
    LOGICAL :: EQ_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DI = .TRUE.
    ELSE
      EQ_DI = DATA%RHEAP(DATA%RPTR(A%P)) == B
      IF (EQ_DI) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(A)
    END IF
  END FUNCTION EQ_DI
  FUNCTION EQ_DR(A,B)
    LOGICAL :: EQ_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DR = .TRUE.
    ELSE
      EQ_DR = DATA%RHEAP(DATA%RPTR(A%P)) == B
      IF (EQ_DR) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(A)
    END IF
  END FUNCTION EQ_DR
  FUNCTION EQ_DS(A,B)
    LOGICAL :: EQ_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DS = .TRUE.
    ELSE
      EQ_DS = DATA%RHEAP(DATA%RPTR(A%P)) == B
      IF (EQ_DS) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(A)
    END IF
  END FUNCTION EQ_DS
  FUNCTION EQ_ID(A,B)
    LOGICAL :: EQ_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_ID = .TRUE.
    ELSE
      EQ_ID = A == DATA%RHEAP(DATA%RPTR(B%P))
      IF (EQ_ID) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(B)
    END IF
  END FUNCTION EQ_ID
  FUNCTION EQ_RD(A,B)
    LOGICAL :: EQ_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_RD = .TRUE.
    ELSE
      EQ_RD = A == DATA%RHEAP(DATA%RPTR(B%P))
      IF (EQ_RD) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(B)
    END IF
  END FUNCTION EQ_RD
  FUNCTION EQ_SD(A,B)
    LOGICAL :: EQ_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_SD = .TRUE.
    ELSE
      EQ_SD = A == DATA%RHEAP(DATA%RPTR(B%P))
      IF (EQ_SD) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(B)
    END IF
  END FUNCTION EQ_SD
  FUNCTION EXP_D(X)
    TYPE (AD02_REAL) :: EXP_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(EXP_D,X,'EXP')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(EXP_D,X,'EXP')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      DERF(0:DATA%LEVEL) = EXP(DATA%RHEAP(DATA%RPTR(X%P)))
      CALL UNARY(X,EXP_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION EXP_D
  FUNCTION GE_DD(A,B)
    LOGICAL :: GE_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
     ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DD = .TRUE.
    ELSE
          GE_DD = DATA%RHEAP(DATA%RPTR(A%P)) >= DATA%RHEAP(DATA%RPTR(B%P))
      IF (DATA%RHEAP(DATA%RPTR(A%P))==DATA%RHEAP(DATA%RPTR(B%P))) &
         CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION GE_DD
  FUNCTION GE_DI(A,B)
    LOGICAL :: GE_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_DI = .TRUE.
          GE_DI = DATA%RHEAP(DATA%RPTR(A%P)) >= B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION GE_DI
  FUNCTION GE_DR(A,B)
    LOGICAL :: GE_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_DR = .TRUE.
          GE_DR = DATA%RHEAP(DATA%RPTR(A%P)) >= B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION GE_DR
  FUNCTION GE_DS(A,B)
    LOGICAL :: GE_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_DS = .TRUE.
          GE_DS = DATA%RHEAP(DATA%RPTR(A%P)) >= B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION GE_DS
  FUNCTION GE_ID(A,B)
    LOGICAL :: GE_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_ID = .TRUE.
          GE_ID = A >= DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION GE_ID
  FUNCTION GE_RD(A,B)
    LOGICAL :: GE_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_RD = .TRUE.
          GE_RD = A >= DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION GE_RD
  FUNCTION GE_SD(A,B)
    LOGICAL :: GE_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_SD = .TRUE.
          GE_SD = A >= DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION GE_SD
  FUNCTION GT_DD(A,B)
    LOGICAL :: GT_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DD = .TRUE.
    ELSE IF ( DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DD = .TRUE.
    ELSE
          GT_DD = DATA%RHEAP(DATA%RPTR(A%P)) > DATA%RHEAP(DATA%RPTR(B%P))
      IF (DATA%RHEAP(DATA%RPTR(A%P))==DATA%RHEAP(DATA%RPTR(B%P))) &
         CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION GT_DD
  FUNCTION GT_DI(A,B)
    LOGICAL :: GT_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DI = .TRUE.
    ELSE
      GT_DI = DATA%RHEAP(DATA%RPTR(A%P)) > B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(A)
    END IF
  END FUNCTION GT_DI
  FUNCTION GT_DR(A,B)
    LOGICAL :: GT_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DR = .TRUE.
    ELSE
          GT_DR = DATA%RHEAP(DATA%RPTR(A%P)) > B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(A)
    END IF
  END FUNCTION GT_DR
  FUNCTION GT_DS(A,B)
    LOGICAL :: GT_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DS = .TRUE.
    ELSE
          GT_DS = DATA%RHEAP(DATA%RPTR(A%P)) > B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(A)
    END IF
  END FUNCTION GT_DS
  FUNCTION GT_ID(A,B)
    LOGICAL :: GT_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_ID = .TRUE.
    ELSE
          GT_ID = A > DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(B)
    END IF
  END FUNCTION GT_ID
  FUNCTION GT_RD(A,B)
    LOGICAL :: GT_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_RD = .TRUE.
    ELSE
          GT_RD = A > DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(B)
    END IF
  END FUNCTION GT_RD
  FUNCTION GT_SD(A,B)
    LOGICAL :: GT_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_SD = .TRUE.
    ELSE
          GT_SD = A > DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(B)
    END IF
  END FUNCTION GT_SD
  FUNCTION INT_D(A)
    TYPE (AD02_REAL) INT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    INT_D%DATA => DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'INT')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'INT')
    ELSE
      VA = DATA%RHEAP(DATA%RPTR(A%P))
      IF (VA==AINT(VA)) THEN
        CALL ERROR_HANDLER(DATA,INT_WARN)
      END IF
      INT_D%CASE = -DATA%CASE
      INT_D = INT(VA)
      INT_D%CASE = -DATA%CASE
    END IF
  END FUNCTION INT_D
  FUNCTION LOG_D(X)
    TYPE (AD02_REAL) :: LOG_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(LOG_D,X,'LOG')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(LOG_D,X,'LOG')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
      DERF(0) = LOG(VG)
      DERF(1) = 1.0_WP/VG
      DO I = 2, DATA%LEVEL
        DERF(I) = -DERF(I-1)*(I-1)/VG
      END DO
      CALL UNARY(X,LOG_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION LOG_D
  FUNCTION LOG10_D(X)
    TYPE (AD02_REAL) :: LOG10_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(LOG10_D,X,'LOG10')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(LOG10_D,X,'LOG10')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
      DERF(0) = LOG10(VG)
      DERF(1) = 1.0_WP/(VG*LOG(10.0_WP))
      DO I = 2, DATA%LEVEL
        DERF(I) = -DERF(I-1)*(I-1)/VG
      END DO
      CALL UNARY(X,LOG10_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION LOG10_D
  FUNCTION LE_DD(A,B)
    LOGICAL :: LE_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE).OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DD = .TRUE.
    ELSE
          LE_DD = DATA%RHEAP(DATA%RPTR(A%P)) <= DATA%RHEAP(DATA%RPTR(B%P))
      IF (DATA%RHEAP(DATA%RPTR(A%P))==DATA%RHEAP(DATA%RPTR(B%P))) &
          CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION LE_DD
  FUNCTION LE_DI(A,B)
    LOGICAL :: LE_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DI = .TRUE.
    ELSE
          LE_DI = DATA%RHEAP(DATA%RPTR(A%P)) <= B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION LE_DI
  FUNCTION LE_DR(A,B)
    LOGICAL :: LE_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DR = .TRUE.
    ELSE
          LE_DR = DATA%RHEAP(DATA%RPTR(A%P)) <= B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION LE_DR
  FUNCTION LE_DS(A,B)
    LOGICAL :: LE_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DS = .TRUE.
    ELSE
          LE_DS = DATA%RHEAP(DATA%RPTR(A%P)) <= B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION LE_DS
  FUNCTION LE_ID(A,B)
    LOGICAL :: LE_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_ID = .TRUE.
    ELSE
          LE_ID = A <= DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION LE_ID
  FUNCTION LE_RD(A,B)
    LOGICAL :: LE_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_RD = .TRUE.
    ELSE
          LE_RD = A <= DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION LE_RD
  FUNCTION LE_SD(A,B)
    LOGICAL :: LE_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_SD = .TRUE.
    ELSE
          LE_SD = A <= DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION LE_SD
  FUNCTION LT_DD(A,B)
    LOGICAL :: LT_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DD = .TRUE.
    ELSE
          LT_DD = DATA%RHEAP(DATA%RPTR(A%P)) < DATA%RHEAP(DATA%RPTR(B%P))
      IF (DATA%RHEAP(DATA%RPTR(A%P))==DATA%RHEAP(DATA%RPTR(B%P)))&
          CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION LT_DD
  FUNCTION LT_DI(A,B)
    LOGICAL :: LT_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DI = .TRUE.
    ELSE
          LT_DI = DATA%RHEAP(DATA%RPTR(A%P)) < B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(A)
    END IF
  END FUNCTION LT_DI
  FUNCTION LT_DR(A,B)
    LOGICAL :: LT_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
    ELSE
      LT_DR = .TRUE.
          LT_DR = DATA%RHEAP(DATA%RPTR(A%P)) < B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(A)
    END IF
  END FUNCTION LT_DR
  FUNCTION LT_DS(A,B)
    LOGICAL :: LT_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
    ELSE
      LT_DS = .TRUE.
          LT_DS = DATA%RHEAP(DATA%RPTR(A%P)) < B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(A)
    END IF
  END FUNCTION LT_DS
  FUNCTION LT_ID(A,B)
    LOGICAL :: LT_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_ID = .TRUE.
    ELSE
          LT_ID = A < DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(B)
    END IF
  END FUNCTION LT_ID
  FUNCTION LT_RD(A,B)
    LOGICAL :: LT_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_RD = .TRUE.
    ELSE
          LT_RD = A < DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(B)
    END IF
  END FUNCTION LT_RD
  FUNCTION LT_SD(A,B)
    LOGICAL :: LT_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_SD = .TRUE.
    ELSE
          LT_SD = A < DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(B)
    END IF
  END FUNCTION LT_SD
  FUNCTION MAX_DD(A1,A2)
    TYPE (AD02_REAL) :: MAX_DD
    TYPE (AD02_REAL), INTENT (IN) :: A1, A2
    REAL(WP) RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    IF (A1%P==-1 .OR. A2%P==-1) THEN
      CALL BINARY_WARNING(MAX_DD,A1,A2,'MAX')
    ELSE IF (.NOT.ASSOCIATED(DATA,A2%DATA)) THEN
      CALL BINARY_WARNING(MAX_DD,A1,A2,'MAX')
    ELSE IF (DATA%CASE/=ABS(A1%CASE) .OR. DATA%CASE/=ABS(A2%CASE)) THEN
      CALL BINARY_WARNING(MAX_DD,A1,A2,'MAX')
    ELSE
      IF (DATA%RHEAP(DATA%RPTR(A1%P))>DATA%RHEAP(DATA%RPTR(A2%P))) THEN
        IF (A1%CASE<0) THEN
          CALL COPY(MAX_DD,A1)
        ELSE
          CALL COPY(MAX_DD,REAL_D(A1))
        END IF
        CALL USED(A2)
      ELSE IF (DATA%RHEAP(DATA%RPTR(A1%P))<DATA%RHEAP(DATA%RPTR(A2%P))) THEN
        IF (A2%CASE<0) THEN
          CALL COPY(MAX_DD,A2)
        ELSE
          CALL COPY(MAX_DD,REAL_D(A2))
        END IF
        CALL USED(A1)
      ELSE
        CALL ERROR_HANDLER(DATA,MAX_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(MAX_DD,A1*RAND+A2*(1.0_WP-RAND))
      END IF
    END IF
  END FUNCTION MAX_DD
  FUNCTION MAX_DR(A1,A2)
    TYPE (AD02_REAL) :: MAX_DR
    TYPE (AD02_REAL), INTENT (IN) :: A1
    REAL (WP), INTENT (IN) :: A2
    REAL(WP) RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    IF (A1%P==-1) THEN
      CALL UNARY_WARNING(MAX_DR,A1,'MAX')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL UNARY_WARNING(MAX_DR,A1,'MAX')
    ELSE
      IF (DATA%RHEAP(DATA%RPTR(A1%P))>A2) THEN
        IF (A1%CASE<0) THEN
          CALL COPY(MAX_DR,A1)
        ELSE
          CALL COPY(MAX_DR,REAL_D(A1))
        END IF
      ELSE IF (DATA%RHEAP(DATA%RPTR(A1%P))<A2) THEN
        CALL COPY(MAX_DR,DERIVS(A2,DATA))
        CALL USED(A1)
      ELSE
        CALL ERROR_HANDLER(DATA,MAX_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(MAX_DR,A1*RAND+A2*(1.0_WP-RAND))
      END IF
    END IF
  END FUNCTION MAX_DR
  FUNCTION MAX_DS(A,B)
    TYPE (AD02_REAL) :: MAX_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MAX_DS,MAX_DR(A,REAL(B,WP)))
  END FUNCTION MAX_DS
  FUNCTION MAX_RD(A1,A2)
    TYPE (AD02_REAL) :: MAX_RD
    REAL (WP), INTENT (IN) :: A1
    TYPE (AD02_REAL), INTENT (IN) :: A2
    CALL COPY(MAX_RD,MAX_DR(A2,REAL(A1,WP)))
  END FUNCTION MAX_RD
  FUNCTION MAX_SD(A,B)
    TYPE (AD02_REAL) :: MAX_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(MAX_SD,MAX_RD(REAL(A,WP),B))
  END FUNCTION MAX_SD
  FUNCTION MIN_DD(A1,A2)
    TYPE (AD02_REAL) :: MIN_DD
    TYPE (AD02_REAL), INTENT (IN) :: A1, A2
    REAL(WP) RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    IF (A1%P==-1 .OR. A2%P==-1) THEN
      CALL BINARY_WARNING(MIN_DD,A1,A2,'MIN')
    ELSE IF (.NOT.ASSOCIATED(DATA,A2%DATA)) THEN
      CALL BINARY_WARNING(MIN_DD,A1,A2,'MIN')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL BINARY_WARNING(MIN_DD,A1,A2,'MIN')
    ELSE
      IF (DATA%RHEAP(DATA%RPTR(A1%P))<DATA%RHEAP(DATA%RPTR(A2%P))) THEN
        IF (A1%CASE<0) THEN
          CALL COPY(MIN_DD,A1)
        ELSE
          CALL COPY(MIN_DD,REAL_D(A1))
        END IF
        CALL USED(A2)
      ELSE IF (DATA%RHEAP(DATA%RPTR(A1%P))>DATA%RHEAP(DATA%RPTR(A2%P))) THEN
        IF (A2%CASE<0) THEN
          CALL COPY(MIN_DD,A2)
        ELSE
          CALL COPY(MIN_DD,REAL_D(A2))
        END IF
        CALL USED(A1)
      ELSE
        CALL ERROR_HANDLER(DATA,MIN_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(MIN_DD,A1*RAND+A2*(1.0_WP-RAND))
      END IF
    END IF
  END FUNCTION MIN_DD
  FUNCTION MIN_DR(A1,A2)
    TYPE (AD02_REAL) :: MIN_DR
    TYPE (AD02_REAL), INTENT (IN) :: A1
    REAL (WP), INTENT (IN) :: A2
    REAL(WP) RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    IF (A1%P==-1) THEN
      CALL UNARY_WARNING(MIN_DR,A1,'MIN')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL UNARY_WARNING(MIN_DR,A1,'MIN')
    ELSE
      IF (DATA%RHEAP(DATA%RPTR(A1%P))<A2) THEN
        IF (A1%CASE<0) THEN
          CALL COPY(MIN_DR,A1)
        ELSE
          CALL COPY(MIN_DR,REAL_D(A1))
        END IF
      ELSE IF (DATA%RHEAP(DATA%RPTR(A1%P))>A2) THEN
        CALL COPY(MIN_DR,DERIVS(A2,DATA))
        CALL USED(A1)
      ELSE
        CALL ERROR_HANDLER(DATA,MIN_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(MIN_DR,A1*RAND+A2*(1.0_WP-RAND))
      END IF
    END IF
  END FUNCTION MIN_DR
  FUNCTION MIN_DS(A,B)
    TYPE (AD02_REAL) :: MIN_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MIN_DS,MIN_DR(A,REAL(B,WP)))
  END FUNCTION MIN_DS
  FUNCTION MIN_RD(A1,A2)
    TYPE (AD02_REAL) :: MIN_RD
    REAL (WP), INTENT (IN) :: A1
    TYPE (AD02_REAL), INTENT (IN) :: A2
    CALL COPY(MIN_RD,MIN_DR(A2,REAL(A1,WP)))
  END FUNCTION MIN_RD
  FUNCTION MIN_SD(A,B)
    TYPE (AD02_REAL) :: MIN_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(MIN_SD,MIN_RD(REAL(A,WP),B))
  END FUNCTION MIN_SD
  FUNCTION MINUS_D(A1)
    TYPE (AD02_REAL) :: MINUS_D
    TYPE (AD02_REAL), INTENT (IN) :: A1
    INTEGER I, I1, I2, NR, NV, P1, P2
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    MINUS_D%DATA => DATA
    IF (A1%P==-1) THEN
      CALL UNARY_WARNING(MINUS_D,A1,'Unary -')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL UNARY_WARNING(MINUS_D,A1,'-')
    ELSE
      MINUS_D%CASE = -DATA%CASE
      NR = DATA%RLENG(A1%P)
      IF (A1%CASE<0) THEN
        MINUS_D%P = A1%P
        MINUS_D%CASE = -DATA%CASE
        P1 = DATA%RPTR(A1%P)
        DATA%RHEAP(P1:P1+NR-1) = -DATA%RHEAP(P1:P1+NR-1)
      ELSE
        NV = DATA%NVARS(A1%P)
        IF (NV/=DATA%SIZE_X) THEN
          CALL GETMEM(NV,NR,MINUS_D)
          I1 = DATA%IPONT(A1%P)
          I2 = DATA%IPONT(MINUS_D%P)
          DATA%IHEAP(I2:I2+NV-1) = DATA%IHEAP(I1:I1+NV-1)
        ELSE
          CALL GETMEM(0,NR,MINUS_D)
        END IF
        P1 = DATA%RPTR(A1%P)
        P2 = DATA%RPTR(MINUS_D%P)
        DO I = 1,NR
           DATA%RHEAP(P2+I-1) = -DATA%RHEAP(P1+I-1)
        END DO
        CALL USED(A1)
      END IF
    END IF
  END FUNCTION MINUS_D
  FUNCTION MINUS_DD(A,B)
    TYPE (AD02_REAL) :: MINUS_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MINUS_DD%DATA => DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(MINUS_DD,A,B,'-')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(MINUS_DD,A,B,'-')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(MINUS_DD,A,B,'-')
    ELSE
      CALL COPY(MINUS_DD,A+(-B))
    END IF
  END FUNCTION MINUS_DD
  FUNCTION MINUS_DI(A,B)
    TYPE (AD02_REAL) :: MINUS_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MINUS_DI%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(MINUS_DI,A,'-')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(MINUS_DI,A,'-')
    ELSE
      MINUS_DI%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
        DATA%RHEAP(DATA%RPTR(A%P)) = DATA%RHEAP(DATA%RPTR(A%P)) - B
        MINUS_DI%P = A%P
      ELSE
        CALL ADD_CONST(A,-REAL(B,WP),MINUS_DI)
      END IF
    END IF
  END FUNCTION MINUS_DI
  FUNCTION MINUS_DR(A,B)
    TYPE (AD02_REAL) :: MINUS_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MINUS_DR%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(MINUS_DR,A,'-')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(MINUS_DR,A,'-')
    ELSE
      MINUS_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
        DATA%RHEAP(DATA%RPTR(A%P)) = DATA%RHEAP(DATA%RPTR(A%P)) - B
        MINUS_DR%P = A%P
      ELSE
        CALL ADD_CONST(A,-B,MINUS_DR)
      END IF
    END IF
  END FUNCTION MINUS_DR
  FUNCTION MINUS_DS(A,B)
    TYPE (AD02_REAL) :: MINUS_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MINUS_DS,MINUS_DR(A,REAL(B,WP)))
  END FUNCTION MINUS_DS
  FUNCTION MINUS_ID(A,B)
    TYPE (AD02_REAL) :: MINUS_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
      CALL COPY(MINUS_ID,MINUS_RD(REAL(A,WP),B))
  END  FUNCTION MINUS_ID
  FUNCTION MINUS_RD(A,B)
    TYPE (AD02_REAL) :: MINUS_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(MINUS_RD,B,'-')
    ELSE IF (B%DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(MINUS_RD,B,'-')
    ELSE
      CALL COPY(MINUS_RD,A+(-B))
    END IF
  END FUNCTION MINUS_RD
  FUNCTION MINUS_SD(A,B)
    TYPE (AD02_REAL) :: MINUS_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MINUS_SD,MINUS_RD(REAL(A,WP),B))
  END FUNCTION MINUS_SD
  FUNCTION MULT_DD(A,B)
    TYPE (AD02_REAL) :: MULT_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(MULT_DD,A,B,'*')
    ELSE IF (.NOT.ASSOCIATED(A%DATA,B%DATA)) THEN
      CALL BINARY_WARNING(MULT_DD,A,B,'*')
    ELSE IF (A%DATA%CASE/=ABS(A%CASE)  .OR. A%DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(MULT_DD,A,B,'*')
    ELSE
      MULT_DD%CASE = -A%DATA%CASE
      CALL MULT(A,B,MULT_DD)
    END IF
  END FUNCTION MULT_DD
  FUNCTION MULT_DI(A,B)
    TYPE (AD02_REAL) :: MULT_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    CALL COPY(MULT_DI,MULT_DR(A,REAL(B,WP)))
  END FUNCTION MULT_DI
  FUNCTION MULT_DR(A,B)
    TYPE (AD02_REAL) MULT_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    INTEGER NV, I, J, IP1, IP2, RL
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MULT_DR%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(MULT_DR,A,'*')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(MULT_DR,A,'*')
    ELSE
      MULT_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
        MULT_DR%P = A%P
        J = DATA%RPTR(A%P)
        DO I = 1,DATA%RLENG(A%P)
            DATA%RHEAP(J) = DATA%RHEAP(J)*B
            J = J + 1
        END DO
      ELSE
        NV = DATA%NVARS(A%P)
        RL = DATA%RLENG(A%P)
        IF (NV/=DATA%SIZE_X) THEN
          CALL GETMEM(NV,RL,MULT_DR)
          IP1 = DATA%IPONT(A%P)
          IP2 = DATA%IPONT(MULT_DR%P)
          DATA%IHEAP(IP2:IP2+NV-1) = DATA%IHEAP(IP1:IP1+NV-1)
        ELSE
          CALL GETMEM(0,RL,MULT_DR)
        END IF
        IP1 = DATA%RPTR(MULT_DR%P)
        IP2 = DATA%RPTR(A%P)
        DO I = 1, RL
           DATA%RHEAP(IP1+I-1) = DATA%RHEAP(IP2+I-1)*B
        END DO
        CALL USED(A)
      END IF
    END IF
  END FUNCTION MULT_DR
  FUNCTION MULT_DS(A,B)
    TYPE (AD02_REAL) :: MULT_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MULT_DS,MULT_DR(A,REAL(B,WP)))
  END FUNCTION MULT_DS
  FUNCTION MULT_ID(A,B)
    TYPE (AD02_REAL) :: MULT_ID
    INTEGER, INTENT (IN):: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MULT_ID,MULT_DR(B,REAL(A,WP)))
  END FUNCTION MULT_ID
  FUNCTION MULT_RD(A,B)
    TYPE (AD02_REAL) :: MULT_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MULT_RD,MULT_DR(B,A))
  END FUNCTION MULT_RD
  FUNCTION MULT_SD(A,B)
    TYPE (AD02_REAL) MULT_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MULT_SD,MULT_DR(B,REAL(A,WP)))
  END FUNCTION MULT_SD
  FUNCTION NE_DD(A,B)
    LOGICAL :: NE_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DD = .TRUE.
    ELSE
      NE_DD = DATA%RHEAP(DATA%RPTR(A%P)) /= DATA%RHEAP(DATA%RPTR(B%P))
      IF ( .NOT. (NE_DD)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION NE_DD
  FUNCTION NE_DI(A,B)
    LOGICAL :: NE_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DI = .TRUE.
    ELSE
      NE_DI = DATA%RHEAP(DATA%RPTR(A%P)) /= B
      IF ( .NOT. (NE_DI)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION NE_DI
  FUNCTION NE_DR(A,B)
    LOGICAL :: NE_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DR = .TRUE.
    ELSE
      NE_DR = DATA%RHEAP(DATA%RPTR(A%P)) /= B
      IF ( .NOT. (NE_DR)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION NE_DR
  FUNCTION NE_DS(A,B)
    LOGICAL :: NE_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DS = .TRUE.
    ELSE
      NE_DS = DATA%RHEAP(DATA%RPTR(A%P)) /= B
      IF ( .NOT. (NE_DS)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION NE_DS
  FUNCTION NE_ID(A,B)
    LOGICAL :: NE_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_ID = .TRUE.
    ELSE
      NE_ID = A /= DATA%RHEAP(DATA%RPTR(B%P))
      IF ( .NOT. (NE_ID)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION NE_ID
  FUNCTION NE_RD(A,B)
    LOGICAL :: NE_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_RD = .TRUE.
    ELSE
      NE_RD = A /= DATA%RHEAP(DATA%RPTR(B%P))
      IF ( .NOT. (NE_RD)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION NE_RD
  FUNCTION NE_SD(A,B)
    LOGICAL :: NE_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_SD = .TRUE.
    ELSE
      NE_SD = A /= DATA%RHEAP(DATA%RPTR(B%P))
      IF ( .NOT. (NE_SD)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION NE_SD
  FUNCTION NINT_D(A)
    TYPE (AD02_REAL) :: NINT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    NINT_D%DATA => DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'NINT')
     ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'NINT')
    ELSE
      VA = DATA%RHEAP(DATA%RPTR(A%P))
      IF (ABS(VA-AINT(VA))*2.0_WP==1.0_WP) THEN
        CALL ERROR_HANDLER(DATA,NINT_WARN)
      END IF
      NINT_D%CASE = -DATA%CASE
      NINT_D = NINT(VA)
      NINT_D%CASE = -DATA%CASE
    END IF
  END FUNCTION NINT_D
  FUNCTION POW_DD(A,B)
    TYPE (AD02_REAL) :: POW_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    POW_DD%DATA => DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(POW_DD,A,B,'**')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(POW_DD,A,B,'**')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(POW_DD,A,B,'**')
    ELSE
      IF (DATA%RHEAP(DATA%RPTR(A%P))<=0.0_WP) THEN
        CALL ERROR_HANDLER(DATA,POW1_ERR)
        POW_DD%P = -1
        RETURN
      END IF
      CALL COPY(POW_DD,EXP(LOG(A)*B))
    END IF
  END FUNCTION POW_DD
  FUNCTION POW_DI(A,B)
    TYPE (AD02_REAL) :: POW_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(POW_DI,A,'**')
    ELSE IF (A%DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(POW_DI,A,'**')
    ELSE
      POW_DI%CASE = -A%DATA%CASE
      CALL UPOW(A,REAL(B,WP),POW_DI)
    END IF
  END FUNCTION POW_DI
  FUNCTION POW_DR(A,B)
    TYPE (AD02_REAL) :: POW_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(POW_DR,A,'**')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(POW_DR,A,'**')
    ELSE
      POW_DR%CASE = -DATA%CASE
      VA = DATA%RHEAP(DATA%RPTR(A%P))
      IF ((VA==0.0_WP) .AND. (REAL(INT(B),WP)/=B) .AND. (B<DATA%LEVEL)) THEN
        CALL ERROR_HANDLER(DATA,POW2_ERR)
        POW_DR%P = -1
      ELSE
        CALL UPOW(A,B,POW_DR)
      END IF
    END IF
  END FUNCTION POW_DR
  FUNCTION POW_DS(A,B)
    TYPE (AD02_REAL) :: POW_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(POW_DS,POW_DR(A,REAL(B,WP)))
  END FUNCTION POW_DS
  FUNCTION POW_ID(A,B)
    TYPE (AD02_REAL) :: POW_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
      CALL COPY(POW_ID,POW_RD(REAL(A,WP),B))
  END FUNCTION POW_ID
  FUNCTION POW_RD(A,B)
    TYPE (AD02_REAL) :: POW_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(POW_RD,B,'**')
    ELSE IF (B%DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(POW_RD,B,'**')
    ELSE
      CALL COPY(POW_RD,EXP(LOG(A)*B))
    END IF
  END FUNCTION POW_RD
  FUNCTION POW_SD(A,B)
    TYPE (AD02_REAL) :: POW_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(POW_SD,POW_RD(REAL(A,WP),B))
  END FUNCTION POW_SD
  FUNCTION REAL_D(A)
    TYPE (AD02_REAL), INTENT (IN) :: A
    TYPE (AD02_REAL) REAL_D
    INTEGER I1, I2, NR, NV, P1, P2
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    REAL_D%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(REAL_D,A,'DBLE')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(REAL_D,A,'DBLE')
    ELSE
    REAL_D%CASE = -DATA%CASE
    IF (A%CASE<0) THEN
      REAL_D%P = A%P
    ELSE
      NR = DATA%RLENG(A%P)
      NV = DATA%NVARS(A%P)
      IF (NV/=DATA%SIZE_X) THEN
        CALL GETMEM(NV,NR,REAL_D)
        I1 = DATA%IPONT(A%P)
        I2 = DATA%IPONT(REAL_D%P)
        DATA%IHEAP(I2:I2+NV-1) = DATA%IHEAP(I1:I1+NV-1)
      ELSE
        CALL GETMEM(0,NR,REAL_D)
      END IF
      P1 = DATA%RPTR(A%P)
      P2 = DATA%RPTR(REAL_D%P)
      DATA%RHEAP(P2:P2+NR-1) = DATA%RHEAP(P1:P1+NR-1)
    END IF
    END IF
  END FUNCTION REAL_D
  FUNCTION SIGN_DD(A,B)
    TYPE (AD02_REAL) :: SIGN_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    REAL (WP) VB,RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(SIGN_DD,A,B,'SIGN')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(SIGN_DD,A,B,'SIGN')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(SIGN_DD,A,B,'SIGN')
    ELSE
      VB = DATA%RHEAP(DATA%RPTR(B%P))
      IF (VB==0.0_WP) THEN
         CALL ERROR_HANDLER(DATA,SIGN_WARN)
         CALL RANDOM_NUMBER(RAND)
         CALL COPY(SIGN_DD,(RAND+RAND-1.0_WP)*ABS(A))
      ELSE
         CALL COPY(SIGN_DD,ABS(A)*SIGN(1.0_WP,VB))
      END IF
      CALL USED(B)
    END IF
  END FUNCTION SIGN_DD
  FUNCTION SIGN_DR(A,B)
    TYPE (AD02_REAL) :: SIGN_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(SIGN_DR,A,'SIGN')
    ELSE IF (A%DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(SIGN_DR,A,'SIGN')
    ELSE
      CALL COPY(SIGN_DR,ABS(A)*SIGN(1.0_WP,B))
    ENDIF
  END FUNCTION SIGN_DR
  FUNCTION SIGN_DS(A,B)
    TYPE (AD02_REAL) :: SIGN_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(SIGN_DS,SIGN_DR(A,REAL(B,WP)))
  END FUNCTION SIGN_DS
  FUNCTION SIGN_RD(A,B)
    TYPE (AD02_REAL) :: SIGN_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL (WP) VB, RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(SIGN_RD,B,'SIGN')
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(SIGN_RD,B,'SIGN')
    ELSE
      SIGN_RD%CASE = -DATA%CASE
      VB = DATA%RHEAP(DATA%RPTR(B%P))
      IF (VB>0.0_WP) THEN
        CALL COPY(SIGN_RD,DERIVS(ABS(A),DATA))
      ELSE IF (VB<0.0_WP) THEN
        CALL COPY(SIGN_RD,DERIVS(-ABS(A),DATA))
      ELSE
        CALL ERROR_HANDLER(DATA,SIGN_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(SIGN_RD,DERIVS((RAND+RAND-1.0_WP)*ABS(A),DATA))
      END IF
      CALL USED(B)
    END IF
  END FUNCTION SIGN_RD
  FUNCTION SIGN_SD(A,B)
    TYPE (AD02_REAL) :: SIGN_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(SIGN_SD,SIGN_RD(REAL(A,WP),B))
  END FUNCTION SIGN_SD
  FUNCTION SIN_D(X)
    TYPE (AD02_REAL) :: SIN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG, VS, VC
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(SIN_D,X,'SIN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(SIN_D,X,'SIN')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
      VS = SIN(VG)
      VC = COS(VG)
      DO I = 0, DATA%LEVEL, 4
        DERF(I) = VS
        DERF(I+1) = VC
        DERF(I+2) = -VS
        DERF(I+3) = -VC
      END DO
      CALL UNARY(X,SIN_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION SIN_D
  FUNCTION SINH_D(X)
    TYPE (AD02_REAL) :: SINH_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG, VS, VC
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(SINH_D,X,'SINH')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(SINH_D,X,'SINH')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
      VS = SINH(VG)
      VC = COSH(VG)
      DO I = 0, DATA%LEVEL, 2
        DERF(I) = VS
        DERF(I+1) = VC
      END DO
      CALL UNARY(X,SINH_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION SINH_D
  FUNCTION SQRT_D(X)
    TYPE (AD02_REAL) :: SQRT_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG, D, T
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(SQRT_D,X,'SQRT')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(SQRT_D,X,'SQRT')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
      T = 0.5_WP
      IF (VG==0.0_WP) THEN
        CALL ERROR_HANDLER(DATA,SQRT_ERR)
        CALL AD02_UNDEFINE(SQRT_D,DATA)
        RETURN
      END IF
      D = SQRT(VG)
      DERF(0) = D
      DO I = 1, DATA%LEVEL
        D = T*D/VG
        T = T - 1.0_WP
        DERF(I) = D
      END DO
      CALL UNARY(X,SQRT_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION SQRT_D
  FUNCTION TAN_D(X)
    TYPE (AD02_REAL) :: TAN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    TYPE (AD02_REAL) :: A
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(TAN_D,X,'TAN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(TAN_D,X,'TAN')
    ELSE
      A = X
      CALL COPY(TAN_D,SIN(A)/COS(A))
      DATA%RHEAP(DATA%RPTR(TAN_D%P)) = TAN(DATA%RHEAP(DATA%RPTR(A%P)))
    END IF
  END FUNCTION TAN_D
  FUNCTION TANH_D(X)
    TYPE (AD02_REAL) :: TANH_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    TYPE (AD02_REAL) :: A
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(TANH_D,X,'TANH')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(TANH_D,X,'TANH')
    ELSE
      A = X
      CALL COPY(TANH_D,SINH(A)/COSH(A))
      DATA%RHEAP(DATA%RPTR(TANH_D%P)) = TANH(DATA%RHEAP(DATA%RPTR(A%P)))
    END IF
  END FUNCTION TANH_D
  SUBROUTINE ADD_CONST(INPUT,CONST,OUTPUT)
    TYPE (AD02_REAL), INTENT (IN) :: INPUT
    REAL (WP), INTENT (IN) :: CONST
    TYPE (AD02_REAL), INTENT (OUT) :: OUTPUT
    INTEGER I, I1, I2, RLEN, ILEN
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => INPUT%DATA
    OUTPUT%DATA => DATA
    RLEN = DATA%RLENG(INPUT%P)
    ILEN = DATA%NVARS(INPUT%P)
    IF (ILEN/=DATA%SIZE_X) THEN
      CALL GETMEM(ILEN,RLEN,OUTPUT)
      I1 = DATA%IPONT(INPUT%P)
      I2 = DATA%IPONT(OUTPUT%P)
      DO I = 0, DATA%NVARS(INPUT%P) - 1
        DATA%IHEAP(I2+I) = DATA%IHEAP(I1+I)
      END DO
    ELSE
      CALL GETMEM(0,RLEN,OUTPUT)
    END IF
    I1 = DATA%RPTR(INPUT%P)
    I2 = DATA%RPTR(OUTPUT%P)
    DATA%RHEAP(I2) = DATA%RHEAP(I1) + CONST
    DO I = 1, DATA%RLENG(INPUT%P) - 1
      DATA%RHEAP(I2+I) = DATA%RHEAP(I1+I)
    END DO
    CALL USED(INPUT)
  END SUBROUTINE ADD_CONST
  SUBROUTINE BINARY_WARNING(FUN,A,B,PROC)
    TYPE (AD02_REAL), INTENT (OUT) :: FUN
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    CHARACTER(*), OPTIONAL, INTENT(IN) :: PROC
    IF (ASSOCIATED(A%DATA) ) THEN
      CALL ERROR_HANDLER(A%DATA,UNDEF_WARN,PROC)
      FUN%DATA => A%DATA
    END IF
    IF (.NOT.ASSOCIATED(A%DATA,B%DATA) )THEN
      CALL ERROR_HANDLER(B%DATA,UNDEF_WARN,PROC)
      IF (ASSOCIATED(B%DATA) ) FUN%DATA => B%DATA
    END IF
    FUN%P = -1
  END SUBROUTINE BINARY_WARNING
  SUBROUTINE CONTROL1(LP,MP,PRINT_LEVEL,STOP_LEVEL)
    INTEGER, OPTIONAL, INTENT (IN) :: LP
    INTEGER, OPTIONAL, INTENT (IN) :: MP
    INTEGER, OPTIONAL, INTENT (IN) :: PRINT_LEVEL
    INTEGER, OPTIONAL, INTENT (IN) :: STOP_LEVEL
    IF (PRESENT(LP)) ERROR_MESSAGE_UNIT = LP
    IF (PRESENT(MP)) WARNING_MESSAGE_UNIT = MP
    IF (PRESENT(PRINT_LEVEL)) ERROR_PRINT_LEVEL = PRINT_LEVEL
    IF (PRESENT(STOP_LEVEL)) ERROR_STOP_LEVEL = STOP_LEVEL
  END SUBROUTINE CONTROL1
  SUBROUTINE CONTROL2(DATA,ERROR,LP,MP,PRINT_LEVEL,STOP_LEVEL)
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: LP
    INTEGER, OPTIONAL, INTENT (IN) :: MP
    INTEGER, OPTIONAL, INTENT (IN) :: PRINT_LEVEL
    INTEGER, OPTIONAL, INTENT (IN) :: STOP_LEVEL
    IF(ASSOCIATED(DATA))THEN
      ERROR = 0
      IF (PRESENT(LP)) DATA%ERROR_MESSAGE_UNIT = LP
      IF (PRESENT(MP)) DATA%WARNING_MESSAGE_UNIT = MP
      IF (PRESENT(PRINT_LEVEL)) DATA%ERROR_PRINT_LEVEL = PRINT_LEVEL
      IF (PRESENT(STOP_LEVEL)) DATA%ERROR_STOP_LEVEL = STOP_LEVEL
    ELSE
      ERROR = 2
    END IF
  END SUBROUTINE CONTROL2
  SUBROUTINE COPY(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    A%P = B%P
    A%CASE = B%CASE
    A%DATA => B%DATA
  END SUBROUTINE COPY
  LOGICAL FUNCTION DATA_UNDEFINED(X)
    TYPE (AD02_REAL), INTENT (IN) :: X
    IF(ASSOCIATED(X%DATA)) THEN
      DATA_UNDEFINED = X%P==-1 .OR. X%DATA%CASE/=ABS(X%CASE)
      IF (X%DATA%CASE==-1) DATA_UNDEFINED = .FALSE.
    ELSE
      DATA_UNDEFINED = .FALSE.
    END IF
  END FUNCTION DATA_UNDEFINED
  FUNCTION DERIVS_I(A,DATA)
    TYPE (AD02_REAL) :: DERIVS_I
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_DATA),POINTER :: DATA
    DERIVS_I%DATA => DATA
    CALL PACCNT(REAL(A,WP),DERIVS_I)
  END FUNCTION DERIVS_I
  FUNCTION DERIVS_R(A,DATA)
    TYPE (AD02_REAL) :: DERIVS_R
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_DATA),POINTER  :: DATA
    DERIVS_R%DATA => DATA
    CALL PACCNT(A,DERIVS_R)
  END FUNCTION DERIVS_R
  SUBROUTINE DERIVS_S(A,R,INDEX,DERIVS,ERROR)
!?? To obtain the derivatives of a dependant variable in a packed form.
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: R
    INTEGER, POINTER, DIMENSION (:) :: INDEX
    REAL (WP), POINTER, DIMENSION (:) :: DERIVS
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER LENGTH_INDEX, LENGTH_DERIVS, I, J
    TYPE(AD02_DATA), POINTER :: DATA
    ERROR = 0
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    ELSE IF (R<0 .OR. R>A%DATA%LEVEL) THEN
      ERROR = 4
    END IF
    IF(ERROR>0)RETURN
    DATA => A%DATA
    IF (DATA%NVARS(A%P)==0) THEN
        ALLOCATE (INDEX(0))
        IF (R==0) THEN
          ALLOCATE (DERIVS(1))
          DERIVS(1) = DATA%RHEAP(DATA%RPTR(A%P))
        ELSE
          ALLOCATE (DERIVS(0))
        END IF
    ELSE
        LENGTH_DERIVS = DATA%IBINCO(R+DATA%NVARS(A%P)-1,R)
        ALLOCATE (INDEX(DATA%NVARS(A%P)))
        ALLOCATE (DERIVS(LENGTH_DERIVS))
        IF (DATA%NVARS(A%P)==DATA%SIZE_X) THEN
          DO I = 1, DATA%SIZE_X
            INDEX(I) = I
          END DO
          LENGTH_INDEX = DATA%SIZE_X
        ELSE
          LENGTH_INDEX = DATA%NVARS(A%P)
          J = DATA%IPONT(A%P)
          DO I = 1, LENGTH_INDEX
            INDEX(I) = DATA%IHEAP(J)
            J = J + 1
          END DO
        END IF
        IF (R>0) THEN
          DERIVS = DATA%RHEAP(DATA%RPTR(A%P)+DATA%IBINCO(R-1+LENGTH_INDEX,R-1):
            DATA%RPTR(A%P)+DATA%IBINCO(R-1+LENGTH_INDEX,R-1)+LENGTH_DERIVS-1)
        ELSE
          DERIVS = DATA%RHEAP(DATA%RPTR(A%P))
        END IF
    END IF
  END SUBROUTINE DERIVS_S
  SUBROUTINE ERROR_HANDLER(DATA,ERROR_NUMBER,PROC)
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, INTENT(IN) :: ERROR_NUMBER
    CHARACTER(*), OPTIONAL, INTENT(IN) :: PROC
    IF(ASSOCIATED(DATA))THEN
      DATA%FLAGS(ERROR_NUMBER) = DATA%FLAGS(ERROR_NUMBER) + 1
    ELSE
      AD02_FLAG(ERROR_NUMBER) = AD02_FLAG(ERROR_NUMBER) + 1
    END IF
    SELECT CASE (ERROR_NUMBER)
    CASE (1)
      CALL ERR_MESS_PRINT(DATA,'ERROR: Invalid call of AD02_INITIALIZE.', &
       .FALSE.)
    CASE (2)
      CALL ERR_MESS_PRINT(DATA, &
        'ERROR: Procedure call without prior AD02_INITIALIZE call.',.FALSE.)
    CASE (3)
      CALL ERR_MESS_PRINT(DATA, &
        'ERROR: Insufficient storage(failure of an ALLOCATE statment).', &
        .FALSE.)
    CASE (4)
      CALL ERR_MESS_PRINT(DATA,'ERROR: Invalid call of AD02_RESTORE',.FALSE.)
    CASE (5)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of SQRT(A) when A is of type AD02_REAL and has     &
     &         value 0.',.TRUE.)
    CASE (6)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of A**B when A and B are of type AD02_REAL, and A  &
     &         has a non-positive value.',.TRUE.)
    CASE (7)
      CALL ERR_MESS_PRINT(DATA, &
     'WARNING: Calculation of A**B when A is of type AD02_REAL, and B is of   &
     &         type REAL, A has value 0, and b has a non-integer value less   &
     &         than DEGREE.',.TRUE.)
    CASE (8)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of SIGN(A,B) when B is of type AD02_REAL and has   &
     &         value 0.',.TRUE.)
    CASE (9)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of ABS(A) or SIGN(A,B) when A is of type AD02_REAL &
     &         and has value 0.',.TRUE.)
    CASE (10)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of INT(A) when A is of type AD02_REAL and has an   &
     &         integer value.',.TRUE.)
    CASE (11)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of AINT(A) when A is of type AD02_REAL and has an  &
     &         integer value.',.TRUE.)
    CASE (12)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of NINT(A) when A is of type AD02_REAL and has a   &
     &         value n + 0.5, where n is an integer.',.TRUE.)
    CASE (13)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of ANINT(A) when A is of type AD02_REAL and has a  &
     &         value n + 0.5, where n is an integer.',.TRUE.)
    CASE (14)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of MAX(A,B) when at least one of A and B is of     &
     &         type AD02_REAL and A has the same value as B.', .TRUE.)
    CASE (15)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of MIN(A,B) when at least one of A and B is of     &
     &         type AD02_REAL and A has the same value as B.', .TRUE.)
    CASE (16)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A==B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (17)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A/=B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (18)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A>B when at least one of A and B is of type      &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (19)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A<B when at least one of A and B is of type      &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (20)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A>=B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (21)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A<=B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (33)
      CALL ERR_MESS_PRINT(DATA, &
        'WARNING: Execution of '//PROC//' for value AD02_UNDEFINED.', .TRUE.)
    CASE (34)
      CALL ERR_MESS_PRINT(DATA, &
        'WARNING: Assignment to array of type AD02_REAL', .TRUE.)
    END SELECT
  CONTAINS
    SUBROUTINE ERR_MESS_PRINT(DATA,ERROR_MESSAGE,WARNING)
      TYPE(AD02_DATA),POINTER :: DATA
      CHARACTER (LEN=*), INTENT (IN) :: ERROR_MESSAGE
      LOGICAL, INTENT (IN) :: WARNING
      INTEGER :: I,J
      IF(ASSOCIATED(DATA))THEN
        IF (WARNING) THEN
          IF (DATA%ERROR_PRINT_LEVEL==2) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (DATA%ERROR_STOP_LEVEL==2) STOP 'AD02 EXECUTION HALTED'
        ELSE
          IF (DATA%ERROR_PRINT_LEVEL/=0) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (DATA%ERROR_STOP_LEVEL/=0) STOP 'AD02 EXECUTION HALTED'
        END IF
      ELSE
        IF (WARNING) THEN
          IF (ERROR_PRINT_LEVEL==2) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (ERROR_STOP_LEVEL==2) STOP 'AD02 EXECUTION HALTED'
        ELSE
          IF (ERROR_PRINT_LEVEL/=0) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (ERROR_STOP_LEVEL/=0) STOP 'AD02 EXECUTION HALTED'
        END IF
      END IF
    END SUBROUTINE ERR_MESS_PRINT
  END SUBROUTINE ERROR_HANDLER
  SUBROUTINE EXPAND(INDEX_LIST_TO_EXP_ST,EXP_ST_SIZE,DATA)
    INTEGER, INTENT (IN) :: INDEX_LIST_TO_EXP_ST(:), EXP_ST_SIZE
    TYPE(AD02_DATA) :: DATA
    INTEGER START_POS, I, J, K, SIZE_INDEX_LIST, OLD_POS, BIN, LEVEL_SIZE
    INTEGER OLD_POS_FUTURE
    SIZE_INDEX_LIST = SIZE(INDEX_LIST_TO_EXP_ST)
    START_POS = DATA%SIZE_X + 1
    DATA%IHEAP(START_POS) = 0
    START_POS = DATA%SIZE_X + 2
    IF (DATA%LEVEL>0) THEN
      DO I = 1,SIZE_INDEX_LIST
         DATA%IHEAP(START_POS+I-1) = INDEX_LIST_TO_EXP_ST(I)
      END DO
      OLD_POS = START_POS
      START_POS = START_POS + SIZE_INDEX_LIST
      DO I = 2, DATA%LEVEL
        OLD_POS_FUTURE = START_POS
        LEVEL_SIZE = DATA%IBINCO(I+EXP_ST_SIZE-2,I-1)
        DO J = 1, SIZE_INDEX_LIST
          BIN = DATA%IBINCO(J+I-2,I-1)
          DO K = 1,BIN
            DATA%IHEAP(START_POS+K-1) = DATA%IHEAP(OLD_POS+K-1) + &
              DATA%IBINCO(INDEX_LIST_TO_EXP_ST(J)+I-2,I) + LEVEL_SIZE
          END DO
          START_POS = START_POS + BIN
        END DO
        OLD_POS = OLD_POS_FUTURE
      END DO
    END IF
  END SUBROUTINE EXPAND
  SUBROUTINE FINALIZE(DATA,ERROR)
     TYPE(AD02_DATA), POINTER :: DATA
     INTEGER, INTENT (OUT) :: ERROR
     INTEGER STAT(2)
     ERROR = 0
     IF(.NOT.ASSOCIATED(DATA))THEN
        ERROR = 1
        RETURN
     END IF
     IF(DATA%CASE/=-1)THEN
       DEALLOCATE (DATA%IPONT,DATA%RPTR,DATA%RLENG,DATA%NVARS,STAT=STAT(1))
       DEALLOCATE (DATA%RHEAP,DATA%IHEAP,DATA%FLAGS,STAT=STAT(1))
       DATA%CASE = -1
       IF(ANY(STAT/=0))ERROR = 3
     END IF
  END SUBROUTINE FINALIZE
  SUBROUTINE FLAGS1(L,FLAG,ERROR,RESET)
     INTEGER, INTENT(IN) :: L
     INTEGER, INTENT(OUT) :: FLAG,ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40) THEN
        ERROR = 1
     ELSE
        ERROR = 0
        FLAG = AD02_FLAG(L)
        IF(PRESENT(RESET)) THEN
          IF(RESET)AD02_FLAG(L)=0
        END IF
     END IF
  END SUBROUTINE FLAGS1
  SUBROUTINE FLAGS2(L,U,FLAG,ERROR,RESET)
     INTEGER, INTENT(IN) :: L,U
     INTEGER, INTENT(OUT) :: FLAG(L:U),ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40 .OR. U<1 .OR. U>40) THEN
        ERROR = 1
     ELSE
        ERROR = 0
        FLAG(L:U) = AD02_FLAG(L:U)
        IF(PRESENT(RESET)) THEN
          IF(RESET)AD02_FLAG(L:U)=0
        END IF
     END IF
  END SUBROUTINE FLAGS2
  SUBROUTINE FLAGS3(DATA,L,FLAG,ERROR,RESET)
     TYPE(AD02_DATA),POINTER :: DATA
     INTEGER, INTENT(IN) :: L
     INTEGER, INTENT(OUT) :: FLAG,ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40) THEN
        ERROR = 1
     ELSE IF (.NOT.ASSOCIATED(DATA))THEN
        ERROR = 2
     ELSE IF (.NOT.ASSOCIATED(DATA%FLAGS))THEN
        ERROR = 3
     ELSE
        ERROR = 0
        FLAG = DATA%FLAGS(L)
        IF(PRESENT(RESET)) THEN
          IF(RESET)DATA%FLAGS(L)=0
        END IF
     END IF
  END SUBROUTINE FLAGS3
  SUBROUTINE FLAGS4(DATA,L,U,FLAG,ERROR,RESET)
     TYPE(AD02_DATA),POINTER :: DATA
     INTEGER, INTENT(IN) :: L,U
     INTEGER, INTENT(OUT) :: FLAG(L:U),ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40 .OR. U<1 .OR. U>40) THEN
        ERROR = 1
     ELSE IF (.NOT.ASSOCIATED(DATA))THEN
        ERROR = 2
     ELSE IF (.NOT.ASSOCIATED(DATA%FLAGS))THEN
        ERROR = 3
     ELSE
        ERROR = 0
        FLAG(L:U) = DATA%FLAGS(L:U)
        IF(PRESENT(RESET)) THEN
          IF(RESET)DATA%FLAGS(L:U)=0
        END IF
     END IF
  END SUBROUTINE FLAGS4
  SUBROUTINE GC(NO_INT,NO_REAL,DATA)
    INTEGER, INTENT (IN) :: NO_INT, NO_REAL
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, ALLOCATABLE :: ADDR(:), TEMP(:)
    INTEGER, POINTER :: ITEMP(:)
    REAL (WP), POINTER :: RTEMP(:)
    INTEGER I, IP, IR, J, NF, NI, NR, STAT, D_POINTER
    INTEGER :: IHSZ,IRSZ
    INTEGER :: IPSZ
    IHSZ = SIZE(DATA%IHEAP)
    IRSZ = SIZE(DATA%RHEAP)
    IPSZ = SIZE(DATA%IPONT)
    IF ((DATA%IHTOS>2*DATA%SIZE_X+DATA%REAL_STRUCT_SIZE+1 .AND. &
         DATA%SWITCH_POINT> 0) .OR. &
        (DATA%IRTOS>DATA%REAL_STRUCT_SIZE*DATA%SIZE_X .AND. &
         DATA%SWITCH_POINT<1))  THEN
      ALLOCATE (ADDR(IPSZ), TEMP(IPSZ),STAT=STAT)
      IF (STAT/=0) THEN
        CALL ERROR_HANDLER(DATA,ALLOC_ERR)
        RETURN
      END IF
      NF = 0
      DO I = DATA%SIZE_X + 1, DATA%IPTOS - 1
        NF = NF + 1
        TEMP(NF) = DATA%RPTR(I)
      END DO
      IF (NF>0) CALL KB07AI(TEMP,NF,ADDR)
      DO I = 1,NF
        ADDR(I) = ADDR(I)+DATA%SIZE_X
      END DO
      D_POINTER = DATA%DEAD_POINTER
      DO
        IF (D_POINTER==-1) THEN
          EXIT
        ELSE
          DATA%NVARS(D_POINTER) = 0
          DATA%RLENG(D_POINTER) = 0
          D_POINTER = DATA%IPONT(D_POINTER)
        END IF
      END DO
      IF (DATA%SWITCH_POINT>0) THEN
        DATA%IHTOS = 2*DATA%SIZE_X + DATA%REAL_STRUCT_SIZE + 1
        DATA%IRTOS = ((1+DATA%LEVEL)*DATA%SIZE_X) + 1
      ELSE
        DATA%IHTOS = DATA%SIZE_X + 1
        DATA%IRTOS = DATA%REAL_STRUCT_SIZE*DATA%SIZE_X + 1
      END IF
      DO I = 1, NF
        IR = DATA%RPTR(ADDR(I))
        IP = DATA%IPONT(ADDR(I))
        NI = DATA%NVARS(ADDR(I))
        NR = DATA%RLENG(ADDR(I))
        IF (IP>DATA%IHTOS) THEN
          DO J = 0, NI - 1
            DATA%IHEAP(DATA%IHTOS+J) = DATA%IHEAP(IP+J)
          END DO
          IF (NI/=0) DATA%IPONT(ADDR(I)) = DATA%IHTOS
          DATA%IHTOS = DATA%IHTOS + NI
        ELSE IF (IP==DATA%IHTOS) THEN
          DATA%IHTOS = DATA%IHTOS + NI
        END IF
        IF (IR>DATA%IRTOS) THEN
          DO J = 0, NR - 1
            DATA%RHEAP(DATA%IRTOS+J) = DATA%RHEAP(IR+J)
          END DO
          DATA%RPTR(ADDR(I)) = DATA%IRTOS
          DATA%IRTOS = DATA%IRTOS + NR
        ELSE IF (IR==DATA%IRTOS) THEN
          DATA%IRTOS = DATA%IRTOS + NR
        END IF
      END DO
      DEALLOCATE (ADDR, TEMP)
    END IF
    IF ((DATA%IHTOS+NO_INT)*10>IHSZ) THEN
      IHSZ = MAX(IHSZ*2,(DATA%IHTOS+NO_INT)*5)
      ALLOCATE (ITEMP(IHSZ),STAT=STAT)
      IF (STAT/=0) THEN
        CALL ERROR_HANDLER(DATA,ALLOC_ERR)
        RETURN
      END IF
      ITEMP(1:DATA%IHTOS-1) = DATA%IHEAP(1:DATA%IHTOS-1)
      DEALLOCATE (DATA%IHEAP)
      DATA%IHEAP => ITEMP
    END IF
    IF ((DATA%IRTOS+NO_REAL)*10>IRSZ) THEN
      IRSZ = MAX(IRSZ*2,(DATA%IRTOS+NO_REAL)*5)
      ALLOCATE (RTEMP(IRSZ),STAT=STAT)
      IF (STAT/=0) THEN
        CALL ERROR_HANDLER(DATA,ALLOC_ERR)
        RETURN
      END IF
      RTEMP(1:DATA%IRTOS-1) = DATA%RHEAP(1:DATA%IRTOS-1)
      DEALLOCATE (DATA%RHEAP)
      DATA%RHEAP => RTEMP
    END IF
  END SUBROUTINE GC
  SUBROUTINE GETMEM(NI,NR,VAR)
    INTEGER, INTENT (IN) :: NI, NR
    TYPE (AD02_REAL), INTENT (INOUT) :: VAR
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => VAR%DATA
    IF (NI+DATA%IHTOS>SIZE(DATA%IHEAP).OR.NR+DATA%IRTOS>SIZE(DATA%RHEAP))THEN
      CALL GC(NI,NR,DATA)
      IF (DATA%CASE==0) RETURN
    END IF
    IF (DATA%DEAD_POINTER==-1) THEN
      IF (DATA%IPTOS>SIZE(DATA%IPONT)) CALL MORE_MEMORY(DATA)
      VAR%P = DATA%IPTOS
      DATA%IPTOS = DATA%IPTOS + 1
    ELSE
      VAR%P = DATA%DEAD_POINTER
      DATA%DEAD_POINTER = DATA%IPONT(DATA%DEAD_POINTER)
    END IF
    VAR%CASE = -DATA%CASE
    DATA%RPTR(VAR%P) = DATA%IRTOS
    DATA%IRTOS = DATA%IRTOS + NR
    DATA%RLENG(VAR%P) = NR
    IF (NI>0) THEN
      DATA%IPONT(VAR%P) = DATA%IHTOS
      DATA%NVARS(VAR%P) = NI
      DATA%IHTOS = DATA%IHTOS + NI
    ELSE IF (NR/=1 .OR. DATA%LEVEL==0) THEN
      DATA%NVARS(VAR%P) = DATA%SIZE_X
      DATA%IPONT(VAR%P) = 1
    ELSE
      DATA%IPONT(VAR%P) = DATA%IHTOS
      DATA%NVARS(VAR%P) = NI
      DATA%IHTOS = DATA%IHTOS + NI
    END IF
  END SUBROUTINE GETMEM
  SUBROUTINE GRAD0(A,GRAD,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: GRAD
    INTEGER, INTENT (OUT) :: ERROR
    REAL (WP) X1(1)
    CALL GRAD1(A,X1,ERROR)
    GRAD = X1(1)
  END SUBROUTINE GRAD0
  SUBROUTINE GRAD1(A,GRAD,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: GRAD(:)
    INTEGER, INTENT (OUT) :: ERROR
    TYPE(AD02_DATA), POINTER :: DATA
    INTEGER N, IP, IDER, NV, I
    ERROR = 0
    GRAD = 0.0_WP
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    ELSE
      DATA => A%DATA
      IF (DATA%LEVEL==0) THEN
        ERROR = 4
      ELSE IF (DATA%SIZE_X/=SIZE(GRAD)) THEN
        ERROR = 5
      END IF
    END IF
    IF(ERROR>0)RETURN
      IDER = DATA%RPTR(A%P)
      N = DATA%NVARS(A%P)
      IF (N==DATA%SIZE_X) THEN
        GRAD(1:N) = DATA%RHEAP(IDER+1:IDER+N)
      ELSE
        IP = DATA%IPONT(A%P)
        DO I = 1, N
          NV = DATA%IHEAP(IP+I-1)
          GRAD(NV) = DATA%RHEAP(IDER+I)
        END DO
      END IF
  END SUBROUTINE GRAD1
  SUBROUTINE HESSIAN0(A,HESSIAN,ERROR,GRAD)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: HESSIAN
    INTEGER, INTENT (OUT) :: ERROR
    REAL (WP), OPTIONAL, INTENT (OUT) :: GRAD
    REAL (WP) :: H1(1,1), G1(1)
    IF (PRESENT(GRAD)) THEN
      CALL HESSIAN1(A,H1,ERROR,G1)
      HESSIAN = H1(1,1)
      GRAD = G1(1)
    ELSE
      CALL HESSIAN1(A,H1,ERROR)
      HESSIAN = H1(1,1)
    END IF
  END SUBROUTINE HESSIAN0
  SUBROUTINE HESSIAN1(A,HESSIAN,ERROR,GRAD)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: HESSIAN(:,:)
    INTEGER, INTENT (OUT) :: ERROR
    REAL (WP), OPTIONAL, INTENT (OUT) :: GRAD(:)
    INTEGER I, K, L, NV, J
    TYPE(AD02_DATA), POINTER :: DATA
    INTEGER, ALLOCATABLE :: LVARS(:)
    HESSIAN = 0.0_WP
    ERROR = 0
    IF (PRESENT(GRAD)) CALL AD02_GRAD(A,GRAD,ERROR)
    IF(ERROR>0)RETURN
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    ELSE
      DATA => A%DATA
      IF (DATA%LEVEL<2) THEN
        ERROR = 4
      ELSE IF (SIZE(HESSIAN,1)/=DATA%SIZE_X .OR. &
             SIZE(HESSIAN,2)/=DATA%SIZE_X) THEN
        ERROR = 6
      END IF
    END IF
    IF(ERROR>0)RETURN
    ALLOCATE(LVARS(0:DATA%SIZE_X))
    NV = DATA%NVARS(A%P)
    IF (NV==DATA%SIZE_X) THEN
        L = DATA%RPTR(A%P) + DATA%SIZE_X
        DO I = 1, DATA%SIZE_X
          K = L + I*(I-1)/2
          DO J = 1, I - 1
            HESSIAN(I,J) = DATA%RHEAP(K+J)
            HESSIAN(J,I) = HESSIAN(I,J)
          END DO
          HESSIAN(I,I) = DATA%RHEAP(K+I)*2.0_WP
        END DO
    ELSE
        K = DATA%IPONT(A%P)
        L = DATA%RPTR(A%P) + NV
        K = K - 1
        DO I = 1, DATA%SIZE_X
          DO J = 1, NV
            IF (I==DATA%IHEAP(K+J)) EXIT
          END DO
          LVARS(I) = J
        END DO
        DO I = 1, DATA%SIZE_X
          IF (LVARS(I)>NV) CYCLE
          K = L + LVARS(I)*(LVARS(I)-1)/2
          DO J = 1, DATA%SIZE_X
            IF (LVARS(J)>LVARS(I)) CYCLE
            HESSIAN(I,J) = DATA%RHEAP(K+LVARS(J))
            HESSIAN(J,I) = HESSIAN(I,J)
          END DO
          HESSIAN(I,I) = HESSIAN(I,I)*2.0_WP
        END DO
    END IF
  END SUBROUTINE HESSIAN1
  SUBROUTINE INITIALIZE_DATA(DATA,ERROR)
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER STAT
    ALLOCATE (DATA,STAT=STAT)
    IF (STAT/=0) THEN
       ERROR = 3
       RETURN
    END IF
    ALLOCATE(DATA%FLAGS(40),STAT=STAT)
    IF (STAT/=0) THEN
       ERROR = 3
       RETURN
    END IF
    DATA%FLAGS = 0
    DATA%MAX_CASE = DATA%MAX_CASE + 1
    DATA%CASE = DATA%MAX_CASE
  END SUBROUTINE INITIALIZE_DATA
  SUBROUTINE INITIALIZE_11(DEGREE,X,VALUE,DATA,ERROR,FULL_THRESHOLD)
    INTEGER, INTENT (IN) :: DEGREE
    TYPE (AD02_REAL), INTENT (OUT) :: X(:)
    REAL (WP), INTENT (IN) :: VALUE(:)
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: FULL_THRESHOLD
    INTEGER STAT, I, J, UPPER, LOWER, MARKER, MAXVAR, NEW_MARKER
    INTEGER :: IHSZ,IRSZ
    INTEGER :: IPSZ
    INTEGER :: IBSH(2)
    ERROR = 0
    IF (SIZE(X)/=SIZE(VALUE)) THEN
       ERROR = 5
       RETURN
    ELSE IF (DEGREE<0) THEN
       ERROR = 4
       RETURN
    END IF
    IF(.NOT.ASSOCIATED(DATA)) THEN
       ALLOCATE (DATA,STAT=STAT)
       IF (STAT/=0) THEN
          ERROR = 3
          RETURN
       END IF
    ELSE IF (DATA%CASE==-1) THEN
       ALLOCATE (DATA,STAT=STAT)
       IF (STAT/=0) THEN
          ERROR = 3
          RETURN
       END IF
    END IF
    IF(.NOT.ASSOCIATED(DATA%FLAGS)) THEN
       ALLOCATE(DATA%FLAGS(40),STAT=STAT)
       IF (STAT/=0) THEN
          ERROR = 3
          RETURN
       END IF
       DATA%FLAGS = 0
    END IF
    DATA%MAX_CASE = DATA%MAX_CASE + 1
    DATA%CASE = DATA%MAX_CASE
    DO I = 1,SIZE(X)
      X(I)%DATA => DATA
      X(I)%CASE = DATA%CASE
    END DO
    DATA%SIZE_X = SIZE(X)
    DATA%LEVEL = DEGREE
    DATA%DEAD_POINTER = -1
    MAXVAR = SIZE(X) + 1
    IPSZ = -1
    IF(ASSOCIATED(DATA%IPONT)) IPSZ = SIZE(DATA%IPONT)
    IF (IPSZ<MAXVAR*10) THEN
      IF(IPSZ>=0) DEALLOCATE (DATA%IPONT,DATA%RPTR,DATA%RLENG,DATA%NVARS)
      IPSZ = MAXVAR*10
      ALLOCATE (DATA%IPONT(IPSZ),DATA%RPTR(IPSZ),DATA%RLENG(IPSZ),&
             DATA%NVARS(IPSZ),STAT=STAT)
      IF (STAT/=0) THEN
         ERROR = 3
         RETURN
      END IF
    END IF
    DATA%IPTOS = 2
    IRSZ = -1
    IF(ASSOCIATED(DATA%RHEAP)) IRSZ = SIZE(DATA%RHEAP)
    IF(IRSZ < HEAP_SIZE) THEN
      IF(IRSZ>=0) DEALLOCATE (DATA%RHEAP)
      IRSZ = HEAP_SIZE
      ALLOCATE (DATA%RHEAP(IRSZ),STAT=STAT)
      IF (STAT/=0) THEN
        ERROR = 3
        RETURN
      END IF
    END IF
    DATA%IRTOS = 1
    IBSH = -1
    IF(ASSOCIATED(DATA%IBINCO)) IBSH = SHAPE(DATA%IBINCO)
    IF ( MAX(DEGREE,DATA%SIZE_X)+2>IBSH(2) .OR. &
              DEGREE+DATA%SIZE_X+2>IBSH(1) ) THEN
      IF(ASSOCIATED(DATA%IBINCO)) DEALLOCATE (DATA%IBINCO)
      ALLOCATE (DATA%IBINCO(-1:DEGREE+DATA%SIZE_X,-1:DEGREE),STAT=STAT)
      IF (STAT/=0) THEN
         ERROR = 3
         RETURN
      END IF
      DATA%IBINCO(0,:) = 0
      DATA%IBINCO(0,0) = 1
      DATA%IBINCO(-1,:) = 0
      DATA%IBINCO(:,-1) = 0
      DO I = 1, DEGREE + DATA%SIZE_X
        DATA%IBINCO(I,0) = 1
        DO J = 1, DEGREE
          DATA%IBINCO(I,J) = DATA%IBINCO(I-1,J-1) + DATA%IBINCO(I-1,J)
        END DO
      END DO
    END IF
    DATA%REAL_STRUCT_SIZE = DATA%IBINCO(DEGREE+DATA%SIZE_X,DEGREE)
    IF (DEGREE==0) THEN
      DATA%SWITCH_POINT = 0
    ELSE IF ( (PRESENT(FULL_THRESHOLD))) THEN
      DATA%SWITCH_POINT = MIN(DATA%SIZE_X,FULL_THRESHOLD)
    ELSE IF (DATA%SIZE_X<=5) THEN
      DATA%SWITCH_POINT = 0
    ELSE
      LOWER = 1
      UPPER = DATA%SIZE_X
      MARKER = 1
      DO
        NEW_MARKER = (UPPER+LOWER+1)/2
        IF (MARKER==NEW_MARKER) EXIT
        MARKER = NEW_MARKER
        IF (DATA%REAL_STRUCT_SIZE>2*DATA%IBINCO(DEGREE+MARKER,DEGREE)) THEN
          LOWER = MARKER
        ELSE
          UPPER = MARKER
        END IF
      END DO
      DATA%SWITCH_POINT = MARKER
    END IF
    IHSZ = -1
    IF(ASSOCIATED(DATA%IHEAP)) IHSZ = SIZE(DATA%IHEAP)
    IF (IHSZ<HEAP_SIZE+DATA%SIZE_X+DATA%REAL_STRUCT_SIZE) THEN
      IF (IHSZ>0) DEALLOCATE (DATA%IHEAP)
      IHSZ = HEAP_SIZE + DATA%SIZE_X + DATA%REAL_STRUCT_SIZE
      ALLOCATE (DATA%IHEAP(IHSZ),STAT=STAT)
      IF (STAT/=0) THEN
         ERROR = 3
        RETURN
      END IF
    END IF
      DATA%IHEAP(1:DATA%SIZE_X) = (/ (I,I=1,DATA%SIZE_X) /)
      IF (DATA%SWITCH_POINT>0) THEN
        DATA%IHTOS = DATA%REAL_STRUCT_SIZE + DATA%SIZE_X + 1
        DATA%IHEAP(DATA%SIZE_X+1:DATA%IHTOS-1) = 0
      ELSE
        DATA%IHTOS = DATA%SIZE_X + 1
      END IF
    IF (DATA%SWITCH_POINT>0) THEN
      DO I = 1, DATA%SIZE_X
        CALL GETMEM(1,1+DEGREE,X(I))
        X(I)%CASE = DATA%CASE
        DATA%IHEAP(DATA%IPONT(X(I)%P)) = I
        DATA%RHEAP(DATA%RPTR(X(I)%P)) = VALUE(I)
        DATA%RHEAP(DATA%RPTR(X(I)%P)+1) = 1.0_WP
        DATA%RHEAP(DATA%RPTR(X(I)%P)+2:DATA%RPTR(X(I)%P)+DEGREE) = 0.0_WP
      END DO
    ELSE
      DO I = 1, DATA%SIZE_X
        CALL GETMEM(0,DATA%REAL_STRUCT_SIZE,X(I))
        X(I)%CASE = DATA%CASE
        DATA%RHEAP(DATA%RPTR(X(I)%P)) = VALUE(I)
        IF (DEGREE>0) THEN
          DATA%RHEAP(DATA%RPTR(X(I)%P)+1:&
             DATA%RPTR(X(I)%P)+DATA%REAL_STRUCT_SIZE-1) = 0.0_WP
          DATA%RHEAP(DATA%RPTR(X(I)%P)+I) = 1.0_WP
        END IF
      END DO
    END IF
  END SUBROUTINE INITIALIZE_11
  SUBROUTINE INITIALIZE_10(DEGREE,X,VALUE,DATA,ERROR,FULL_THRESHOLD)
    INTEGER, INTENT (IN) :: DEGREE
    TYPE (AD02_REAL), INTENT (OUT) :: X(:)
    REAL (WP), INTENT (IN) :: VALUE
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: FULL_THRESHOLD
    REAL (WP), DIMENSION (SIZE(X)) :: VAL
    VAL = VALUE
    CALL INITIALIZE_11(DEGREE,X,VAL,DATA,ERROR,FULL_THRESHOLD)
  END SUBROUTINE INITIALIZE_10
  SUBROUTINE INITIALIZE_0(DEGREE,X,VALUE,DATA,ERROR,FULL_THRESHOLD)
    INTEGER, INTENT (IN) :: DEGREE
    TYPE (AD02_REAL), INTENT (OUT) :: X
    REAL (WP), INTENT (IN) :: VALUE
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: FULL_THRESHOLD
    REAL (WP) VAL(1)
    TYPE (AD02_REAL) :: A1(1)
    VAL(1) = VALUE
    CALL INITIALIZE_11(DEGREE,A1,VAL,DATA,ERROR,FULL_THRESHOLD)
    X%P = A1(1) %P
    IF(ASSOCIATED(DATA)) X%CASE = DATA%CASE
    X%DATA => DATA
  END SUBROUTINE INITIALIZE_0
  INTEGER FUNCTION IRPOS(MI,N,DATA)
    INTEGER, INTENT (IN) :: N
    INTEGER, INTENT (IN) :: MI(0:)
    TYPE(AD02_DATA) :: DATA
    INTEGER I, P, LAMBDA
    LAMBDA = MI(0)
    IF (LAMBDA>0) THEN
      P = DATA%IBINCO(LAMBDA-1+N,LAMBDA-1)
    ELSE
      P = 0
    END IF
    DO I = 1, LAMBDA
      P = P + DATA%IBINCO(I+MI(I)-2,I)
    END DO
    IRPOS = P
  END FUNCTION IRPOS
  INTEGER FUNCTION IRPOS2(MI,N,IREF1,DATA)
    INTEGER, INTENT (IN) :: N
    INTEGER, INTENT (IN) :: MI(0:),IREF1(*)
    TYPE(AD02_DATA) :: DATA
    INTEGER I, P, LAMBDA
    LAMBDA = MI(0)
    IF (LAMBDA>0) THEN
      P = DATA%IBINCO(LAMBDA-1+N,LAMBDA-1)
    ELSE
      P = 0
    END IF
    DO I = 1, LAMBDA
      P = P + DATA%IBINCO(I+IREF1(MI(I))-2,I)
    END DO
    IRPOS2 = P
  END FUNCTION IRPOS2
  SUBROUTINE MAKE_TEMP(A)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    A%CASE = -ABS(A%CASE)
  END SUBROUTINE MAKE_TEMP
  SUBROUTINE MERGE(I1,I2,N1,N2,DATA,LVARS,IREF1,IREF2)
    INTEGER, INTENT (IN) :: I1, I2, N1, N2
    TYPE(AD02_DATA) :: DATA
    INTEGER :: LVARS(0:*),IREF1(*),IREF2(*)
    INTEGER POINTER1, POINTER2, LVARS_POINTER
    INTEGER END_INDEX1, END_INDEX2, I
    END_INDEX1 = I1 + N1 - 1
    END_INDEX2 = I2 + N2 - 1
    POINTER1 = I1
    POINTER2 = I2
    LVARS_POINTER = 1
    IF (POINTER1>END_INDEX1) THEN
      LVARS(0) = LVARS_POINTER + END_INDEX2 - POINTER2
      LVARS(LVARS_POINTER:LVARS_POINTER+END_INDEX2-POINTER2) &
        = DATA%IHEAP(POINTER2:END_INDEX2)
      IREF2(POINTER2-I2+1:END_INDEX2-I2+1) = (/ (I,I=LVARS_POINTER, &
        LVARS_POINTER+END_INDEX2-POINTER2) /)
      RETURN
    END IF
    IF (POINTER2>END_INDEX2) THEN
      LVARS(0) = LVARS_POINTER + END_INDEX1 - POINTER1
      LVARS(LVARS_POINTER:LVARS_POINTER+END_INDEX1-POINTER1) &
        = DATA%IHEAP(POINTER1:END_INDEX1)
      IREF1(POINTER1-I1+1:END_INDEX1-I1+1) = (/ (I,I=LVARS_POINTER, &
        LVARS_POINTER+END_INDEX1-POINTER1) /)
      RETURN
    END IF
    DO
      IF (DATA%IHEAP(POINTER1)==DATA%IHEAP(POINTER2)) THEN
        IREF1(POINTER1-I1+1) = LVARS_POINTER
        IREF2(POINTER2-I2+1) = LVARS_POINTER
        LVARS(LVARS_POINTER) = DATA%IHEAP(POINTER1)
        LVARS_POINTER = LVARS_POINTER + 1
        POINTER1 = POINTER1 + 1
        POINTER2 = POINTER2 + 1
        IF (POINTER1>END_INDEX1) THEN
          LVARS(0) = LVARS_POINTER + END_INDEX2 - POINTER2
          LVARS(LVARS_POINTER:LVARS_POINTER+END_INDEX2-POINTER2) &
            = DATA%IHEAP(POINTER2:END_INDEX2)
          IREF2(POINTER2-I2+1:END_INDEX2-I2+1) = (/ (I,I=LVARS_POINTER, &
            LVARS_POINTER+END_INDEX2-POINTER2) /)
          EXIT
        END IF
        IF (POINTER2>END_INDEX2) THEN
          LVARS(0) = LVARS_POINTER + END_INDEX1 - POINTER1
          LVARS(LVARS_POINTER:LVARS_POINTER+END_INDEX1-POINTER1) &
            = DATA%IHEAP(POINTER1:END_INDEX1)
          IREF1(POINTER1-I1+1:END_INDEX1-I1+1) = (/ (I,I=LVARS_POINTER, &
            LVARS_POINTER+END_INDEX1-POINTER1) /)
          EXIT
        END IF
      ELSE IF (DATA%IHEAP(POINTER1)>DATA%IHEAP(POINTER2)) THEN
        IREF2(POINTER2-I2+1) = LVARS_POINTER
        LVARS(LVARS_POINTER) = DATA%IHEAP(POINTER2)
        LVARS_POINTER = LVARS_POINTER + 1
        POINTER2 = POINTER2 + 1
        IF (POINTER2>END_INDEX2) THEN
          LVARS(0) = LVARS_POINTER + END_INDEX1 - POINTER1
          LVARS(LVARS_POINTER:LVARS_POINTER+END_INDEX1-POINTER1) &
            = DATA%IHEAP(POINTER1:END_INDEX1)
          IREF1(POINTER1-I1+1:END_INDEX1-I1+1) = (/ (I,I=LVARS_POINTER, &
            LVARS_POINTER+END_INDEX1-POINTER1) /)
          EXIT
        END IF
      ELSE
        IREF1(POINTER1-I1+1) = LVARS_POINTER
        LVARS(LVARS_POINTER) = DATA%IHEAP(POINTER1)
        LVARS_POINTER = LVARS_POINTER + 1
        POINTER1 = POINTER1 + 1
        IF (POINTER1>END_INDEX1) THEN
          LVARS(0) = LVARS_POINTER + END_INDEX2 - POINTER2
          LVARS(LVARS_POINTER:LVARS_POINTER+END_INDEX2-POINTER2) &
            = DATA%IHEAP(POINTER2:END_INDEX2)
          IREF2(POINTER2-I2+1:END_INDEX2-I2+1) = (/ (I,I=LVARS_POINTER, &
            LVARS_POINTER+END_INDEX2-POINTER2) /)
          EXIT
        END IF
      END IF
    END DO
  END SUBROUTINE MERGE
  SUBROUTINE MIINC(LEVEL,MI,N)
    INTEGER, INTENT (IN) :: LEVEL, N
    INTEGER, INTENT (INOUT) :: MI(0:LEVEL+1)
    INTEGER I, LAMBDA
    LAMBDA = MI(0)
    IF (LAMBDA==LEVEL+1) RETURN
    IF (N==0) RETURN
    IF (LAMBDA==2) THEN
      IF (MI(1)<MI(2)) THEN
        MI(1) = MI(1) + 1
        RETURN
      END IF
      MI(1) = 1
      IF (MI(2)==N) THEN
        MI(2) = 1
        MI(3) = 1
        MI(0) = 3
        RETURN
      END IF
      MI(2) = MI(2) + 1
      RETURN
    END IF
    IF (LAMBDA==1) THEN
      IF (MI(1)==N) THEN
        MI(0) = 2
        MI(1) = 1
        MI(2) = 1
        RETURN
      END IF
      MI(1) = MI(1) + 1
      RETURN
    END IF
    IF (LAMBDA==0) THEN
      MI(0) = 1
      MI(1) = 1
      RETURN
    END IF
    IF (MI(1)==N) THEN
      MI(0) = LAMBDA + 1
      DO I = 1, MI(0)
        MI(I) = 1
      END DO
      RETURN
    END IF
    I = 1
    DO
      IF (I>LAMBDA-1) EXIT
      IF (MI(I)<MI(I+1)) THEN
        MI(I) = MI(I) + 1
        RETURN
      END IF
      MI(I) = 1
      I = I + 1
    END DO
    MI(I) = MI(I) + 1
  END SUBROUTINE MIINC
  SUBROUTINE MIMERU(MI1,MI2,MI3)
    INTEGER, INTENT (IN) :: MI1(1:), MI2(1:)
    INTEGER, INTENT (OUT) :: MI3(0:)
    INTEGER I1, I2, I3, K, N1, N2
    N1 = SIZE(MI1)
    N2 = SIZE(MI2)
    MI3(0) = N1 + N2
    I1 = 1
    I2 = 1
    I3 = 0
    IF (N1/=0 .AND. N2/=0) THEN
      DO
        IF (MI1(I1)<MI2(I2)) THEN
          I3 = I3 + 1
          MI3(I3) = MI1(I1)
          I1 = I1 + 1
          N1 = N1 - 1
          IF (N1==0) EXIT
        ELSE
          I3 = I3 + 1
          MI3(I3) = MI2(I2)
          I2 = I2 + 1
          N2 = N2 - 1
          IF (N2==0) EXIT
        END IF
      END DO
    END IF
    IF (N1>0) THEN
      DO K = 0, N1 - 1
        MI3(I3+K+1) = MI1(I1+K)
      END DO
    ELSE IF (N2>0) THEN
      DO K = 0, N2 - 1
        MI3(I3+K+1) = MI2(I2+K)
      END DO
    END IF
  END SUBROUTINE MIMERU
    SUBROUTINE MORE_MEMORY(DATA)
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, POINTER :: ITEMP1(:), ITEMP3(:), ITEMP4(:), ITEMP5(:)
    INTEGER STAT
    INTEGER :: IPSZ
    IPSZ = DATA%IPTOS*2
    ALLOCATE (ITEMP1(IPSZ),ITEMP3(IPSZ),ITEMP4(IPSZ),ITEMP5(IPSZ),STAT=STAT)
    IF (STAT/=0) THEN
      CALL ERROR_HANDLER(DATA,ALLOC_ERR)
      RETURN
    END IF
    ITEMP1(1:DATA%IPTOS-1) = DATA%IPONT(1:DATA%IPTOS-1)
    ITEMP3(1:DATA%IPTOS-1) = DATA%RPTR (1:DATA%IPTOS-1)
    ITEMP4(1:DATA%IPTOS-1) = DATA%RLENG(1:DATA%IPTOS-1)
    ITEMP5(1:DATA%IPTOS-1) = DATA%NVARS(1:DATA%IPTOS-1)
    DEALLOCATE (DATA%IPONT,DATA%RPTR,DATA%RLENG,DATA%NVARS)
    DATA%IPONT => ITEMP1
    DATA%RPTR  => ITEMP3
    DATA%RLENG => ITEMP4
    DATA%NVARS => ITEMP5
  END SUBROUTINE MORE_MEMORY
  SUBROUTINE MULT(A,B,C)
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE (AD02_REAL), INTENT (OUT) :: C
    INTEGER I, IR, I1, I2, L1, L2, N(3), P(3), PR, J, INDEX
    INTEGER INDEX_A, INDEX_B, INDEX_C, LEVEL
    REAL (WP) V1
    TYPE(AD02_DATA), POINTER :: DATA
    INTEGER, ALLOCATABLE :: LVARS(:)
    INTEGER, ALLOCATABLE :: IREF1(:)
    INTEGER, ALLOCATABLE :: IREF2(:)
    INTEGER, ALLOCATABLE :: MI(:,:)
    INTEGER, ALLOCATABLE :: INV_IREF1(:),INV_IREF2(:)
    LOGICAL, ALLOCATABLE :: A_PRES(:), B_PRES(:)
    DATA => A%DATA
    C%DATA => DATA
    LEVEL = DATA%LEVEL
    N(1) = DATA%NVARS(A%P)
    N(2) = DATA%NVARS(B%P)
    IF ((N(1)==DATA%SIZE_X) .AND. (N(2)==DATA%SIZE_X)) THEN
      CALL GETMEM(0,DATA%REAL_STRUCT_SIZE,C)
      SELECT CASE (LEVEL)
      CASE (0)
        DATA%RHEAP(DATA%RPTR(C%P)) =  &
            DATA%RHEAP(DATA%RPTR(A%P))*DATA%RHEAP(DATA%RPTR(B%P))
      CASE (1)
        INDEX_A = DATA%RPTR(A%P)
        INDEX_B = DATA%RPTR(B%P)
        INDEX_C = DATA%RPTR(C%P)
        DATA%RHEAP(INDEX_C) = DATA%RHEAP(INDEX_A)*DATA%RHEAP(INDEX_B)
        DO I = 1, DATA%SIZE_X
        DATA%RHEAP(INDEX_C+I) = DATA%RHEAP(INDEX_A)* &
          DATA%RHEAP(INDEX_B+I) + DATA%RHEAP(INDEX_B)*DATA%RHEAP(INDEX_A+I)
        END DO
      CASE (2)
        DATA%RHEAP(DATA%RPTR(C%P)) = &
          DATA%RHEAP(DATA%RPTR(A%P))*DATA%RHEAP(DATA%RPTR(B%P))
        DATA%RHEAP(DATA%RPTR(C%P)+1:DATA%RPTR(C%P)+DATA%SIZE_X) = &
          DATA%RHEAP(DATA%RPTR(B%P))* &
          DATA%RHEAP(DATA%RPTR(A%P)+1:DATA%RPTR(A%P)+DATA%SIZE_X) + &
          DATA%RHEAP(DATA%RPTR(A%P))*DATA%RHEAP(DATA%RPTR(B% &
          P)+1:DATA%RPTR(B%P)+DATA%SIZE_X)
        INDEX = 1 + DATA%SIZE_X
        DO I = 1, DATA%SIZE_X
          DO J = 1, I - 1
            DATA%RHEAP(DATA%RPTR(C%P)+INDEX) = &
              DATA%RHEAP(DATA%RPTR(B%P))*DATA%RHEAP(DATA%RPTR(A%P)+INDEX) + &
              DATA%RHEAP(DATA%RPTR(A%P))*DATA%RHEAP(DATA%RPTR(B%P)+INDEX) + &
              (DATA%RHEAP(DATA%RPTR(A%P)+I)*DATA%RHEAP(DATA%RPTR(B%P)+J)+&
              DATA%RHEAP(DATA%RPTR(A%P)+J)*DATA%RHEAP(DATA%RPTR(B%P)+I))
            INDEX = INDEX + 1
          END DO
          DATA%RHEAP(DATA%RPTR(C%P)+INDEX) = &
            DATA%RHEAP(DATA%RPTR(A%P)+INDEX)*DATA%RHEAP(DATA%RPTR(B%P)) + &
            DATA%RHEAP(DATA%RPTR(B%P)+INDEX)*DATA%RHEAP(DATA%RPTR(A%P)) + &
            DATA%RHEAP(DATA%RPTR(B%P)+I)*DATA%RHEAP(DATA%RPTR(A%P)+I)
          INDEX = INDEX + 1
        END DO
      CASE DEFAULT
        ALLOCATE(MI(0:DATA%LEVEL+1,4))
        P(1) = DATA%RPTR(A%P)
        P(2) = DATA%RPTR(B%P)
        P(3) = DATA%RPTR(C%P)
        DATA%RHEAP(P(3):P(3)+DATA%REAL_STRUCT_SIZE-1) = 0.0_WP
        MI(0,1) = 0
        DO L1 = 0, DATA%REAL_STRUCT_SIZE - 1
          V1 = DATA%RHEAP(P(1)+L1)
          MI(0,2) = 0
          DO L2 = 0, DATA%REAL_STRUCT_SIZE - 1
            IF (MI(0,1)+MI(0,2)>LEVEL) EXIT
            CALL MIMERU(MI(1:MI(0,1),1),MI(1:MI(0,2),2),MI(0:LEVEL+1,3))
            PR = IRPOS(MI(0:LEVEL+1,3),DATA%SIZE_X,DATA) + P(3)
            DATA%RHEAP(PR) = DATA%RHEAP(PR) + V1*DATA%RHEAP(P(2)+L2)
            CALL MIINC(LEVEL,MI(0:LEVEL+1,2),DATA%SIZE_X)
          END DO
          CALL MIINC(LEVEL,MI(0:LEVEL+1,1),DATA%SIZE_X)
        END DO
      END SELECT
    ELSE
      ALLOCATE(LVARS(0:DATA%SIZE_X),IREF1(DATA%SIZE_X),IREF2(DATA%SIZE_X))
      I1 = DATA%IPONT(A%P)
      I2 = DATA%IPONT(B%P)
      CALL MERGE(I1,I2,N(1),N(2),A%DATA,LVARS,IREF1,IREF2)
      N(3) = LVARS(0)
      CALL GETMEM(N(3),DATA%IBINCO(LEVEL+N(3),LEVEL),C)
      IR = DATA%IPONT(C%P)
      DO I = 0, N(3) - 1
        DATA%IHEAP(IR+I) = LVARS(I+1)
      END DO
      P(1) = DATA%RPTR(A%P)
      P(2) = DATA%RPTR(B%P)
      P(3) = DATA%RPTR(C%P)
      DO I = 0, DATA%RLENG(C%P) - 1
        DATA%RHEAP(P(3)+I) = 0.0_WP
      END DO
      SELECT CASE (LEVEL)
      CASE (0)
        DATA%RHEAP(P(3)) = DATA%RHEAP(P(1))*DATA%RHEAP(P(2))
      CASE (1)
        DATA%RHEAP(P(3)) = DATA%RHEAP(P(1))*DATA%RHEAP(P(2))
        DO I = 1, N(1)
          DATA%RHEAP(P(3)+IREF1(I)) = DATA%RHEAP(P(2))*DATA%RHEAP(P(1)+I)
        END DO
        DO I = 1, N(2)
          DATA%RHEAP(P(3)+IREF2(I)) = DATA%RHEAP(P(3)+IREF2(I)) + &
            DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+I)
        END DO
      CASE (2)
      ALLOCATE (INV_IREF1(DATA%SIZE_X),INV_IREF2(DATA%SIZE_X),&
         A_PRES(DATA%SIZE_X),B_PRES(DATA%SIZE_X))
        A_PRES = .FALSE.
        DO I = 1, N(1)
          A_PRES(IREF1(I)) = .TRUE.
          INV_IREF1(IREF1(I)) = I
        END DO
        B_PRES = .FALSE.
        DO I = 1, N(2)
          B_PRES(IREF2(I)) = .TRUE.
          INV_IREF2(IREF2(I)) = I
        END DO
        DATA%RHEAP(P(3)) = DATA%RHEAP(P(1))*DATA%RHEAP(P(2))
        DO I = 1, N(1)
          DATA%RHEAP(P(3)+IREF1(I)) = DATA%RHEAP(P(2))*DATA%RHEAP(P(1)+I)
        END DO
        DO I = 1, N(2)
          DATA%RHEAP(P(3)+IREF2(I)) = DATA%RHEAP(P(3)+IREF2(I)) + &
            DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+I)
        END DO
        INDEX_A = 1 + N(1)
        INDEX_B = 1 + N(2)
        INDEX_C = 1 + N(3)
        DO I = 1, N(3)
          DO J = 1, I - 1
            DATA%RHEAP(P(3)+INDEX_C) = 0.0_WP
            IF ((A_PRES(I)) .AND. (A_PRES(J))) THEN
              DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                DATA%RHEAP(P(2))*DATA%RHEAP(P(1)+INDEX_A)
              IF (B_PRES(I)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                  DATA%RHEAP(P(1)+INV_IREF1(J))*DATA%RHEAP(P(2)+INV_IREF2(I))
                IF (B_PRES(J)) THEN
                  DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                    DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+INDEX_B) + &
                    DATA%RHEAP(P(1)+INV_IREF1(I))*DATA%RHEAP(P(2)+INV_IREF2(J))
                  INDEX_B = INDEX_B + 1
                END IF
              ELSE IF (B_PRES(J)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                  DATA%RHEAP(P(1)+INV_IREF1(I))*DATA%RHEAP(P(2)+INV_IREF2(J))
              END IF
              INDEX_A = INDEX_A + 1
            ELSE
              IF (A_PRES(I)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                  DATA%RHEAP(P(1)+INV_IREF1(I))*DATA%RHEAP(P(2)+INV_IREF2(J))
                IF (B_PRES(I)) THEN
                  DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                    DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+INDEX_B)
                  INDEX_B = INDEX_B + 1
                END IF
              ELSE IF (A_PRES(J)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                  DATA%RHEAP(P(1)+INV_IREF1(J))*DATA%RHEAP(P(2)+INV_IREF2(I))
                IF (B_PRES(J)) THEN
                  DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                    DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+INDEX_B)
                  INDEX_B = INDEX_B + 1
                END IF
              ELSE
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                  DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+INDEX_B)
                INDEX_B = INDEX_B + 1
              END IF
            END IF
            INDEX_C = INDEX_C + 1
          END DO
          IF (A_PRES(I)) THEN
            IF (B_PRES(I)) THEN
              DATA%RHEAP(P(3)+INDEX_C) = &
                DATA%RHEAP(P(1)+INDEX_A)*DATA%RHEAP(P(2)) + &
                DATA%RHEAP(P(2)+INDEX_B)*DATA%RHEAP(P(1)) + &
                DATA%RHEAP(P(1)+INV_IREF1(I))* &
                DATA%RHEAP(P(2)+INV_IREF2(I))
              INDEX_A = INDEX_A + 1
              INDEX_B = INDEX_B + 1
              INDEX_C = INDEX_C + 1
            ELSE
              DATA%RHEAP(P(3)+INDEX_C) = &
                  DATA%RHEAP(P(1)+INDEX_A)*DATA%RHEAP(P(2))
              INDEX_A = INDEX_A + 1
              INDEX_C = INDEX_C + 1
            END IF
          ELSE
            DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(2)+INDEX_B)*DATA%RHEAP(P(1))
            INDEX_B = INDEX_B + 1
            INDEX_C = INDEX_C + 1
          END IF
        END DO
        DEALLOCATE (INV_IREF1,INV_IREF2,A_PRES,B_PRES)
      CASE DEFAULT
        ALLOCATE(MI(0:LEVEL+1,4))
        MI(0,1) = 0
        DO L1 = 0, DATA%RLENG(A%P) - 1
          V1 = DATA%RHEAP(P(1)+L1)
          MI(0,2) = 0
          DO L2 = 0, DATA%RLENG(B%P) - 1
            IF (MI(0,1)+MI(0,2)>LEVEL) EXIT
            CALL MIMERU &
               (IREF1(MI(1:MI(0,1),1)),IREF2(MI(1:MI(0,2),2)),MI(0:LEVEL+1,3))
            PR = IRPOS(MI(0:LEVEL+1,3),N(3),DATA) + P(3)
            DATA%RHEAP(PR) = DATA%RHEAP(PR) + V1*DATA%RHEAP(P(2)+L2)
            CALL MIINC(LEVEL,MI(0:LEVEL+1,2),N(2))
          END DO
          CALL MIINC(LEVEL,MI(0:LEVEL+1,1),N(1))
        END DO
      END SELECT
      IF ((DATA%NVARS(C%P)>=DATA%SWITCH_POINT) .AND. &
        (DATA%NVARS(C%P)/=DATA%SIZE_X))  CALL SPARSE_TO_FULL(C)
      DEALLOCATE(LVARS,IREF1,IREF2)
    END IF
    CALL USED(A)
    CALL USED(B)
  END SUBROUTINE MULT
  SUBROUTINE PACCNT(V,OUT)
    REAL (WP), INTENT (IN) :: V
    TYPE (AD02_REAL), INTENT (INOUT) :: OUT
    TYPE(AD02_DATA), POINTER :: DATA
    INTEGER :: MORE
    DATA => OUT%DATA
    MORE = 1
    IF (DATA%SWITCH_POINT<=0) MORE = DATA%REAL_STRUCT_SIZE
    IF (MORE+DATA%IRTOS>SIZE(DATA%RHEAP)) THEN
      CALL GC(0,MORE,DATA)
      IF (DATA%CASE==0) RETURN
    END IF
    IF (DATA%DEAD_POINTER==-1) THEN
      IF (DATA%IPTOS>SIZE(DATA%IPONT)) CALL MORE_MEMORY(DATA)
      OUT%P = DATA%IPTOS
      DATA%IPTOS = DATA%IPTOS + 1
    ELSE
      OUT%P = DATA%DEAD_POINTER
      DATA%DEAD_POINTER = DATA%IPONT(DATA%DEAD_POINTER)
    END IF
    OUT%CASE = -DATA%CASE
    DATA%RPTR(OUT%P) = DATA%IRTOS
    DATA%IRTOS = DATA%IRTOS + MORE
    DATA%RLENG(OUT%P) = MORE
    IF (DATA%SWITCH_POINT>0) THEN
      DATA%NVARS(OUT%P) = 0
      DATA%IPONT(OUT%P) = 0
      DATA%RHEAP(DATA%RPTR(OUT%P)) = V
    ELSE
      DATA%NVARS(OUT%P) = DATA%SIZE_X
      DATA%IPONT(OUT%P) = 1
      DATA%RHEAP(DATA%RPTR(OUT%P)) = V
      DATA%RHEAP(DATA%RPTR(OUT%P)+1:DATA%RPTR(OUT%P)+MORE-1) = 0.0_WP
    END IF
  END SUBROUTINE PACCNT
  SUBROUTINE SPARSE_TO_FULL(INPUT)
    TYPE (AD02_REAL), INTENT (IN) :: INPUT
    INTEGER OLD_RPTR
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => INPUT%DATA
    IF (DATA%REAL_STRUCT_SIZE+DATA%IRTOS>SIZE(DATA%RHEAP)) THEN
      CALL GC(0,DATA%REAL_STRUCT_SIZE,DATA)
      IF (DATA%CASE==0) RETURN
    END IF
    OLD_RPTR = DATA%RPTR(INPUT%P)
    DATA%RPTR(INPUT%P) = DATA%IRTOS
    DATA%RHEAP(DATA%IRTOS+1:DATA%IRTOS+DATA%REAL_STRUCT_SIZE-1) = 0.0_WP
    CALL EXPAND(DATA%IHEAP( &
        DATA%IPONT(INPUT%P):DATA%IPONT(INPUT%P)+DATA%NVARS(INPUT%P)-1),&
        DATA%SIZE_X, DATA)
    DATA%RHEAP(DATA%IHEAP(DATA%SIZE_X+1:DATA%SIZE_X+DATA%RLENG(INPUT%P))+&
      DATA%IRTOS) = DATA%RHEAP(OLD_RPTR:OLD_RPTR+DATA%RLENG(INPUT%P)-1)
    DATA%RLENG(INPUT%P) = DATA%REAL_STRUCT_SIZE
    DATA%IRTOS = DATA%IRTOS + DATA%REAL_STRUCT_SIZE
    DATA%NVARS(INPUT%P) = DATA%SIZE_X
    DATA%IPONT(INPUT%P) = 1
  END SUBROUTINE SPARSE_TO_FULL
  SUBROUTINE UNARY(A,B,DERF)
    TYPE (AD02_REAL), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (OUT) :: B
    REAL (WP) :: DERF(0:*)
    INTEGER I, J, INDEX,LEVEL, NV, RECLEV, PR, PG, IG, IH, P(2), NOSAME
    REAL (WP) FACT
    TYPE(AD02_DATA), POINTER :: DATA
    INTEGER, ALLOCATABLE :: MI(:,:)
    REAL (WP), ALLOCATABLE :: RS(:)
    INTEGER, ALLOCATABLE :: IS(:)
    DATA => A%DATA
    B%DATA => DATA
    LEVEL = DATA%LEVEL
    NV = DATA%NVARS(A%P)
    IF ((A%CASE<0) .AND. (LEVEL<3)) THEN
      P(1) = DATA%RPTR(A%P)
      P(2) = P(1)
      B%P = A%P
      B%DATA => DATA
      B%CASE = A%CASE
    ELSE
      IF (NV/=DATA%SIZE_X) THEN
        CALL GETMEM(DATA%NVARS(A%P),DATA%RLENG(A%P),B)
        IG = DATA%IPONT(A%P)
        IH = DATA%IPONT(B%P)
        DATA%NVARS(B%P) = NV
        DO I = 1,NV
           DATA%IHEAP(IH+I-1) = DATA%IHEAP(IG+I-1)
        END DO
      ELSE
        CALL GETMEM(0,DATA%RLENG(A%P),B)
      END IF
      P(1) = DATA%RPTR(A%P)
      P(2) = DATA%RPTR(B%P)
    END IF
    SELECT CASE (LEVEL)
    CASE (0)
      DATA%RHEAP(P(2)) = DERF(0)
    CASE (1)
      DO I = 1,NV
         DATA%RHEAP(P(2)+I) = DATA%RHEAP(P(1)+I)*DERF(1)
      END DO
      DATA%RHEAP(P(2)) = DERF(0)
    CASE (2)
      INDEX = NV
      DO I = 1, NV
        DO J = 1, I - 1
          INDEX = INDEX + 1
          DATA%RHEAP(P(2)+INDEX) = DERF(2)*DATA%RHEAP(P(1)+I)*DATA%RHEAP(P(1)+J)
            DERF(1)*DATA%RHEAP(P(1)+INDEX)
        END DO
        INDEX = INDEX + 1
        DATA%RHEAP(P(2)+INDEX) = 0.5_WP*DERF(2)*DATA%RHEAP(P(1)+I)**2 + &
          DERF(1)*DATA%RHEAP(P(1)+INDEX)
      END DO
      DO I = 1,NV
         DATA%RHEAP(P(2)+I) = DATA%RHEAP(P(1)+I)*DERF(1)
      END DO
      DATA%RHEAP(P(2)) = DERF(0)
    CASE DEFAULT
      ALLOCATE(MI(0:LEVEL+1,4),IS((LEVEL+1)*(2*LEVEL*5)),RS(LEVEL+1))
      DATA%RHEAP(P(2)) = DERF(0)
      IF (NV/=0) THEN
        DO I = 1, DATA%RLENG(B%P) - 1
          DATA%RHEAP(P(2)+I) = 0.0_WP
        END DO
        RECLEV = 1
        MI = 0
        MI(0,2) = 1
        MI(1,2) = 1
        PG = 1
        NOSAME = 1
        FACT = 1.0_WP
        DO
          DO
            IF (MI(0,1)+MI(0,2)<=LEVEL) THEN
              CALL MIMERU(MI(1:MI(0,1),1),MI(1:MI(0,2),2),MI(0:LEVEL+1,3))
              CALL UPUSH(LEVEL,MI(0:LEVEL+1,1),MI(0:LEVEL+1,2),&
                   PG,FACT,RECLEV,IS,RS)
              FACT = FACT*DATA%RHEAP(P(1)+PG)/NOSAME
              PR = IRPOS(MI(0:LEVEL+1,3),NV,DATA) + P(2)
              DATA%RHEAP(PR) = DATA%RHEAP(PR) + FACT*DERF(RECLEV)
              DO I = 0, MI(0,3)
                MI(I,1) = MI(I,3)
              END DO
              RECLEV = RECLEV + 1
              NOSAME = NOSAME + 1
            ELSE
              EXIT
            END IF
          END DO
          RECLEV = RECLEV - 1
          CALL UPOP(LEVEL,MI(0:LEVEL+1,1),MI(0:LEVEL+1,2),PG,FACT,RECLEV,IS,RS)
          NOSAME = 1
          CALL MIINC(LEVEL,MI(0:LEVEL+1,2),NV)
          PG = PG + 1
          IF (MI(0,2)>LEVEL) EXIT
        END DO
      END IF
      CALL USED(A)
      DEALLOCATE(MI,IS,RS)
    END SELECT
  END SUBROUTINE UNARY
  SUBROUTINE UNARY_WARNING(FUN,A,PROC)
    TYPE (AD02_REAL), INTENT (OUT) :: FUN
    TYPE (AD02_REAL), INTENT (IN) :: A
    CHARACTER(*), OPTIONAL, INTENT(IN) :: PROC
    CALL ERROR_HANDLER(A%DATA,UNDEF_WARN,PROC)
    FUN%DATA => A%DATA
  END SUBROUTINE UNARY_WARNING
  LOGICAL FUNCTION UNDEFINED(X)
    TYPE (AD02_REAL), INTENT (IN) :: X
    IF(ASSOCIATED(X%DATA))THEN
      UNDEFINED = X%DATA%CASE==-1
    ELSE
      UNDEFINED = .TRUE.
    END IF
  END FUNCTION UNDEFINED
  SUBROUTINE UNDEFINE_REAL0(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    IF(PRESENT(DATA))then
       F%DATA => DATA
       IF(ASSOCIATED(DATA)) F%CASE = DATA%CASE
    ELSE
       NULLIFY(F%DATA)
       F%CASE = 0
    END IF
    F%P = -1
  END SUBROUTINE UNDEFINE_REAL0
  SUBROUTINE UNDEFINE_REAL1(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F)
      CALL AD02_UNDEFINE(F(I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL1
  SUBROUTINE UNDEFINE_REAL2(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,2)
      CALL AD02_UNDEFINE(F(:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL2
  SUBROUTINE UNDEFINE_REAL3(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,3)
      CALL AD02_UNDEFINE(F(:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL3
  SUBROUTINE UNDEFINE_REAL4(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,4)
      CALL AD02_UNDEFINE(F(:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL4
  SUBROUTINE UNDEFINE_REAL5(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,5)
      CALL AD02_UNDEFINE(F(:,:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL5
  SUBROUTINE UNDEFINE_REAL6(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,6)
      CALL AD02_UNDEFINE(F(:,:,:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL6
  SUBROUTINE UNDEFINE_REAL7(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,7)
      CALL AD02_UNDEFINE(F(:,:,:,:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL7
  SUBROUTINE UPOP(LEVEL,MI1,MI2,PG,FACT,RECLEV,IS,RS)
    INTEGER, INTENT (IN) :: LEVEL
    INTEGER, INTENT (OUT) :: MI1(0:LEVEL+1), MI2(0:LEVEL+1), PG
    INTEGER, INTENT (IN) :: RECLEV
    REAL (WP), INTENT (OUT) :: FACT
    INTEGER, INTENT (INOUT) :: IS(*)
    REAL (WP), INTENT (INOUT) :: RS(*)
    INTEGER I, J, WHERE
    J = 2*(LEVEL+1)
    WHERE = (RECLEV-1)*(J+1) + 1
    FACT = RS(RECLEV)
    DO I = 0, LEVEL
      MI1(I) = IS(WHERE+I)
      MI2(I) = IS(WHERE+LEVEL+1+I)
    END DO
    PG = IS(WHERE+J)
  END SUBROUTINE UPOP
  SUBROUTINE UPOW(A,P,B)
    TYPE (AD02_REAL), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (INOUT) :: B
    REAL (WP), INTENT (IN) :: P
    INTEGER I,LEVEL
    REAL (WP) VG, D, T
    TYPE(AD02_DATA), POINTER :: DATA
    REAL (WP), ALLOCATABLE :: DERF(:)
    DATA => A%DATA
    ALLOCATE(DERF(0:DATA%LEVEL+4))
    LEVEL = DATA%LEVEL
    VG = DATA%RHEAP(DATA%RPTR(A%P))
    IF (VG==0.0_WP) THEN
      IF (P==ANINT(P)) THEN
        IF (NINT(P)>=0 .AND. NINT(P)<=LEVEL) THEN
          D = 1.0_WP
          DO I = 0, NINT(P) - 1
            D = D*(NINT(P)-I)
            DERF(I) = 0.0_WP
          END DO
          DERF(NINT(P)) = D
          DO I = NINT(P) + 1, LEVEL
            DERF(I) = 0.0_WP
          END DO
          CALL UNARY(A,B,DERF)
          RETURN
        END IF
      END IF
      DERF(0:LEVEL) = 0.0_WP
      CALL UNARY(A,B,DERF)
      RETURN
    END IF
    T = P
    IF (VG<0.0) THEN
      IF (P==ANINT(P)) THEN
        D = VG**INT(P)
      ELSE
        D = VG**P
      END IF
    ELSE
      D = VG**P
    END IF
    DERF(0) = D
    DO I = 1, LEVEL
      D = D*T/VG
      T = T - 1.0_WP
      DERF(I) = D
    END DO
    CALL UNARY(A,B,DERF)
    DEALLOCATE(DERF)
  END SUBROUTINE UPOW
  SUBROUTINE UPUSH(LEVEL,MI1,MI2,PG,FACT,RECLEV,IS,RS)
    INTEGER, INTENT (IN) :: LEVEL
    INTEGER, INTENT (IN) :: MI1(0:LEVEL+1), MI2(0:LEVEL+1), PG, RECLEV
    REAL (WP), INTENT (IN) :: FACT
    INTEGER, INTENT (INOUT) :: IS(*)
    REAL (WP), INTENT (INOUT) :: RS(*)
    INTEGER I, J, WHERE
    J = 2*(LEVEL+1)
    WHERE = (RECLEV-1)*(J+1) + 1
    RS(RECLEV) = FACT
    DO I = 0, LEVEL
      IS(WHERE+I) = MI1(I)
      IS(WHERE+LEVEL+1+I) = MI2(I)
    END DO
    IS(WHERE+J) = PG
  END SUBROUTINE UPUSH
  SUBROUTINE USED(A)
    TYPE (AD02_REAL) :: A
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%CASE<0) THEN
      DATA%IPONT(A%P) = DATA%DEAD_POINTER
      DATA%DEAD_POINTER = A%P
    END IF
  END SUBROUTINE USED
  SUBROUTINE USER(D,X,F,NAME)
    TYPE (AD02_REAL), INTENT (IN) :: X
    TYPE (AD02_REAL), INTENT (OUT) :: F
    REAL (WP), INTENT (IN) :: D(0:)
    CHARACTER (LEN=*), INTENT (IN), OPTIONAL :: NAME
    INTEGER I
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    IF (X%P==-1) THEN
      IF (PRESENT(NAME)) THEN
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,NAME)
      ELSE
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AD02_USER')
      END IF
      F%P = -1
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      IF (PRESENT(NAME)) THEN
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,NAME)
      ELSE
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AD02_USER')
      END IF
      F%P = -1
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      DO I = 0, DATA%LEVEL
        DERF(I) = D(I)
      END DO
      CALL UNARY(X,F,DERF)
      DEALLOCATE(DERF)
    END IF
  END SUBROUTINE USER
  SUBROUTINE VALUE_SCALAR(A,VALUE,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: VALUE
    INTEGER, INTENT (OUT) :: ERROR
    TYPE(AD02_DATA), POINTER :: DATA
    VALUE = 0.0_WP
    ERROR = 0
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    END IF
    IF(ERROR>0)RETURN
    DATA => A%DATA
    VALUE = DATA%RHEAP(DATA%RPTR(A%P))
  END SUBROUTINE VALUE_SCALAR
  SUBROUTINE VALUE_ARRAY(A,VALUE,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A(:)
    REAL (WP), INTENT (OUT) :: VALUE(:)
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER I,ERR
    ERROR = 0
    IF (SIZE(A)/=SIZE(VALUE)) ERROR = 5
    DO I = 1, MIN(SIZE(VALUE),SIZE(A))
       CALL VALUE_SCALAR(A(I),VALUE(I),ERR)
       IF(ERR>0)ERROR = ERR
    END DO
  END SUBROUTINE VALUE_ARRAY
END MODULE HSL_AD02_FORWARD_DOUBLE
MODULE HSL_AD02_BACKWARD_DOUBLE
  IMPLICIT NONE
  PRIVATE
  INTEGER, PARAMETER :: WP = KIND(0D0)
  REAL (WP), PARAMETER :: D0 = 0.0_WP, D1 = 1.0_WP, D2 = 2.0_WP
  INTEGER, PARAMETER :: INIT_MAX_NODES = 10000
  TYPE NODE
    REAL (WP) RVAL
    REAL (WP) RVALS(0:1)
    INTEGER ONUM
    INTEGER IPTRS(0:1)
  END TYPE NODE
  PUBLIC NODE
  REAL (WP) LN10
  INTEGER, PARAMETER :: INIT_ERR = 1
  INTEGER, PARAMETER :: NO_INIT_ERR = 2
  INTEGER, PARAMETER :: ALLOC_ERR = 3
  INTEGER, PARAMETER :: SQRT_ERR = 5
  INTEGER, PARAMETER :: POW1_ERR = 6
  INTEGER, PARAMETER :: POW2_ERR = 7
  INTEGER, PARAMETER :: SIGN_WARN = 8
  INTEGER, PARAMETER :: ABS_WARN = 9
  INTEGER, PARAMETER :: INT_WARN = 10
  INTEGER, PARAMETER :: AINT_WARN = 11
  INTEGER, PARAMETER :: NINT_WARN = 12
  INTEGER, PARAMETER :: ANINT_WARN = 13
  INTEGER, PARAMETER :: MAX_WARN = 14
  INTEGER, PARAMETER :: MIN_WARN = 15
  INTEGER, PARAMETER :: EQ_WARN = 16
  INTEGER, PARAMETER :: NE_WARN = 17
  INTEGER, PARAMETER :: GT_WARN = 18
  INTEGER, PARAMETER :: LT_WARN = 19
  INTEGER, PARAMETER :: GE_WARN = 20
  INTEGER, PARAMETER :: LE_WARN = 21
  INTEGER, PARAMETER :: UNDEF_WARN = 33
  INTEGER, PARAMETER :: ASSIGNMENT_WARN = 34
    INTEGER :: AD02_FLAG(40)=0
    INTEGER :: ERROR_MESSAGE_UNIT=6
    INTEGER :: WARNING_MESSAGE_UNIT=6
    INTEGER :: ERROR_PRINT_LEVEL=1
    INTEGER :: ERROR_STOP_LEVEL=1
  TYPE, PUBLIC :: AD02_DATA
!????    PRIVATE
    INTEGER :: LEVEL = -1
    INTEGER, POINTER :: FLAGS(:)=>NULL()
    INTEGER :: ERROR_MESSAGE_UNIT = 6
    INTEGER :: WARNING_MESSAGE_UNIT = 6
    INTEGER :: ERROR_PRINT_LEVEL = 1
    INTEGER :: ERROR_STOP_LEVEL = 1
    TYPE (NODE), POINTER :: GRAPH(:)=>NULL()
    REAL (WP), POINTER :: DER2(:,:)=>NULL()
    INTEGER :: MAX_NODES = 0
    INTEGER :: MAX_NODES2 = 0
    INTEGER NUM_NODES
    INTEGER SIZE_X
    INTEGER :: CASE = -1
    INTEGER :: MAX_CASE = 1
  END TYPE AD02_DATA
  TYPE, PUBLIC :: AD02_REAL
    PRIVATE
    INTEGER :: P = -1
    INTEGER :: CASE
    TYPE(AD02_DATA), POINTER :: DATA => NULL()
  END TYPE AD02_REAL
  INTERFACE OPERATOR (+)
    MODULE PROCEDURE ADD_DD, ADD_RD, ADD_DR, ADD_ID, ADD_DI
    MODULE PROCEDURE ADD_DS, ADD_SD
  END INTERFACE
  PUBLIC OPERATOR (+)
  INTERFACE OPERATOR (-)
    MODULE PROCEDURE MINUS_D, MINUS_DD, MINUS_RD, MINUS_DR
    MODULE PROCEDURE MINUS_ID, MINUS_DI
    MODULE PROCEDURE MINUS_DS, MINUS_SD
  END INTERFACE
  PUBLIC OPERATOR (-)
  INTERFACE OPERATOR (*)
    MODULE PROCEDURE MULT_DD, MULT_RD, MULT_DR, MULT_ID, MULT_DI
    MODULE PROCEDURE MULT_DS, MULT_SD
  END INTERFACE
  PUBLIC OPERATOR (*)
  INTERFACE OPERATOR (/)
    MODULE PROCEDURE DIV_DD, DIV_RD, DIV_DR, DIV_ID, DIV_DI
    MODULE PROCEDURE DIV_DS, DIV_SD
  END INTERFACE
  PUBLIC OPERATOR (/)
  INTERFACE OPERATOR (**)
    MODULE PROCEDURE POW_DD, POW_RD, POW_DR, POW_DI, POW_ID
    MODULE PROCEDURE POW_DS, POW_SD
  END INTERFACE
  PUBLIC OPERATOR (**)
  INTERFACE OPERATOR (==)
    MODULE PROCEDURE EQ_DD, EQ_RD, EQ_DR, EQ_ID, EQ_DI
    MODULE PROCEDURE EQ_DS, EQ_SD
  END INTERFACE
  PUBLIC OPERATOR (==)
  INTERFACE OPERATOR (<=)
    MODULE PROCEDURE LE_DD, LE_RD, LE_DR, LE_ID, LE_DI
    MODULE PROCEDURE LE_DS, LE_SD
  END INTERFACE
  PUBLIC OPERATOR (<=)
  INTERFACE OPERATOR (<)
    MODULE PROCEDURE LT_DD, LT_RD, LT_DR, LT_DI, LT_ID
    MODULE PROCEDURE LT_DS, LT_SD
  END INTERFACE
  PUBLIC OPERATOR (<)
  INTERFACE OPERATOR (>=)
    MODULE PROCEDURE GE_DD, GE_RD, GE_DR, GE_ID, GE_DI
    MODULE PROCEDURE GE_DS, GE_SD
  END INTERFACE
  PUBLIC OPERATOR (>=)
  INTERFACE OPERATOR (>)
    MODULE PROCEDURE GT_DD, GT_RD, GT_DR, GT_DI, GT_ID
    MODULE PROCEDURE GT_DS, GT_SD
  END INTERFACE
  PUBLIC OPERATOR (>)
  INTERFACE OPERATOR (/=)
    MODULE PROCEDURE NE_DD, NE_RD, NE_DR, NE_ID, NE_DI
    MODULE PROCEDURE NE_DS, NE_SD
  END INTERFACE
  PUBLIC OPERATOR (/=)
  INTERFACE ASSIGNMENT (=)
    MODULE PROCEDURE ASSIGN_DR, ASSIGN_DD, ASSIGN_DI, ASSIGN_ID
    MODULE PROCEDURE ASSIGN_DS
    MODULE PROCEDURE ASSIGN_DD1, ASSIGN_DD2, ASSIGN_DD3
    MODULE PROCEDURE ASSIGN_DD4, ASSIGN_DD5, ASSIGN_DD6, ASSIGN_DD7
    MODULE PROCEDURE ASSIGN_DD10, ASSIGN_DD20, ASSIGN_DD30
    MODULE PROCEDURE ASSIGN_DD40, ASSIGN_DD50, ASSIGN_DD60, ASSIGN_DD70
  END INTERFACE
  PUBLIC ASSIGNMENT (=)
  INTERFACE AD02_CONTROL
    MODULE PROCEDURE CONTROL1,CONTROL2
  END INTERFACE
  PUBLIC AD02_CONTROL
  INTERFACE AD02_DATA_UNDEFINED
    MODULE PROCEDURE DATA_UNDEFINED
  END INTERFACE
  PUBLIC AD02_DATA_UNDEFINED
  INTERFACE AD02_DERIVS
    MODULE PROCEDURE DERIVS_S
  END INTERFACE
  PUBLIC AD02_DERIVS
  INTERFACE AD02_FINALIZE_DATA
    MODULE PROCEDURE FINALIZE
  END INTERFACE
  PUBLIC AD02_FINALIZE_DATA
  INTERFACE AD02_FLAGS
    MODULE PROCEDURE FLAGS1,FLAGS2,FLAGS3,FLAGS4
  END INTERFACE
  PUBLIC AD02_FLAGS
  INTERFACE AD02_GRAD
    MODULE PROCEDURE GRAD0, GRAD1
  END INTERFACE
  PUBLIC AD02_GRAD
  INTERFACE AD02_HESSIAN
    MODULE PROCEDURE HESSIAN0, HESSIAN1
  END INTERFACE
  PUBLIC AD02_HESSIAN
  INTERFACE AD02_INITIALIZE_COMP
    MODULE PROCEDURE INITIALIZE_0, INITIALIZE_11, INITIALIZE_10
  END INTERFACE
  PUBLIC AD02_INITIALIZE_COMP
  INTERFACE AD02_INITIALIZE_DATA
    MODULE PROCEDURE INITIALIZE_DATA
  END INTERFACE
  PUBLIC AD02_INITIALIZE_DATA
  INTERFACE AD02_TEMP
    MODULE PROCEDURE MAKE_TEMP
  END INTERFACE
  PUBLIC AD02_TEMP
  INTERFACE AD02_UNDEFINE
    MODULE PROCEDURE UNDEFINE_REAL0, UNDEFINE_REAL1
    MODULE PROCEDURE UNDEFINE_REAL2, UNDEFINE_REAL3
    MODULE PROCEDURE UNDEFINE_REAL4, UNDEFINE_REAL5
    MODULE PROCEDURE UNDEFINE_REAL6, UNDEFINE_REAL7
  END INTERFACE
  PUBLIC AD02_UNDEFINE
  INTERFACE AD02_UNDEFINED
    MODULE PROCEDURE UNDEFINED
  END INTERFACE
  PUBLIC AD02_UNDEFINED
  INTERFACE AD02_USER
    MODULE PROCEDURE USER
  END INTERFACE
  PUBLIC AD02_USER
  INTERFACE AD02_VALUE
    MODULE PROCEDURE VALUE_SCALAR, VALUE_ARRAY
  END INTERFACE
  PUBLIC AD02_VALUE
  INTERFACE ABS
    MODULE PROCEDURE ABS_D
  END INTERFACE
  PUBLIC ABS
  INTERFACE ACOS
    MODULE PROCEDURE ACOS_D
  END INTERFACE
  PUBLIC ACOS
  INTERFACE AINT
    MODULE PROCEDURE AINT_D
  END INTERFACE
  PUBLIC AINT
  INTERFACE ANINT
    MODULE PROCEDURE ANINT_D
  END INTERFACE
  PUBLIC ANINT
  INTERFACE ASIN
    MODULE PROCEDURE ASIN_D
  END INTERFACE
  PUBLIC ASIN
  INTERFACE ATAN
    MODULE PROCEDURE ATAN_D
  END INTERFACE
  PUBLIC ATAN
  INTERFACE ATAN2
    MODULE PROCEDURE ATAN2_DD, ATAN2_RD, ATAN2_DR
    MODULE PROCEDURE ATAN2_DS, ATAN2_SD
  END INTERFACE
  PUBLIC ATAN2
  INTERFACE COS
    MODULE PROCEDURE COS_D
  END INTERFACE
  PUBLIC COS
  INTERFACE COSH
    MODULE PROCEDURE COSH_D
  END INTERFACE
  PUBLIC COSH
  INTERFACE EXP
    MODULE PROCEDURE EXP_D
  END INTERFACE
  PUBLIC EXP
  INTERFACE INT
    MODULE PROCEDURE INT_D
  END INTERFACE
  PUBLIC INT
  INTERFACE LOG10
    MODULE PROCEDURE LOG10_D
  END INTERFACE
  PUBLIC LOG10
  INTERFACE LOG
    MODULE PROCEDURE LOG_D
  END INTERFACE
  PUBLIC LOG
  INTERFACE MAX
    MODULE PROCEDURE MAX_DD, MAX_DR, MAX_RD
    MODULE PROCEDURE MAX_DS, MAX_SD
  END INTERFACE
  PUBLIC MAX
  INTERFACE MIN
    MODULE PROCEDURE MIN_DD, MIN_DR, MIN_RD
    MODULE PROCEDURE MIN_DS, MIN_SD
  END INTERFACE
  PUBLIC MIN
  INTERFACE NINT
    MODULE PROCEDURE NINT_D
  END INTERFACE
  PUBLIC NINT
  INTERFACE SIGN
    MODULE PROCEDURE SIGN_DD, SIGN_DR, SIGN_RD
    MODULE PROCEDURE SIGN_DS, SIGN_SD
  END INTERFACE
  PUBLIC SIGN
  INTERFACE SIN
    MODULE PROCEDURE SIN_D
  END INTERFACE
  PUBLIC SIN
  INTERFACE SINH
    MODULE PROCEDURE SINH_D
  END INTERFACE
  PUBLIC SINH
  INTERFACE SQRT
    MODULE PROCEDURE SQRT_D
  END INTERFACE
  PUBLIC SQRT
  INTERFACE TAN
    MODULE PROCEDURE TAN_D
  END INTERFACE
  PUBLIC TAN
  INTERFACE TANH
    MODULE PROCEDURE TANH_D
  END INTERFACE
  PUBLIC TANH
  INTERFACE DABS
    MODULE PROCEDURE ABS_D
  END INTERFACE
  PUBLIC DABS
  INTERFACE DACOS
    MODULE PROCEDURE ACOS_D
  END INTERFACE
  PUBLIC DACOS
  INTERFACE DASIN
    MODULE PROCEDURE ASIN_D
  END INTERFACE
  PUBLIC DASIN
  INTERFACE DATAN
    MODULE PROCEDURE ATAN_D
  END INTERFACE
  PUBLIC DATAN
  INTERFACE DATAN2
    MODULE PROCEDURE ATAN2_DD, ATAN2_RD, ATAN2_DR
    MODULE PROCEDURE ATAN2_DS, ATAN2_SD
  END INTERFACE
  PUBLIC DATAN2
  INTERFACE DBLE
    MODULE PROCEDURE REAL_D
  END INTERFACE
  PUBLIC DBLE
  INTERFACE DCOS
    MODULE PROCEDURE COS_D
  END INTERFACE
  PUBLIC DCOS
  INTERFACE DCOSH
    MODULE PROCEDURE COSH_D
  END INTERFACE
  PUBLIC DCOSH
  INTERFACE DEXP
    MODULE PROCEDURE EXP_D
  END INTERFACE
  PUBLIC DEXP
  INTERFACE DINT
    MODULE PROCEDURE AINT_D
  END INTERFACE
  PUBLIC DINT
  INTERFACE DLOG10
    MODULE PROCEDURE LOG10_D
  END INTERFACE
  PUBLIC DLOG10
  INTERFACE DLOG
    MODULE PROCEDURE LOG_D
  END INTERFACE
  PUBLIC DLOG
  INTERFACE DMAX1
    MODULE PROCEDURE MAX_DD, MAX_DR, MAX_RD
    MODULE PROCEDURE MAX_DS, MAX_SD
  END INTERFACE
  PUBLIC DMAX1
  INTERFACE DMIN1
    MODULE PROCEDURE MIN_DD, MIN_DR, MIN_RD
    MODULE PROCEDURE MIN_DS, MIN_SD
  END INTERFACE
  PUBLIC DMIN1
  INTERFACE DNINT
    MODULE PROCEDURE ANINT_D
  END INTERFACE
  PUBLIC DNINT
  INTERFACE DSIGN
    MODULE PROCEDURE SIGN_DD, SIGN_DR, SIGN_RD
    MODULE PROCEDURE SIGN_DS, SIGN_SD
  END INTERFACE
  PUBLIC DSIGN
  INTERFACE DSIN
    MODULE PROCEDURE SIN_D
  END INTERFACE
  PUBLIC DSIN
  INTERFACE DSINH
    MODULE PROCEDURE SINH_D
  END INTERFACE
  PUBLIC DSINH
  INTERFACE DSQRT
    MODULE PROCEDURE SQRT_D
  END INTERFACE
  PUBLIC DSQRT
  INTERFACE DTAN
    MODULE PROCEDURE TAN_D
  END INTERFACE
  PUBLIC DTAN
  INTERFACE DTANH
    MODULE PROCEDURE TANH_D
  END INTERFACE
  PUBLIC DTANH
  INTERFACE IDINT
    MODULE PROCEDURE INT_D
  END INTERFACE
  PUBLIC IDINT
  INTERFACE IDNINT
    MODULE PROCEDURE NINT_D
  END INTERFACE
  PUBLIC IDNINT
CONTAINS
  FUNCTION ABS_D(A)
    TYPE (AD02_REAL) :: ABS_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA, DERF
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ABS_D%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(ABS_D,A,'ABS')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(ABS_D,A,'ABS')
    ELSE
      ABS_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      IF (VA<0.0_WP) THEN
        IF (A%CASE<0) THEN
          DATA%GRAPH(A%P)%RVAL = -VA
          ABS_D%P = A%P
          IF (DATA%GRAPH(A%P)%ONUM==2) THEN
            DATA%GRAPH(A%P)%RVALS = -DATA%GRAPH(A%P)%RVALS
            IF (DATA%LEVEL==2) DATA%DER2(:,A%P)  = -DATA%DER2(:,A%P)
          ELSE
            IF (DATA%LEVEL==2) THEN
              DATA%GRAPH(A%P)%RVALS = -DATA%GRAPH(A%P)%RVALS
            ELSE
              DATA%GRAPH(A%P)%RVALS(0) = -DATA%GRAPH(A%P)%RVALS(0)
            END IF
          END IF
        ELSE
          ABS_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES)%RVAL = ABS(VA)
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = -D1
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
          DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
          IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE IF (VA>0.0_WP) THEN
        ABS_D = A
      ELSE
        CALL ERROR_HANDLER(DATA,ABS_WARN)
        CALL RANDOM_NUMBER(DERF)
        DERF = (DERF-0.5_WP)*2.0_WP
        IF (A%CASE<0) THEN
          ABS_D%P = A%P
          DATA%GRAPH(A%P)%RVAL = DATA%GRAPH(A%P)%RVAL*DERF
          IF (DATA%GRAPH(A%P)%ONUM==2) THEN
            DATA%GRAPH(A%P)%RVALS = DATA%GRAPH(A%P)%RVALS*DERF
            IF (DATA%LEVEL==2) DATA%DER2(:,A%P) = DATA%DER2(:,A%P)*DERF
          ELSE
            IF (DATA%LEVEL==2) THEN
              DATA%GRAPH(A%P)%RVALS = DATA%GRAPH(A%P)%RVALS*DERF
            ELSE
              DATA%GRAPH(A%P)%RVALS(0) = DATA%GRAPH(A%P)%RVALS(0)*DERF
            END IF
          END IF
        ELSE
          ABS_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES)%RVAL = ABS(VA)
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = DERF
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
          DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
          IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION ABS_D
  FUNCTION ACOS_D(X)
    TYPE (AD02_REAL) :: ACOS_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, V, V2
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    ACOS_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ACOS_D,X,'ACOS')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ACOS_D,X,'ACOS')
    ELSE
      ACOS_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = (D1-VA**2)
      V2 = SQRT(V)
      IF (DATA%LEVEL==2) THEN
        IF (X%CASE<0) THEN
          CALL CONDENSE_NODE(DATA,ACOS(VA),X%P,-D1/V2,-VA/(V2*V),ACOS_D)
        ELSE
          ACOS_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES)%RVAL = ACOS(VA)
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = -D1/V2
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = -VA/(V2*V)
          DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = X%P
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        IF (X%CASE<0) THEN
          CALL CONDENSE_NODE(DATA,ACOS(VA),X%P,-D1/V2,D0,ACOS_D)
        ELSE
          ACOS_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = &
                    NODE(ACOS(VA),(/-D1/V2,0.0_WP/),1,(/X%P,0/))
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION ACOS_D
  FUNCTION ADD_DD(A,B)
    TYPE (AD02_REAL) :: ADD_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ADD_DD%DATA => DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(ADD_DD,A,B,'+')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(ADD_DD,A,B,'+')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(ADD_DD,A,B,'+')
    ELSE
      ADD_DD%CASE = -DATA%CASE
      ADD_DD%P = DATA%NUM_NODES
      DATA%GRAPH(DATA%NUM_NODES)%RVAL = &
           DATA%GRAPH(A%P)%RVAL+DATA%GRAPH(B%P)%RVAL
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = 1.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 1.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%ONUM = 2
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = B%P
      IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END FUNCTION ADD_DD
  FUNCTION ADD_DI(A,B)
    TYPE (AD02_REAL) :: ADD_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    CALL COPY(ADD_DI,ADD_DR(A,REAL(B,WP)))
  END FUNCTION ADD_DI
  FUNCTION ADD_DR(A,B)
    TYPE (AD02_REAL) :: ADD_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ADD_DR%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(ADD_DR,A,'+')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(ADD_DR,A,'+')
    ELSE
      ADD_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
        DATA%GRAPH(A%P)%RVAL = DATA%GRAPH(A%P)%RVAL + B
        ADD_DR%P = A%P
      ELSE
        ADD_DR%P = DATA%NUM_NODES
      DATA%GRAPH(DATA%NUM_NODES)%RVAL = DATA%GRAPH(A%P)%RVAL+B
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = 1.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION ADD_DR
  FUNCTION ADD_DS(A,B)
    TYPE (AD02_REAL) :: ADD_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(ADD_DS,ADD_DR(A,REAL(B,WP)))
  END FUNCTION ADD_DS
  FUNCTION ADD_ID(A,B)
    TYPE (AD02_REAL) :: ADD_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ADD_ID,ADD_DR(B,REAL(A,WP)))
  END FUNCTION ADD_ID
  FUNCTION ADD_RD(A,B)
    TYPE (AD02_REAL) :: ADD_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ADD_RD,ADD_DR(B,A))
  END FUNCTION ADD_RD
  FUNCTION ADD_SD(A,B)
    TYPE (AD02_REAL) :: ADD_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ADD_SD,ADD_DR(B,REAL(A,WP)))
  END FUNCTION ADD_SD
  FUNCTION AINT_D(A)
    TYPE (AD02_REAL) :: AINT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    AINT_D%DATA => DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AINT')
      AINT_D = 0.0_WP
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AINT')
      AINT_D = 0.0_WP
    ELSE
      AINT_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      IF (VA==AINT(VA)) CALL ERROR_HANDLER(DATA,AINT_WARN)
      AINT_D = AINT(VA)
    END IF
  END FUNCTION AINT_D
  FUNCTION ANINT_D(A)
    TYPE (AD02_REAL) ANINT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ANINT_D%DATA => DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'ANINT')
      ANINT_D = 0.0_WP
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'ANINT')
      ANINT_D = 0.0_WP
    ELSE
      ANINT_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      IF (ABS(VA-AINT(VA))-0.5_WP==0.0_WP) CALL ERROR_HANDLER(DATA,ANINT_WARN)
      ANINT_D = ANINT(VA)
    END IF
  END FUNCTION ANINT_D
  FUNCTION ASIN_D(X)
    TYPE (AD02_REAL) :: ASIN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, V, V2
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    ASIN_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ASIN_D,X,'ASIN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ASIN_D,X,'ASIN')
    ELSE
      ASIN_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = (D1-VA**2)
      V2 = SQRT(V)
      IF (DATA%LEVEL==2) THEN
        IF (X%CASE<0) THEN
          CALL CONDENSE_NODE(DATA,ASIN(VA),X%P,D1/V2,VA/(V2*V),ASIN_D)
        ELSE
          ASIN_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = &
               NODE(ASIN(VA),(/D1/V2,VA/(V2*V)/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        IF (X%CASE<0) THEN
          CALL CONDENSE_NODE(DATA,ASIN(VA),X%P,D1/V2,D0,ASIN_D)
        ELSE
          ASIN_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = &
              NODE(ASIN(VA),(/D1/V2,0.0_WP/),1,(/X%P,0/))
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION ASIN_D
  SUBROUTINE ASSIGN_DD(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    A%DATA => DATA
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(A,B,'Assign')
      RETURN
    ELSE IF (DATA%CASE/=ABS(B%CASE) ) THEN
      CALL UNARY_WARNING(A,B,'Assign')
      RETURN
    ELSE
      A%P = B%P
      A%CASE = DATA%CASE
    END IF
  END SUBROUTINE ASSIGN_DD
  SUBROUTINE ASSIGN_DD1(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:)
    CALL ERROR_HANDLER(B(1)%DATA,ASSIGNMENT_WARN)
    CALL AD02_UNDEFINE(A,B(1)%DATA)
  END SUBROUTINE ASSIGN_DD1
  SUBROUTINE ASSIGN_DD10(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
    CALL AD02_UNDEFINE(A,B%DATA)
  END SUBROUTINE ASSIGN_DD10
  SUBROUTINE ASSIGN_DD2(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:)
    CALL AD02_UNDEFINE(A,B(1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD2
  SUBROUTINE ASSIGN_DD20(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD20
  SUBROUTINE ASSIGN_DD3(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD3
  SUBROUTINE ASSIGN_DD30(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD30
  SUBROUTINE ASSIGN_DD4(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD4
  SUBROUTINE ASSIGN_DD40(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD40
  SUBROUTINE ASSIGN_DD5(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD5
  SUBROUTINE ASSIGN_DD50(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD50
  SUBROUTINE ASSIGN_DD6(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD6
  SUBROUTINE ASSIGN_DD60(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD60
  SUBROUTINE ASSIGN_DD7(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD7
  SUBROUTINE ASSIGN_DD70(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    A%P = -1
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD70
  SUBROUTINE ASSIGN_DI(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    INTEGER, INTENT (IN) :: B
    CALL ASSIGN_DR(A,REAL(B,WP))
  END SUBROUTINE ASSIGN_DI
  SUBROUTINE ASSIGN_DR(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF(.NOT.ASSOCIATED(DATA))THEN
      CALL AD02_UNDEFINE(A)
    ELSE
      A%P = DATA%NUM_NODES
      A%CASE = ABS(A%CASE)
      DATA%GRAPH(DATA%NUM_NODES)%RVAL = B
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = 0.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%ONUM = 0
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = 1
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
      IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END SUBROUTINE ASSIGN_DR
  SUBROUTINE ASSIGN_DS(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    REAL, INTENT (IN) :: B
    CALL ASSIGN_DR(A,REAL(B,WP))
  END SUBROUTINE ASSIGN_DS
  SUBROUTINE ASSIGN_ID(A,B)
    INTEGER, INTENT (OUT) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'Assign')
      A = 0
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'Assign')
      A = 0
    ELSE
      A = DATA%GRAPH(B%P)%RVAL
    END IF
  END SUBROUTINE ASSIGN_ID
  FUNCTION ATAN_D(X)
    TYPE (AD02_REAL) :: ATAN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, V
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    ATAN_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ATAN_D,X,'ATAN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ATAN_D,X,'ATAN')
    ELSE
      ATAN_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = (D1+VA**2)
      IF (DATA%LEVEL==2) THEN
        IF (X%CASE<0) THEN
          CALL CONDENSE_NODE(DATA,ATAN(VA),X%P,D1/V,-D2*VA/V**2,ATAN_D)
        ELSE
          ATAN_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN(VA),(/D1/V,-D2*VA/V**2/),1,(/X%
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        IF (X%CASE<0) THEN
          CALL CONDENSE_NODE(DATA,ATAN(VA),X%P,D1/V,D0,ATAN_D)
        ELSE
          ATAN_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN(VA),(/D1/V,0.0_WP/),1,(/X%P,0/)
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION ATAN_D
  FUNCTION ATAN2_DD(Y,X)
    TYPE (AD02_REAL) :: ATAN2_DD
    TYPE (AD02_REAL), INTENT (IN) :: Y, X
    REAL (WP) VA, VB, V
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    ATAN2_DD%DATA => DATA
    IF (X%P==-1 .OR. Y%P==-1) THEN
      CALL BINARY_WARNING(ATAN2_DD,X,Y,'ATAN2')
    ELSE IF (.NOT.ASSOCIATED(DATA,Y%DATA)) THEN
      CALL BINARY_WARNING(ATAN2_DD,X,Y,'ATAN2')
    ELSE IF (DATA%CASE/=ABS(X%CASE) .OR.DATA%CASE/=ABS(Y%CASE) ) THEN
      CALL BINARY_WARNING(ATAN2_DD,X,Y,'ATAN2')
    ELSE
      ATAN2_DD%CASE = -DATA%CASE
      VA = DATA%GRAPH(Y%P)%RVAL
      VB = DATA%GRAPH(X%P)%RVAL
      IF (ABS(VB)>ABS(VA)) THEN
        V = D1 + (VA/VB)**2
        ATAN2_DD%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(VA,VB),(/D1/(VB*V),-VA/(VB**2*V)
          (/Y%P,X%P/))
        IF (DATA%LEVEL==2) THEN
          DATA%DER2(0,DATA%NUM_NODES) = -D2*VA/(VB**3*V**2)
          DATA%DER2(1,DATA%NUM_NODES) = -D1/(VB**2*V)+D2*VA**2/(VB**4*V**2)
          DATA%DER2(2,DATA%NUM_NODES) = D2*VA/(VB**3*V)-D2*VA**3/(VB**5*V**2)
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      ELSE
        V = D1 + (VB/VA)**2
        ATAN2_DD%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(VA,VB),(/VB/(VA**2*V),-D1/(VA*V)
          (/Y%P,X%P/))
        IF (DATA%LEVEL==2) THEN
          DATA%DER2(0,DATA%NUM_NODES) = -D2*VB/(VA**3*V)+D2*VB**3/(VA**5*V**2)
          DATA%DER2(1,DATA%NUM_NODES) = D1/(VA**2*V)-D2*VB**2/(VA**4*V**2)
          DATA%DER2(2,DATA%NUM_NODES) = D2*VB/(VA**3*V**2)
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION ATAN2_DD
  FUNCTION ATAN2_DR(Y,X)
    TYPE (AD02_REAL) :: ATAN2_DR
    TYPE (AD02_REAL), INTENT (IN) :: Y
    REAL (WP), INTENT (IN) :: X
    REAL (WP) V, RY
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => Y%DATA
    ATAN2_DR%DATA => DATA
    IF (Y%P==-1) THEN
      CALL UNARY_WARNING(ATAN2_DR,Y,'ATAN2')
    ELSE IF (DATA%CASE/=ABS(Y%CASE)) THEN
      CALL UNARY_WARNING(ATAN2_DR,Y,'ATAN2')
    ELSE
      ATAN2_DR%CASE = -DATA%CASE
      RY = DATA%GRAPH(Y%P)%RVAL
      IF (ABS(X)>ABS(RY)) THEN
        V = D1 + RY**2/X**2
        IF (Y%CASE<0) THEN
          IF (DATA%LEVEL==2) THEN
            CALL CONDENSE_NODE(DATA,ATAN2(RY,X),Y%P,D1/(V*X),-D2*RY/(X**3*V**2),
              ATAN2_DR)
          ELSE
            CALL CONDENSE_NODE(DATA,ATAN2(RY,X),Y%P,D1/(V*X),D0,ATAN2_DR)
          END IF
        ELSE
          ATAN2_DR%P = DATA%NUM_NODES
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(RY,X),(/D1/(V*X), &
              -D2*RY/(X**3*V**2)/),1,(/Y%P,0/))
            DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          ELSE
            DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(RY,X),(/D1/(V*X),0.0_WP/),1,
              0/))
          END IF
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        V = D1 + X**2/RY**2
        IF (Y%CASE<0) THEN
          IF (DATA%LEVEL==2) THEN
            CALL CONDENSE_NODE(DATA,ATAN2(RY,X),Y%P,X/(RY**2*V), &
              -D2*X/(RY**3*V)+D2*X**3/(RY**5*V**2),ATAN2_DR)
          ELSE
            CALL CONDENSE_NODE(DATA,ATAN2(RY,X),Y%P,X/(RY**2*V),D0,ATAN2_DR)
          END IF
        ELSE
          ATAN2_DR%P = DATA%NUM_NODES
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(RY,X),(/X/(RY**2*V), &
              -D2*X/(RY**3*V)+D2*X**3/(RY**5*V**2)/),1,(/Y%P,0/))
            DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          ELSE
            DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(RY,X),(/X/(RY**2*V),0.0_WP/)
              (/Y%P,0/))
          END IF
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION ATAN2_DR
  FUNCTION ATAN2_DS(A,B)
    TYPE (AD02_REAL) :: ATAN2_DS
    REAL, INTENT (IN) :: B
    TYPE (AD02_REAL), INTENT (IN) :: A
    CALL COPY(ATAN2_DS,ATAN2_DR(A,REAL(B,WP)))
  END FUNCTION ATAN2_DS
  FUNCTION ATAN2_RD(Y,X)
    TYPE (AD02_REAL) :: ATAN2_RD
    REAL (WP), INTENT (IN) :: Y
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) V, RX
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    ATAN2_RD%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ATAN2_RD,X,'ATAN2')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ATAN2_RD,X,'ATAN2')
    ELSE
      ATAN2_RD%CASE = -DATA%CASE
      RX = DATA%GRAPH(X%P)%RVAL
      IF (ABS(RX)>ABS(Y)) THEN
        V = D1 + Y**2/RX**2
        IF (X%CASE<0) THEN
          IF (DATA%LEVEL==2) THEN
            CALL CONDENSE_NODE(DATA,ATAN2(Y,RX),X%P,-Y/(RX**2*V), &
              D2*Y/(RX**3*V)-D2*Y**3/(RX**5*V**2),ATAN2_RD)
          ELSE
            CALL CONDENSE_NODE(DATA,ATAN2(Y,RX),X%P,-Y/(RX**2*V),0.0_WP,ATAN2_RD
          END IF
        ELSE
          ATAN2_RD%P = DATA%NUM_NODES
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(Y,RX),(/-Y/(RX**2*V), &
              D2*Y/(RX**3*V)-D2*Y**3/(RX**5*V**2)/),1,(/X%P,0/))
            DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          ELSE
            DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(Y,RX),(/-Y/(RX**2*V),0.0_WP/
              (/X%P,0/))
          END IF
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        V = D1 + RX**2/Y**2
        IF (X%CASE<0) THEN
          IF (DATA%LEVEL==2) THEN
            CALL CONDENSE_NODE(DATA,ATAN2(Y,RX),X%P,-D1/(Y*V),D2*RX/(Y**3*V**2),
              ATAN2_RD)
          ELSE
            CALL CONDENSE_NODE(DATA,ATAN2(Y,RX),X%P,-D1/(Y*V),0.0_WP,ATAN2_RD)
          END IF
        ELSE
          ATAN2_RD%P = DATA%NUM_NODES
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(Y,RX),(/-D1/(Y*V), &
              D2*RX/(Y**3*V**2)/),1,(/X%P,0/))
            DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          ELSE
            DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(Y,RX),(/-D1/(Y*V),0.0_WP/),1
              0/))
          END IF
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION ATAN2_RD
  FUNCTION ATAN2_SD(A,B)
    TYPE (AD02_REAL) :: ATAN2_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ATAN2_SD,ATAN2_RD(REAL(A,WP),B))
  END FUNCTION ATAN2_SD
  FUNCTION COS_D(X)
    TYPE (AD02_REAL) :: COS_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) V, VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    COS_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(COS_D,X,'COS')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(COS_D,X,'COS')
    ELSE
      COS_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = COS(VA)
      IF (X%CASE<0) THEN
        CALL CONDENSE_NODE(DATA,V,X%P,-SIN(VA),-V,COS_D)
      ELSE
        COS_D%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/-SIN(VA),-V/),1,(/X%P,0/))
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION COS_D
  FUNCTION COSH_D(X)
    TYPE (AD02_REAL) :: COSH_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, V
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    COSH_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(COSH_D,X,'COSH')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(COSH_D,X,'COSH')
    ELSE
      COSH_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = COSH(VA)
      IF (X%CASE<0) THEN
        CALL CONDENSE_NODE(DATA,V,X%P,SINH(VA),V,COSH_D)
      ELSE
        COSH_D%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/SINH(VA),V/),1,(/X%P,0/))
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION COSH_D
  FUNCTION DIV_DD(A,B)
    TYPE (AD02_REAL) :: DIV_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    REAL (WP) VA, VB, VC
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    DIV_DD%DATA => DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(DIV_DD,A,B,'/')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(DIV_DD,A,B,'/')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE) ) THEN
      CALL BINARY_WARNING(DIV_DD,A,B,'/')
    ELSE
      DIV_DD%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      VB = DATA%GRAPH(B%P)%RVAL
      VC = VA/VB
      DIV_DD%P = DATA%NUM_NODES
      DATA%GRAPH(DATA%NUM_NODES)%RVAL = VC
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = D1/VB
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = -VC/VB
      DATA%GRAPH(DATA%NUM_NODES)%ONUM = 2
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = B%P
      IF (DATA%LEVEL==2) THEN
         DATA%DER2(0,DATA%NUM_NODES) = D0
         DATA%DER2(1,DATA%NUM_NODES) = -D1/VB**2
         DATA%DER2(2,DATA%NUM_NODES) = D2*VC/VB**2
      END IF
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END FUNCTION DIV_DD
  FUNCTION DIV_DI(A,B)
    TYPE (AD02_REAL) :: DIV_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    CALL COPY(DIV_DI,DIV_DR(A,REAL(B,WP)))
  END FUNCTION DIV_DI
  FUNCTION DIV_DR(A,B)
    TYPE (AD02_REAL) :: DIV_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    DIV_DR%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(DIV_DR,A,'/')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(DIV_DR,A,'/')
    ELSE
      DIV_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
        DIV_DR%P = A%P
        DATA%GRAPH(A%P)%RVAL = DATA%GRAPH(A%P)%RVAL/B
        IF (DATA%GRAPH(A%P)%ONUM==2) THEN
          DATA%GRAPH(A%P)%RVALS = DATA%GRAPH(A%P)%RVALS/B
          IF (DATA%LEVEL==2) DATA%DER2(:,A%P) = DATA%DER2(:,A%P)/B
        ELSE
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(A%P)%RVALS = DATA%GRAPH(A%P)%RVALS/B
          ELSE
            DATA%GRAPH(A%P)%RVALS(0) = DATA%GRAPH(A%P)%RVALS(0)/B
          END IF
        END IF
      ELSE
        DIV_DR%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = NODE(DATA%GRAPH(A%P)%RVAL/B,(/D1/B,0.0_WP/)
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION DIV_DR
  FUNCTION DIV_DS(A,B)
    TYPE (AD02_REAL) :: DIV_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(DIV_DS,DIV_DR(A,REAL(B,WP)))
  END FUNCTION DIV_DS
  FUNCTION DIV_ID(A,B)
    TYPE (AD02_REAL) :: DIV_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(DIV_ID,DIV_RD(REAL(A,WP),B))
  END FUNCTION DIV_ID
  FUNCTION DIV_RD(A,B)
    TYPE (AD02_REAL) :: DIV_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL (WP) AB, RB
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    DIV_RD%DATA => DATA
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(DIV_RD,B,'/')
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(DIV_RD,B,'/')
    ELSE
      DIV_RD%CASE = -DATA%CASE
      RB = DATA%GRAPH(B%P)%RVAL
      AB = A/RB
      IF (B%CASE<0) THEN
        IF (DATA%LEVEL==2) THEN
          CALL CONDENSE_NODE(DATA,AB,B%P,-AB/RB,D2*AB/(RB*RB),DIV_RD)
        ELSE
          CALL CONDENSE_NODE(DATA,AB,B%P,-AB/RB,D0,DIV_RD)
        END IF
      ELSE
        DIV_RD%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(AB,(/-AB/RB,D2*AB/(RB*RB)/),1,(/B%P,
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES)%RVAL = AB
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = -AB/RB
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
          DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = B%P
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION DIV_RD
  FUNCTION DIV_SD(A,B)
    TYPE (AD02_REAL) :: DIV_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(DIV_SD,DIV_RD(REAL(A,WP),B))
  END FUNCTION DIV_SD
  FUNCTION EQ_DD(A,B)
    LOGICAL :: EQ_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DD = .TRUE.
    ELSE
      EQ_DD = DATA%GRAPH(A%P)%RVAL == DATA%GRAPH(B%P)%RVAL
      IF (EQ_DD) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_DD
  FUNCTION EQ_DI(A,B)
    LOGICAL :: EQ_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DI = .TRUE.
    ELSE
      EQ_DI = DATA%GRAPH(A%P)%RVAL == B
      IF (EQ_DI) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_DI
  FUNCTION EQ_DR(A,B)
    LOGICAL :: EQ_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DR = .TRUE.
    ELSE
      EQ_DR = DATA%GRAPH(A%P)%RVAL == B
      IF (EQ_DR) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_DR
  FUNCTION EQ_DS(A,B)
    LOGICAL :: EQ_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DS = .TRUE.
    ELSE
      EQ_DS = DATA%GRAPH(A%P)%RVAL == B
      IF (EQ_DS) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_DS
  FUNCTION EQ_ID(A,B)
    LOGICAL :: EQ_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_ID = .TRUE.
    ELSE
      EQ_ID = A == DATA%GRAPH(B%P)%RVAL
      IF (EQ_ID) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_ID
  FUNCTION EQ_SD(A,B)
    LOGICAL :: EQ_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_SD = .TRUE.
    ELSE
      EQ_SD = A == DATA%GRAPH(B%P)%RVAL
      IF (EQ_SD) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_SD
  FUNCTION EQ_RD(A,B)
    LOGICAL :: EQ_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_RD = .TRUE.
    ELSE
      EQ_RD = A == DATA%GRAPH(B%P)%RVAL
      IF (EQ_RD) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_RD
  FUNCTION EXP_D(X)
    TYPE (AD02_REAL) :: EXP_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VB
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    EXP_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(EXP_D,X,'EXP')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(EXP_D,X,'EXP')
    ELSE
      EXP_D%CASE = -DATA%CASE
      VB = EXP(DATA%GRAPH(X%P)%RVAL)
      IF (X%CASE<0) THEN
        CALL CONDENSE_NODE(DATA,VB,X%P,VB,VB,EXP_D)
      ELSE
        EXP_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VB,(/VB,VB/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VB,(/VB,0.0_WP/),1,(/X%P,0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION EXP_D
  FUNCTION GE_DD(A,B)
    LOGICAL :: GE_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DD = .TRUE.
     ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DD = .TRUE.
    ELSE
      GE_DD = DATA%GRAPH(A%P)%RVAL >= DATA%GRAPH(B%P)%RVAL
      IF (DATA%GRAPH(A%P)%RVAL==DATA%GRAPH(B%P)%RVAL) &
         CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_DD
  FUNCTION GE_DI(A,B)
    LOGICAL :: GE_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_DI = DATA%GRAPH(A%P)%RVAL >= B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_DI
  FUNCTION GE_DR(A,B)
    LOGICAL :: GE_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_DR = DATA%GRAPH(A%P)%RVAL >= B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_DR
  FUNCTION GE_DS(A,B)
    LOGICAL :: GE_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_DS = DATA%GRAPH(A%P)%RVAL >= B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_DS
  FUNCTION GE_ID(A,B)
    LOGICAL :: GE_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_ID = A >= DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_ID
  FUNCTION GE_RD(A,B)
    LOGICAL :: GE_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_RD = A >= DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_RD
  FUNCTION GE_SD(A,B)
    LOGICAL :: GE_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_SD = A >= DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_SD
  FUNCTION GT_DD(A,B)
    LOGICAL :: GT_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DD = .TRUE.
    ELSE IF ( DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DD = .TRUE.
    ELSE
      GT_DD = DATA%GRAPH(A%P)%RVAL > DATA%GRAPH(B%P)%RVAL
      IF (DATA%GRAPH(A%P)%RVAL==DATA%GRAPH(B%P)%RVAL) &
         CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_DD
  FUNCTION GT_DI(A,B)
    LOGICAL :: GT_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DI = .TRUE.
    ELSE
      GT_DI = DATA%GRAPH(A%P)%RVAL > B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_DI
  FUNCTION GT_DR(A,B)
    LOGICAL :: GT_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DR = .TRUE.
    ELSE
      GT_DR = DATA%GRAPH(A%P)%RVAL > B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_DR
  FUNCTION GT_DS(A,B)
    LOGICAL :: GT_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DS = .TRUE.
    ELSE
      GT_DS = DATA%GRAPH(A%P)%RVAL > B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_DS
  FUNCTION GT_ID(A,B)
    LOGICAL :: GT_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_ID = .TRUE.
    ELSE
      GT_ID = A > DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_ID
  FUNCTION GT_RD(A,B)
    LOGICAL :: GT_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_RD = .TRUE.
    ELSE
      GT_RD = A > DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_RD
  FUNCTION GT_SD(A,B)
    LOGICAL :: GT_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_SD = .TRUE.
    ELSE
      GT_SD = A > DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_SD
  FUNCTION INT_D(A)
    TYPE (AD02_REAL) INT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    INT_D%DATA => DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'INT')
      INT_D = 0
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'INT')
      INT_D = 0
    ELSE
      INT_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      IF (VA==AINT(VA)) CALL ERROR_HANDLER(DATA,INT_WARN)
      INT_D = INT(VA)
    END IF
  END FUNCTION INT_D
  FUNCTION LOG_D(X)
    TYPE (AD02_REAL) :: LOG_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    LOG_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(LOG_D,X,'LOG')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(LOG_D,X,'LOG')
    ELSE
      LOG_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      IF (X%CASE<0) THEN
        IF (DATA%LEVEL==2) THEN
          CALL CONDENSE_NODE(DATA,LOG(VA),X%P,D1/VA,-D1/VA**2,LOG_D)
        ELSE
          CALL CONDENSE_NODE(DATA,LOG(VA),X%P,D1/VA,D0,LOG_D)
        END IF
      ELSE
        LOG_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(LOG(VA),(/D1/VA,-D1/VA**2/),1,(/X%P,
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = NODE(LOG(VA),(/D1/VA,0.0_WP/),1,(/X%P,0/)
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION LOG_D
  FUNCTION LOG10_D(X)
    TYPE (AD02_REAL) :: LOG10_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    LOG10_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(LOG10_D,X,'LOG10')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(LOG10_D,X,'LOG10')
    ELSE
      LOG10_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      IF (X%CASE<0) THEN
        IF (DATA%LEVEL==2) THEN
          CALL CONDENSE_NODE(DATA,LOG10(VA),X%P,D1/(VA*LN10),-D1/(VA**2*LN10), &
            LOG10_D)
        ELSE
          CALL CONDENSE_NODE(DATA,LOG10(VA),X%P,D1/(VA*LN10),D0,LOG10_D)
        END IF
      ELSE
        LOG10_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(LOG10(VA),(/D1/(VA*LN10),-D1/(VA**2*
            1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = NODE(LOG10(VA),(/D1/(VA*LN10),0.0_WP/),1,
            0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION LOG10_D
  FUNCTION LE_DD(A,B)
    LOGICAL :: LE_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE).OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DD = .TRUE.
    ELSE
      LE_DD = DATA%GRAPH(A%P)%RVAL <= DATA%GRAPH(B%P)%RVAL
      IF (DATA%GRAPH(A%P)%RVAL==DATA%GRAPH(B%P)%RVAL) &
            CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_DD
  FUNCTION LE_DI(A,B)
    LOGICAL :: LE_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DI = .TRUE.
    ELSE
      LE_DI = DATA%GRAPH(A%P)%RVAL <= B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_DI
  FUNCTION LE_DR(A,B)
    LOGICAL :: LE_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DR = .TRUE.
    ELSE
      LE_DR = DATA%GRAPH(A%P)%RVAL <= B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_DR
  FUNCTION LE_DS(A,B)
    LOGICAL :: LE_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DS = .TRUE.
    ELSE
      LE_DS = DATA%GRAPH(A%P)%RVAL <= B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_DS
  FUNCTION LE_ID(A,B)
    LOGICAL :: LE_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_ID = .TRUE.
    ELSE
      LE_ID = A <= DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_ID
  FUNCTION LE_RD(A,B)
    LOGICAL :: LE_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_RD = .TRUE.
    ELSE
      LE_RD = A <= DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_RD
  FUNCTION LE_SD(A,B)
    LOGICAL :: LE_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_SD = .TRUE.
    ELSE
      LE_SD = A <= DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_SD
  FUNCTION LT_DD(A,B)
    LOGICAL :: LT_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DD = .TRUE.
    ELSE
      LT_DD = DATA%GRAPH(A%P)%RVAL < DATA%GRAPH(B%P)%RVAL
      IF (DATA%GRAPH(A%P)%RVAL==DATA%GRAPH(B%P)%RVAL) &
         CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_DD
  FUNCTION LT_DI(A,B)
    LOGICAL :: LT_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DI = .TRUE.
    ELSE
      LT_DI = DATA%GRAPH(A%P)%RVAL < B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_DI
  FUNCTION LT_DR(A,B)
    LOGICAL :: LT_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
    ELSE
      LT_DR = DATA%GRAPH(A%P)%RVAL < B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_DR
  FUNCTION LT_DS(A,B)
    LOGICAL :: LT_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
    ELSE
      LT_DS = DATA%GRAPH(A%P)%RVAL < B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_DS
  FUNCTION LT_ID(A,B)
    LOGICAL :: LT_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_ID = .TRUE.
    ELSE
      LT_ID = A < DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_ID
  FUNCTION LT_RD(A,B)
    LOGICAL :: LT_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_RD = .TRUE.
    ELSE
      LT_RD = A < DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_RD
  FUNCTION LT_SD(A,B)
    LOGICAL :: LT_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_SD = .TRUE.
    ELSE
      LT_SD = A < DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_SD
  FUNCTION MAX_DD(A1,A2)
    TYPE (AD02_REAL) :: MAX_DD
    TYPE (AD02_REAL), INTENT (IN) :: A1, A2
    REAL (WP) VA, VB, RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    MAX_DD%DATA => DATA
    IF (A1%P==-1 .OR. A2%P==-1) THEN
      CALL BINARY_WARNING(MAX_DD,A1,A2,'MAX')
    ELSE IF (.NOT.ASSOCIATED(DATA,A2%DATA)) THEN
      CALL BINARY_WARNING(MAX_DD,A1,A2,'MAX')
    ELSE IF (DATA%CASE/=ABS(A1%CASE) .OR. DATA%CASE/=ABS(A2%CASE)) THEN
      CALL BINARY_WARNING(MAX_DD,A1,A2,'MAX')
    ELSE
      MAX_DD%CASE = -DATA%CASE
      VA = DATA%GRAPH(A1%P)%RVAL
      VB = DATA%GRAPH(A2%P)%RVAL
      IF (VA>VB) THEN
        MAX_DD%P = A1%P
        MAX_DD%CASE= A1%CASE
      ELSE IF (VB>VA) THEN
        MAX_DD%P = A2%P
        MAX_DD%CASE= A2%CASE
      ELSE
        CALL ERROR_HANDLER(DATA,MAX_WARN)
        CALL RANDOM_NUMBER(RAND)
        MAX_DD%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) =  &
           NODE( RAND*DATA%GRAPH(A1%P)%RVAL+(1.0_WP-RAND)*DATA%GRAPH(A2%P)%RVAL,
                (/RAND,1.0_WP-RAND/), 2, (/A1%P,A2%P/) )
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION MAX_DD
  FUNCTION MAX_DR(A1,A2)
    TYPE (AD02_REAL) :: MAX_DR
    TYPE (AD02_REAL), INTENT (IN) :: A1
    REAL (WP), INTENT (IN) :: A2
    REAL (WP) RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    MAX_DR%DATA => DATA
    IF (A1%P==-1) THEN
      CALL UNARY_WARNING(MAX_DR,A1,'MAX')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL UNARY_WARNING(MAX_DR,A1,'MAX')
    ELSE
      IF (DATA%GRAPH(A1%P)%RVAL>A2) THEN
        MAX_DR%P = A1%P
        MAX_DR%CASE = A1%CASE
      ELSE IF (DATA%GRAPH(A1%P)%RVAL<A2) THEN
        MAX_DR%P = DATA%NUM_NODES
        MAX_DR%CASE = -DATA%CASE
        DATA%GRAPH(DATA%NUM_NODES) = NODE(A2,(/0.0_WP,0.0_WP/),0,(/1,0/))
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      ELSE
        CALL ERROR_HANDLER(DATA,MAX_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(MAX_DR,A1*RAND+A2*(1.0_WP-RAND))
      END IF
    END IF
  END FUNCTION MAX_DR
  FUNCTION MAX_DS(A,B)
    TYPE (AD02_REAL) :: MAX_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MAX_DS,MAX_DR(A,REAL(B,WP)))
  END FUNCTION MAX_DS
  FUNCTION MAX_RD(A1,A2)
    TYPE (AD02_REAL) :: MAX_RD
    REAL (WP), INTENT (IN) :: A1
    TYPE (AD02_REAL), INTENT (IN) :: A2
    CALL COPY(MAX_RD,MAX_DR(A2,REAL(A1,WP)))
  END FUNCTION MAX_RD
  FUNCTION MAX_SD(A,B)
    TYPE (AD02_REAL) :: MAX_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(MAX_SD,MAX_RD(REAL(A,WP),B))
  END FUNCTION MAX_SD
  FUNCTION MIN_DD(A1,A2)
    TYPE (AD02_REAL) :: MIN_DD
    TYPE (AD02_REAL), INTENT (IN) :: A1, A2
    REAL (WP) VA, VB, RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    MIN_DD%DATA => DATA
    IF (A1%P==-1 .OR. A2%P==-1) THEN
      CALL BINARY_WARNING(MIN_DD,A1,A2,'MIN')
    ELSE IF (.NOT.ASSOCIATED(DATA,A2%DATA)) THEN
      CALL BINARY_WARNING(MIN_DD,A1,A2,'MIN')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL BINARY_WARNING(MIN_DD,A1,A2,'MIN')
    ELSE
      MIN_DD%CASE = -DATA%CASE
      VA = DATA%GRAPH(A1%P)%RVAL
      VB = DATA%GRAPH(A2%P)%RVAL
      IF (VA<VB) THEN
        MIN_DD%P = A1%P
        MIN_DD%CASE = A1%CASE
      ELSE IF (VB<VA) THEN
        MIN_DD%P = A2%P
        MIN_DD%CASE = A2%CASE
      ELSE
        CALL ERROR_HANDLER(DATA,MIN_WARN)
        CALL RANDOM_NUMBER(RAND)
        MIN_DD%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) =  &
           NODE( RAND*DATA%GRAPH(A1%P)%RVAL+(1.0_WP-RAND)*DATA%GRAPH(A2%P)%RVAL,
                (/RAND,1.0_WP-RAND/), 2, (/A1%P,A2%P/) )
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION MIN_DD
  FUNCTION MIN_DR(A1,A2)
    TYPE (AD02_REAL) :: MIN_DR
    TYPE (AD02_REAL), INTENT (IN) :: A1
    REAL (WP), INTENT (IN) :: A2
    REAL (WP) RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    MIN_DR%DATA => DATA
    IF (A1%P==-1) THEN
      CALL UNARY_WARNING(MIN_DR,A1,'MIN')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL UNARY_WARNING(MIN_DR,A1,'MIN')
    ELSE
      IF (DATA%GRAPH(A1%P)%RVAL>A2) THEN
        MIN_DR%CASE = -DATA%CASE
        MIN_DR%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = NODE(A2,(/0.0_WP,0.0_WP/),0,(/1,0/))
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      ELSE IF (DATA%GRAPH(A1%P)%RVAL<A2) THEN
        MIN_DR%P = A1%P
        MIN_DR%CASE = A1%CASE
      ELSE
        CALL ERROR_HANDLER(DATA,MIN_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(MIN_DR,A1*RAND+A2*(1.0_WP-RAND))
      END IF
    END IF
  END FUNCTION MIN_DR
  FUNCTION MIN_DS(A,B)
    TYPE (AD02_REAL) :: MIN_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MIN_DS,MIN_DR(A,REAL(B,WP)))
  END FUNCTION MIN_DS
  FUNCTION MIN_RD(A1,A2)
    TYPE (AD02_REAL) :: MIN_RD
    REAL (WP), INTENT (IN) :: A1
    TYPE (AD02_REAL), INTENT (IN) :: A2
    CALL COPY(MIN_RD,MIN_DR(A2,REAL(A1,WP)))
  END FUNCTION MIN_RD
  FUNCTION MIN_SD(A,B)
    TYPE (AD02_REAL) :: MIN_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(MIN_SD,MIN_RD(REAL(A,WP),B))
  END FUNCTION MIN_SD
  FUNCTION MINUS_D(A1)
    TYPE (AD02_REAL) :: MINUS_D
    TYPE (AD02_REAL), INTENT (IN) :: A1
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    MINUS_D%DATA => DATA
    IF (A1%P==-1) THEN
      CALL UNARY_WARNING(MINUS_D,A1,'Unary -')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL UNARY_WARNING(MINUS_D,A1,'-')
    ELSE
      MINUS_D%CASE = -DATA%CASE
      IF (A1%CASE<0) THEN
        DATA%GRAPH(A1%P)%RVAL = -DATA%GRAPH(A1%P)%RVAL
        MINUS_D%P = A1%P
        IF (DATA%GRAPH(A1%P)%ONUM==2) THEN
          DATA%GRAPH(A1%P)%RVALS = -DATA%GRAPH(A1%P)%RVALS
          IF (DATA%LEVEL==2) DATA%DER2(:,A1%P) = -DATA%DER2(:,A1%P)
        ELSE
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(A1%P)%RVALS = -DATA%GRAPH(A1%P)%RVALS
          ELSE
            DATA%GRAPH(A1%P)%RVALS(0) = -DATA%GRAPH(A1%P)%RVALS(0)
          END IF
        END IF
      ELSE
        MINUS_D%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = NODE(-DATA%GRAPH(A1%P)%RVAL,(/-D1,D0/),1,(/
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION MINUS_D
  FUNCTION MINUS_DD(A,B)
    TYPE (AD02_REAL) :: MINUS_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MINUS_DD%DATA => DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL UNARY_WARNING(MINUS_DD,B,'-')
    ELSE IF (.NOT.ASSOCIATED(A%DATA,B%DATA)) THEN
      CALL UNARY_WARNING(MINUS_DD,B,'-')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(MINUS_DD,B,'-')
    ELSE
      MINUS_DD%CASE = -DATA%CASE
      MINUS_DD%P = DATA%NUM_NODES
      DATA%GRAPH(DATA%NUM_NODES)%RVAL = DATA%GRAPH(A%P)%RVAL-DATA%GRAPH(B%P)%RVA
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = 1.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = -1.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%ONUM = 2
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = B%P
      IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END FUNCTION MINUS_DD
  FUNCTION MINUS_DI(A,B)
    TYPE (AD02_REAL) :: MINUS_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    CALL COPY(MINUS_DI,MINUS_DR(A,REAL(B,WP)))
  END FUNCTION MINUS_DI
  FUNCTION MINUS_DR(A,B)
    TYPE (AD02_REAL) :: MINUS_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MINUS_DR%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(MINUS_DR,A,'-')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(MINUS_DR,A,'-')
    ELSE
      MINUS_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
        DATA%GRAPH(A%P)%RVAL = DATA%GRAPH(A%P)%RVAL - B
        MINUS_DR%P = A%P
        MINUS_DR%CASE = A%CASE
      ELSE
        MINUS_DR%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) =  NODE(DATA%GRAPH(A%P)%RVAL-B, &
                                    (/1.0_WP,0.0_WP/),1,(/A%P, 0/))
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION MINUS_DR
  FUNCTION MINUS_DS(A,B)
    TYPE (AD02_REAL) :: MINUS_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MINUS_DS,MINUS_DR(A,REAL(B,WP)))
  END FUNCTION MINUS_DS
  FUNCTION MINUS_ID(A,B)
    TYPE (AD02_REAL) :: MINUS_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MINUS_ID,MINUS_RD(REAL(A,WP),B))
  END FUNCTION MINUS_ID
  FUNCTION MINUS_RD(A,B)
    TYPE (AD02_REAL) :: MINUS_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    MINUS_RD%DATA => DATA
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(MINUS_RD,B,'-')
    ELSE IF (B%DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(MINUS_RD,B,'-')
    ELSE
      MINUS_RD%CASE = -DATA%CASE
      IF (B%CASE<0) THEN
        DATA%GRAPH(B%P)%RVAL = A - DATA%GRAPH(B%P)%RVAL
        MINUS_RD%P = B%P
        IF (DATA%GRAPH(B%P)%ONUM==2) THEN
          DATA%GRAPH(B%P)%RVALS = -DATA%GRAPH(B%P)%RVALS
          IF (DATA%LEVEL==2) DATA%DER2(:,B%P)  = -DATA%DER2(:,B%P)
        ELSE
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(B%P)%RVALS = -DATA%GRAPH(B%P)%RVALS
          ELSE
            DATA%GRAPH(B%P)%RVALS(0) = -DATA%GRAPH(B%P)%RVALS(0)
          END IF
        END IF
      ELSE
        MINUS_RD%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES)%RVAL = A-DATA%GRAPH(B%P)%RVAL
        DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = -1.0_WP
        DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
        DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
        DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = B%P
        DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION MINUS_RD
  FUNCTION MINUS_SD(A,B)
    TYPE (AD02_REAL) :: MINUS_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MINUS_SD,MINUS_RD(REAL(A,WP),B))
  END FUNCTION MINUS_SD
  FUNCTION MULT_DD(A,B)
    TYPE (AD02_REAL) :: MULT_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    REAL (WP) VA, VB
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MULT_DD%DATA => DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(MULT_DD,A,B,'*')
    ELSE IF (.NOT.ASSOCIATED(A%DATA,B%DATA)) THEN
      CALL BINARY_WARNING(MULT_DD,A,B,'*')
    ELSE IF (DATA%CASE/=ABS(A%CASE)  .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(MULT_DD,A,B,'*')
    ELSE
      MULT_DD%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      VB = DATA%GRAPH(B%P)%RVAL
      MULT_DD%P = DATA%NUM_NODES
      DATA%GRAPH(DATA%NUM_NODES)%RVAL = VA*VB
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = VB
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = VA
      DATA%GRAPH(DATA%NUM_NODES)%ONUM = 2
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = B%P
      IF (DATA%LEVEL==2) THEN
        DATA%DER2(0,DATA%NUM_NODES) = 0.0_WP
        DATA%DER2(1,DATA%NUM_NODES) = 1.0_WP
        DATA%DER2(2,DATA%NUM_NODES) = 0.0_WP
      END IF
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END FUNCTION MULT_DD
  FUNCTION MULT_DI(A,B)
    TYPE (AD02_REAL) :: MULT_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    CALL COPY(MULT_DI,MULT_DR(A,REAL(B,WP)))
  END FUNCTION MULT_DI
  FUNCTION MULT_DR(A,B)
    TYPE (AD02_REAL) :: MULT_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MULT_DR%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(MULT_DR,A,'*')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(MULT_DR,A,'*')
    ELSE
      MULT_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
        MULT_DR%P = A%P
        DATA%GRAPH(A%P)%RVAL = DATA%GRAPH(A%P)%RVAL*B
        IF (DATA%GRAPH(A%P)%ONUM==2) THEN
          DATA%GRAPH(A%P)%RVALS = DATA%GRAPH(A%P)%RVALS*B
          IF (DATA%LEVEL==2) DATA%DER2(:,A%P)  = DATA%DER2(:,A%P) *B
        ELSE
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(A%P)%RVALS = DATA%GRAPH(A%P)%RVALS*B
          ELSE
            DATA%GRAPH(A%P)%RVALS(0) = DATA%GRAPH(A%P)%RVALS(0)*B
          END IF
        END IF
      ELSE
        MULT_DR%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES)%RVAL = DATA%GRAPH(A%P)%RVAL*B
        DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = B
        DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
        DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
        DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
        DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION MULT_DR
  FUNCTION MULT_DS(A,B)
    TYPE (AD02_REAL) :: MULT_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MULT_DS,MULT_DR(A,REAL(B,WP)))
  END FUNCTION MULT_DS
  FUNCTION MULT_ID(A,B)
    TYPE (AD02_REAL) :: MULT_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MULT_ID,MULT_DR(B,REAL(A,WP)))
  END FUNCTION MULT_ID
  FUNCTION MULT_RD(A,B)
    TYPE (AD02_REAL) MULT_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MULT_RD,MULT_DR(B,A))
  END FUNCTION MULT_RD
  FUNCTION MULT_SD(A,B)
    TYPE (AD02_REAL) MULT_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MULT_SD,MULT_DR(B,REAL(A,WP)))
  END FUNCTION MULT_SD
  FUNCTION NE_DD(A,B)
    LOGICAL :: NE_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DD = .TRUE.
    ELSE
      NE_DD = DATA%GRAPH(A%P)%RVAL /= DATA%GRAPH(B%P)%RVAL
      IF ( .NOT.NE_DD) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_DD
  FUNCTION NE_DI(A,B)
    LOGICAL :: NE_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DI = .TRUE.
    ELSE
      NE_DI = DATA%GRAPH(A%P)%RVAL /= B
      IF ( .NOT. (NE_DI)) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_DI
  FUNCTION NE_DR(A,B)
    LOGICAL :: NE_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DR = .TRUE.
    ELSE
      NE_DR = DATA%GRAPH(A%P)%RVAL /= B
      IF ( .NOT. (NE_DR)) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_DR
  FUNCTION NE_DS(A,B)
    LOGICAL :: NE_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DS = .TRUE.
    ELSE
      NE_DS = DATA%GRAPH(A%P)%RVAL /= B
      IF ( .NOT. (NE_DS)) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_DS
  FUNCTION NE_ID(A,B)
    LOGICAL :: NE_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_ID = .TRUE.
    ELSE
      NE_ID = A /= DATA%GRAPH(B%P)%RVAL
      IF ( .NOT. (NE_ID)) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_ID
  FUNCTION NE_RD(A,B)
    LOGICAL :: NE_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_RD = .TRUE.
    ELSE
      NE_RD = A /= DATA%GRAPH(B%P)%RVAL
      IF ( .NOT. (NE_RD)) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_RD
  FUNCTION NE_SD(A,B)
    LOGICAL :: NE_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_SD = .TRUE.
    ELSE
      NE_SD = A /= DATA%GRAPH(B%P)%RVAL
      IF ( .NOT. (NE_SD)) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_SD
  FUNCTION NINT_D(A)
    TYPE (AD02_REAL) NINT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    NINT_D%DATA => DATA
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'NINT')
      NINT_D = 0
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'NINT')
      NINT_D = 0
    ELSE
      NINT_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      IF (ABS(VA-AINT(VA))*2.0_WP==1.0_WP) CALL ERROR_HANDLER(DATA,NINT_WARN)
      NINT_D = NINT(VA)
    END IF
  END FUNCTION NINT_D
  FUNCTION POW_DD(A,B)
    TYPE (AD02_REAL) :: POW_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    INTEGER P
    REAL (WP) VA, VB, VC, LVA, FD
    LOGICAL INTEG
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    POW_DD%DATA => DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(POW_DD,A,B,'**')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(POW_DD,A,B,'**')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(POW_DD,A,B,'**')
    ELSE
      POW_DD%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      VB = DATA%GRAPH(B%P)%RVAL
      IF (VA<=0.0_WP) THEN
        CALL ERROR_HANDLER(DATA,POW1_ERR)
        CALL AD02_UNDEFINE(POW_DD,DATA)
        RETURN
      END IF
      IF (VB==ANINT(VB)) THEN
        P = NINT(VB)
        INTEG = .TRUE.
        VC = VA**P
      ELSE
        INTEG = .FALSE.
        VC = VA**VB
      END IF
      IF (INTEG) THEN
        FD = VB*VA**(P-1)
      ELSE
        FD = VB*VA**(VB-D1)
      END IF
      LVA = LOG(VA)
      POW_DD%P = DATA%NUM_NODES
      DATA%GRAPH(DATA%NUM_NODES) = NODE(VC,(/FD,VC*LVA/),2,(/A%P,B%P/))
      IF (DATA%LEVEL==2) THEN
        DATA%DER2(0,DATA%NUM_NODES) = (VB*VB-VB)*VA**(VB-D2)
        DATA%DER2(1,DATA%NUM_NODES) = VA**(VB-D1)*(LVA*VB+D1)
        DATA%DER2(2,DATA%NUM_NODES) = VC*LVA*LVA
      END IF
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END FUNCTION POW_DD
  FUNCTION POW_DI(A,B)
    TYPE (AD02_REAL) :: POW_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    REAL (WP) VA, SD, FD
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    POW_DI%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(POW_DI,A,'**')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(POW_DI,A,'**')
    ELSE
      POW_DI%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      IF (B==1) THEN
        FD = 1
      ELSE
        FD = B*VA**(B-1)
      END IF
      IF (DATA%LEVEL==2) THEN
        IF (B==1) THEN
          SD = 0.0_WP
        ELSE IF (B==2) THEN
          SD = B*B - B
        ELSE
          SD = (B*B-B)*VA**(B-2)
        END IF
        IF (A%CASE<0) THEN
          CALL CONDENSE_NODE(DATA,VA**B,A%P,FD,SD,POW_DI)
        ELSE
          POW_DI%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VA**B,(/FD,SD/),1,(/A%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        IF (A%CASE<0) THEN
          CALL CONDENSE_NODE(DATA,VA**B,A%P,FD,D0,POW_DI)
        ELSE
          POW_DI%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES)%RVAL = VA**B
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = FD
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
          DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION POW_DI
  FUNCTION POW_DR(A,B)
    TYPE (AD02_REAL) :: POW_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    REAL (WP) SD, FD, VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    POW_DR%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(POW_DR,A,'**')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(POW_DR,A,'**')
    ELSE
      POW_DR%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      IF ((VA==0.0_WP) .AND. (B/=INT(B)) .AND. (B<DATA%LEVEL)) THEN
        CALL ERROR_HANDLER(DATA,POW2_ERR)
        CALL AD02_UNDEFINE(POW_DR,DATA)
        RETURN
      END IF
      IF (B==1) THEN
        FD = 1
      ELSE
        FD = B*VA**(B-1)
      END IF
      IF (DATA%LEVEL==2) THEN
        IF (B==1) THEN
          SD = 0.0_WP
        ELSE IF (B==2) THEN
          SD = B*B - B
        ELSE
          SD = (B*B-B)*VA**(B-2)
        END IF
        IF (A%CASE<0) THEN
          CALL CONDENSE_NODE(DATA,VA**B,A%P,FD,SD,POW_DR)
        ELSE
          POW_DR%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VA**B,(/FD,SD/),1,(/A%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        IF (A%CASE<0) THEN
          CALL CONDENSE_NODE(DATA,VA**B,A%P,FD,D0,POW_DR)
        ELSE
          POW_DR%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VA**B,(/FD,0.0_WP/),1,(/A%P,0/))
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION POW_DR
  FUNCTION POW_DS(A,B)
    TYPE (AD02_REAL) :: POW_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(POW_DS,POW_DR(A,REAL(B,WP)))
  END FUNCTION POW_DS
  FUNCTION POW_ID(A,B)
    TYPE (AD02_REAL) :: POW_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(POW_ID,POW_RD(REAL(A,WP),B))
  END FUNCTION POW_ID
  FUNCTION POW_RD(A,B)
    TYPE (AD02_REAL) :: POW_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL (WP) RB, LVA, VC, FD
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    POW_RD%DATA => DATA
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(POW_RD,B,'**')
    ELSE IF (B%DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(POW_RD,B,'**')
    ELSE
      POW_RD%CASE = -DATA%CASE
      IF (A<=0.0_WP) THEN
        CALL ERROR_HANDLER(DATA,POW1_ERR)
        CALL AD02_UNDEFINE(POW_RD,DATA)
        RETURN
      END IF
      RB = DATA%GRAPH(B%P)%RVAL
      VC = A**RB
      LVA = LOG(A)
      FD = VC*LVA
      IF (DATA%LEVEL==2) THEN
        IF (B%CASE<0) THEN
          CALL CONDENSE_NODE(DATA,VC,B%P,FD,FD*LVA,POW_RD)
        ELSE
          POW_RD%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VC,(/FD,FD*LVA/),1,(/B%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        IF (B%CASE<0) THEN
          CALL CONDENSE_NODE(DATA,VC,B%P,FD,0.0_WP,POW_RD)
        ELSE
          POW_RD%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VC,(/FD,0.0_WP/),1,(/B%P,0/))
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION POW_RD
  FUNCTION POW_SD(A,B)
    TYPE (AD02_REAL) :: POW_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(POW_SD,POW_RD(REAL(A,WP),B))
  END FUNCTION POW_SD
  FUNCTION REAL_D(A)
    TYPE (AD02_REAL), INTENT (IN) :: A
    TYPE (AD02_REAL) REAL_D
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    REAL_D%DATA => DATA
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(REAL_D,A,'DBLE')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(REAL_D,A,'DBLE')
    ELSE
      REAL_D = A
    END IF
  END FUNCTION REAL_D
  FUNCTION SIGN_DD(A,B)
    TYPE (AD02_REAL) :: SIGN_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    REAL (WP) VB,RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    SIGN_DD%DATA => DATA
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(SIGN_DD,A,B,'SIGN')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(SIGN_DD,A,B,'SIGN')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(SIGN_DD,A,B,'SIGN')
    ELSE
      SIGN_DD%CASE = -DATA%CASE
      VB = DATA%GRAPH(B%P)%RVAL
      IF (VB>0.0_WP) THEN
        CALL COPY(SIGN_DD,ABS(A))
      ELSE IF (VB<0.0_WP) THEN
        CALL COPY(SIGN_DD,-ABS(A))
      ELSE
        CALL ERROR_HANDLER(DATA,SIGN_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(SIGN_DD,(RAND+RAND-1.0_WP)*ABS(A))
      END IF
    END IF
  END FUNCTION SIGN_DD
  FUNCTION SIGN_DR(A,B)
    TYPE (AD02_REAL) :: SIGN_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(SIGN_DR,A,'SIGN')
    ELSE IF (A%DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(SIGN_DR,A,'SIGN')
    ELSE
      IF (B>=0.0_WP) THEN
        CALL COPY(SIGN_DR,ABS(A))
      ELSE
        CALL COPY(SIGN_DR,-ABS(A))
      END IF
    END IF
  END FUNCTION SIGN_DR
  FUNCTION SIGN_DS(A,B)
    TYPE (AD02_REAL) :: SIGN_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(SIGN_DS,SIGN_DR(A,REAL(B,WP)))
  END FUNCTION SIGN_DS
  FUNCTION SIGN_RD(A,B)
    TYPE (AD02_REAL) :: SIGN_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL (WP) VB, RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    SIGN_RD%DATA => DATA
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(SIGN_RD,B,'SIGN')
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(SIGN_RD,B,'SIGN')
    ELSE
      SIGN_RD%CASE = -DATA%CASE
      VB = DATA%GRAPH(B%P)%RVAL
      SIGN_RD%P = DATA%NUM_NODES
      IF (VB>0.0_WP) THEN
        DATA%GRAPH(DATA%NUM_NODES) = NODE(ABS(A),(/0.0_WP,0.0_WP/),0,(/1,0/))
      ELSE IF (VB<0.0_WP) THEN
        DATA%GRAPH(DATA%NUM_NODES) = NODE(-ABS(A),(/0.0_WP,0.0_WP/),0,(/1,0/))
      ELSE
        CALL ERROR_HANDLER(DATA,SIGN_WARN)
        CALL RANDOM_NUMBER(RAND)
        DATA%GRAPH(DATA%NUM_NODES) =  NODE &
             ((RAND+RAND-1.0_WP)*ABS(A),(/0.0_WP,0.0_WP/),0,(/1,0/))
      END IF
      IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
   END IF
  END FUNCTION SIGN_RD
  FUNCTION SIGN_SD(A,B)
    TYPE (AD02_REAL) :: SIGN_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(SIGN_SD,SIGN_RD(REAL(A,WP),B))
  END FUNCTION SIGN_SD
  FUNCTION SIN_D(X)
    TYPE (AD02_REAL) :: SIN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, V
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    SIN_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(SIN_D,X,'SIN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(SIN_D,X,'SIN')
    ELSE
      SIN_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = SIN(VA)
      IF (X%CASE<0) THEN
        CALL CONDENSE_NODE(DATA,V,X%P,COS(VA),-V,SIN_D)
      ELSE
        SIN_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/COS(VA),-V/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/COS(VA),0.0_WP/),1,(/X%P,0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION SIN_D
  FUNCTION SINH_D(X)
    TYPE (AD02_REAL) :: SINH_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, V
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    SINH_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(SINH_D,X,'SINH')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(SINH_D,X,'SINH')
    ELSE
      SINH_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = SINH(VA)
      IF (X%CASE<0) THEN
        CALL CONDENSE_NODE(DATA,V,X%P,COSH(VA),V,SINH_D)
      ELSE
        SINH_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/COSH(VA),V/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/COSH(VA),0.0_WP/),1,(/X%P,0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION SINH_D
  FUNCTION SQRT_D(X)
    TYPE (AD02_REAL) :: SQRT_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, VB
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    SQRT_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(SQRT_D,X,'SQRT')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(SQRT_D,X,'SQRT')
    ELSE
      SQRT_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      IF (VA==D0) THEN
        CALL ERROR_HANDLER(DATA,SQRT_ERR)
        CALL AD02_UNDEFINE(SQRT_D,DATA)
        RETURN
      END IF
      VB = SQRT(VA)
      IF (X%CASE<0) THEN
        IF (DATA%LEVEL==2) THEN
          CALL CONDENSE_NODE(DATA,VB,X%P,D1/(D2*VB),-D1/(4.0_WP*VB*VA),SQRT_D)
        ELSE
          CALL CONDENSE_NODE(DATA,VB,X%P,D1/(D2*VB),D0,SQRT_D)
        END IF
      ELSE
        SQRT_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) =  &
              NODE(VB,(/D1/(D2*VB),-D1/(4.0_WP*VB*VA)/),1, (/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES)%RVAL = VB
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = D1/(D2*VB)
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
          DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = X%P
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION SQRT_D
  FUNCTION TAN_D(X)
    TYPE (AD02_REAL) :: TAN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) V, V1
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    TAN_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(TAN_D,X,'TAN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(TAN_D,X,'TAN')
    ELSE
      TAN_D%CASE = -DATA%CASE
      V = TAN(DATA%GRAPH(X%P)%RVAL)
      V1 = D1 + V**2
      IF (X%CASE<0) THEN
        IF (DATA%LEVEL==2) THEN
          CALL CONDENSE_NODE(DATA,V,X%P,V1,D2*V*V1,TAN_D)
        ELSE
          CALL CONDENSE_NODE(DATA,V,X%P,V1,D0,TAN_D)
        END IF
      ELSE
        TAN_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/V1,D2*V*V1/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/V1,0.0_WP/),1,(/X%P,0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION TAN_D
  FUNCTION TANH_D(X)
    TYPE (AD02_REAL) :: TANH_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) V, V2
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    TANH_D%DATA => DATA
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(TANH_D,X,'TANH')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(TANH_D,X,'TANH')
    ELSE
      TANH_D%CASE = -DATA%CASE
      V = TANH(DATA%GRAPH(X%P)%RVAL)
      V2 = D1 - V*V
      IF (X%CASE<0) THEN
        IF (DATA%LEVEL==2) THEN
          CALL CONDENSE_NODE(DATA,V,X%P,V2,-D2*V*V2,TANH_D)
        ELSE
          CALL CONDENSE_NODE(DATA,V,X%P,V2,D0,TANH_D)
        END IF
      ELSE
        TANH_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/V2,-D2*V*V2/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/V2,0.0_WP/),1,(/X%P,0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION TANH_D
  SUBROUTINE BINARY_WARNING(FUN,A,B,PROC)
    TYPE (AD02_REAL), INTENT (OUT) :: FUN
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    CHARACTER(*), OPTIONAL, INTENT(IN) :: PROC
    IF (ASSOCIATED(A%DATA) ) THEN
      CALL ERROR_HANDLER(A%DATA,UNDEF_WARN,PROC)
      FUN%DATA => A%DATA
    END IF
    IF (.NOT.ASSOCIATED(A%DATA,B%DATA) )THEN
      CALL ERROR_HANDLER(B%DATA,UNDEF_WARN,PROC)
      IF (ASSOCIATED(B%DATA) ) FUN%DATA => B%DATA
    END IF
    FUN%P = -1
  END SUBROUTINE BINARY_WARNING
  SUBROUTINE CONDENSE_NODE(DATA,V,LHO,E1,E1D1,C)
    TYPE(AD02_DATA), INTENT(INOUT) :: DATA
    INTEGER, INTENT (IN) :: LHO
    REAL (WP), INTENT (IN) :: V, E1, E1D1
    TYPE (AD02_REAL), INTENT (INOUT) :: C
    DATA%GRAPH(LHO)%RVAL = V
    IF (DATA%GRAPH(LHO)%ONUM==2) THEN
      IF (DATA%LEVEL==2) THEN
        DATA%DER2(1,LHO) = E1*DATA%DER2(1,LHO) + &
          E1D1*DATA%GRAPH(LHO)%RVALS(0)*DATA%GRAPH(LHO)%RVALS(1)
        DATA%DER2(0,LHO) = E1D1*DATA%GRAPH(LHO)%RVALS(0)**2 + &
                           E1*DATA%DER2(0,LHO)
        DATA%DER2(2,LHO) = E1D1*DATA%GRAPH(LHO)%RVALS(1)**2 + &
                           E1*DATA%DER2(2,LHO)
      END IF
      DATA%GRAPH(LHO)%RVALS = E1*DATA%GRAPH(LHO)%RVALS
    ELSE
      IF (DATA%LEVEL==2) DATA%GRAPH(LHO)%RVALS(1) = &
                         E1D1*DATA%GRAPH(LHO)%RVALS(0)**2 + &
                         DATA%GRAPH(LHO)%RVALS(1)*E1
      DATA%GRAPH(LHO)%RVALS(0) = E1*DATA%GRAPH(LHO)%RVALS(0)
    END IF
    C%P = LHO
  END SUBROUTINE CONDENSE_NODE
  SUBROUTINE CONTROL1(LP,MP,PRINT_LEVEL,STOP_LEVEL)
    INTEGER, OPTIONAL, INTENT (IN) :: LP
    INTEGER, OPTIONAL, INTENT (IN) :: MP
    INTEGER, OPTIONAL, INTENT (IN) :: PRINT_LEVEL
    INTEGER, OPTIONAL, INTENT (IN) :: STOP_LEVEL
    IF (PRESENT(LP)) ERROR_MESSAGE_UNIT = LP
    IF (PRESENT(MP)) WARNING_MESSAGE_UNIT = MP
    IF (PRESENT(PRINT_LEVEL)) ERROR_PRINT_LEVEL = PRINT_LEVEL
    IF (PRESENT(STOP_LEVEL)) ERROR_STOP_LEVEL = STOP_LEVEL
  END SUBROUTINE CONTROL1
  SUBROUTINE CONTROL2(DATA,ERROR,LP,MP,PRINT_LEVEL,STOP_LEVEL)
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: LP
    INTEGER, OPTIONAL, INTENT (IN) :: MP
    INTEGER, OPTIONAL, INTENT (IN) :: PRINT_LEVEL
    INTEGER, OPTIONAL, INTENT (IN) :: STOP_LEVEL
    IF(ASSOCIATED(DATA))THEN
      ERROR = 0
      IF (PRESENT(LP)) DATA%ERROR_MESSAGE_UNIT = LP
      IF (PRESENT(MP)) DATA%WARNING_MESSAGE_UNIT = MP
      IF (PRESENT(PRINT_LEVEL)) DATA%ERROR_PRINT_LEVEL = PRINT_LEVEL
      IF (PRESENT(STOP_LEVEL)) DATA%ERROR_STOP_LEVEL = STOP_LEVEL
    ELSE
      ERROR = 2
    END IF
  END SUBROUTINE CONTROL2
  SUBROUTINE COPY(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    A%P = B%P
    A%CASE = B%CASE
    A%DATA => B%DATA
  END SUBROUTINE COPY
  LOGICAL FUNCTION DATA_UNDEFINED(X)
    TYPE (AD02_REAL), INTENT (IN) :: X
    IF(ASSOCIATED(X%DATA)) THEN
      DATA_UNDEFINED = X%P==-1 .OR. X%DATA%CASE/=ABS(X%CASE)
      IF (X%DATA%CASE==-1) DATA_UNDEFINED = .FALSE.
    ELSE
      DATA_UNDEFINED = .FALSE.
    END IF
  END FUNCTION DATA_UNDEFINED
  SUBROUTINE DERIVS_S(A,R,INDEX,DERIVS,ERROR)
!?? To obtain the derivatives of a dependant variable in a packed form.
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: R
    INTEGER, POINTER, DIMENSION (:) :: INDEX
    REAL (WP), POINTER, DIMENSION (:) :: DERIVS
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER I
    TYPE(AD02_DATA), POINTER :: DATA
    ERROR = 0
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    ELSE IF (R<0 .OR. R>A%DATA%LEVEL) THEN
      ERROR = 4
    END IF
    IF(ERROR>0)RETURN
    DATA => A%DATA
    ALLOCATE (INDEX(DATA%SIZE_X))
    DO I = 1, DATA%SIZE_X
        INDEX(I) = I
    END DO
    IF (R==0) THEN
      ALLOCATE (DERIVS(1))
      CALL AD02_VALUE(A,DERIVS(1),ERROR)
    ELSE IF (R==1) THEN
      ALLOCATE (DERIVS(DATA%SIZE_X))
      CALL GETDER(DATA,A%P,DERIVS)
    ELSE
      ALLOCATE (DERIVS(DATA%SIZE_X*(DATA%SIZE_X+1)/2))
      CALL GETHES(DATA,A%P,DERIVS,SIZE(DERIVS),.TRUE.)
    END IF
  END SUBROUTINE DERIVS_S
  SUBROUTINE ERROR_HANDLER(DATA,ERROR_NUMBER,PROC)
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, INTENT(IN) :: ERROR_NUMBER
    CHARACTER(*), OPTIONAL, INTENT(IN) :: PROC
    IF(ASSOCIATED(DATA))THEN
      DATA%FLAGS(ERROR_NUMBER) = DATA%FLAGS(ERROR_NUMBER) + 1
    ELSE
      AD02_FLAG(ERROR_NUMBER) = AD02_FLAG(ERROR_NUMBER) + 1
    END IF
    SELECT CASE (ERROR_NUMBER)
    CASE (1)
      CALL ERR_MESS_PRINT(DATA,'ERROR: Invalid call of AD02_INITIALIZE.', &
       .FALSE.)
    CASE (2)
      CALL ERR_MESS_PRINT(DATA, &
        'ERROR: Procedure call without prior AD02_INITIALIZE call.',.FALSE.)
    CASE (3)
      CALL ERR_MESS_PRINT(DATA, &
        'ERROR: Insufficient storage(failure of an ALLOCATE statment).', &
        .FALSE.)
    CASE (4)
      CALL ERR_MESS_PRINT(DATA,'ERROR: Invalid call of AD02_RESTORE',.FALSE.)
    CASE (5)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of SQRT(A) when A is of type AD02_REAL and has     &
     &         value 0.',.TRUE.)
    CASE (6)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of A**B when A and B are of type AD02_REAL, and A  &
     &         has a non-positive value.',.TRUE.)
    CASE (7)
      CALL ERR_MESS_PRINT(DATA, &
     'WARNING: Calculation of A**B when A is of type AD02_REAL, and B is of   &
     &         type REAL, A has value 0, and b has a non-integer value less   &
     &         than DEGREE.',.TRUE.)
    CASE (8)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of SIGN(A,B) when B is of type AD02_REAL and has   &
     &         value 0.',.TRUE.)
    CASE (9)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of ABS(A) or SIGN(A,B) when A is of type AD02_REAL &
     &         and has value 0.',.TRUE.)
    CASE (10)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of INT(A) when A is of type AD02_REAL and has an   &
     &         integer value.',.TRUE.)
    CASE (11)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of AINT(A) when A is of type AD02_REAL and has an  &
     &         integer value.',.TRUE.)
    CASE (12)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of NINT(A) when A is of type AD02_REAL and has a   &
     &         value n + 0.5, where n is an integer.',.TRUE.)
    CASE (13)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of ANINT(A) when A is of type AD02_REAL and has a  &
     &         value n + 0.5, where n is an integer.',.TRUE.)
    CASE (14)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of MAX(A,B) when at least one of A and B is of     &
     &         type AD02_REAL and A has the same value as B.', .TRUE.)
    CASE (15)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of MIN(A,B) when at least one of A and B is of     &
     &         type AD02_REAL and A has the same value as B.', .TRUE.)
    CASE (16)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A==B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (17)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A/=B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (18)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A>B when at least one of A and B is of type      &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (19)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A<B when at least one of A and B is of type      &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (20)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A>=B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (21)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A<=B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (33)
      CALL ERR_MESS_PRINT(DATA, &
        'WARNING: Execution of '//PROC//' for value AD02_UNDEFINED.', .TRUE.)
    CASE (34)
      CALL ERR_MESS_PRINT(DATA, &
        'WARNING: Assignment to array of type AD02_REAL', .TRUE.)
    END SELECT
  CONTAINS
    SUBROUTINE ERR_MESS_PRINT(DATA,ERROR_MESSAGE,WARNING)
      TYPE(AD02_DATA),POINTER :: DATA
      CHARACTER (LEN=*), INTENT (IN) :: ERROR_MESSAGE
      LOGICAL, INTENT (IN) :: WARNING
      INTEGER :: I,J
      IF(ASSOCIATED(DATA))THEN
        IF (WARNING) THEN
          IF (DATA%ERROR_PRINT_LEVEL==2) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (DATA%ERROR_STOP_LEVEL==2) STOP 'AD02 EXECUTION HALTED'
        ELSE
          IF (DATA%ERROR_PRINT_LEVEL/=0) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (DATA%ERROR_STOP_LEVEL/=0) STOP 'AD02 EXECUTION HALTED'
        END IF
      ELSE
        IF (WARNING) THEN
          IF (ERROR_PRINT_LEVEL==2) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (ERROR_STOP_LEVEL==2) STOP 'AD02 EXECUTION HALTED'
        ELSE
          IF (ERROR_PRINT_LEVEL/=0) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (ERROR_STOP_LEVEL/=0) STOP 'AD02 EXECUTION HALTED'
        END IF
      END IF
    END SUBROUTINE ERR_MESS_PRINT
  END SUBROUTINE ERROR_HANDLER
  SUBROUTINE FINALIZE(DATA,ERROR)
     TYPE(AD02_DATA), POINTER :: DATA
     INTEGER, INTENT (OUT) :: ERROR
     INTEGER STAT(3)
     ERROR = 0
     IF(.NOT.ASSOCIATED(DATA))THEN
        ERROR = 1
        RETURN
     END IF
     STAT = 0
     IF(ASSOCIATED(DATA%GRAPH)) DEALLOCATE(DATA%GRAPH,STAT=STAT(1))
     IF(ASSOCIATED(DATA%DER2)) DEALLOCATE(DATA%DER2,STAT=STAT(2))
     IF(ASSOCIATED(DATA%FLAGS)) DEALLOCATE(DATA%FLAGS,STAT=STAT(3))
     DATA%CASE = -1
     DATA%MAX_NODES = 0
     DATA%MAX_NODES2 = 0
     IF(ANY(STAT/=0))ERROR = 3
  END SUBROUTINE FINALIZE
  SUBROUTINE FLAGS1(L,FLAG,ERROR,RESET)
     INTEGER, INTENT(IN) :: L
     INTEGER, INTENT(OUT) :: FLAG,ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40) THEN
        ERROR = 1
     ELSE
        ERROR = 0
        FLAG = AD02_FLAG(L)
        IF(PRESENT(RESET)) THEN
          IF(RESET)AD02_FLAG(L)=0
        END IF
     END IF
  END SUBROUTINE FLAGS1
  SUBROUTINE FLAGS2(L,U,FLAG,ERROR,RESET)
     INTEGER, INTENT(IN) :: L,U
     INTEGER, INTENT(OUT) :: FLAG(L:U),ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40 .OR. U<1 .OR. U>40) THEN
        ERROR = 1
     ELSE
        ERROR = 0
        FLAG(L:U) = AD02_FLAG(L:U)
        IF(PRESENT(RESET)) THEN
          IF(RESET)AD02_FLAG(L:U)=0
        END IF
     END IF
  END SUBROUTINE FLAGS2
  SUBROUTINE FLAGS3(DATA,L,FLAG,ERROR,RESET)
     TYPE(AD02_DATA),POINTER :: DATA
     INTEGER, INTENT(IN) :: L
     INTEGER, INTENT(OUT) :: FLAG,ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40) THEN
        ERROR = 1
     ELSE IF (.NOT.ASSOCIATED(DATA))THEN
        ERROR = 2
     ELSE IF (.NOT.ASSOCIATED(DATA%FLAGS))THEN
        ERROR = 3
     ELSE
        ERROR = 0
        FLAG = DATA%FLAGS(L)
        IF(PRESENT(RESET)) THEN
          IF(RESET)DATA%FLAGS(L)=0
        END IF
     END IF
  END SUBROUTINE FLAGS3
  SUBROUTINE FLAGS4(DATA,L,U,FLAG,ERROR,RESET)
     TYPE(AD02_DATA),POINTER :: DATA
     INTEGER, INTENT(IN) :: L,U
     INTEGER, INTENT(OUT) :: FLAG(L:U),ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40 .OR. U<1 .OR. U>40) THEN
        ERROR = 1
     ELSE IF (.NOT.ASSOCIATED(DATA))THEN
        ERROR = 2
     ELSE IF (.NOT.ASSOCIATED(DATA%FLAGS))THEN
        ERROR = 3
     ELSE
        ERROR = 0
        FLAG(L:U) = DATA%FLAGS(L:U)
        IF(PRESENT(RESET)) THEN
          IF(RESET)DATA%FLAGS(L:U)=0
        END IF
     END IF
  END SUBROUTINE FLAGS4
  SUBROUTINE GETDER(DATA,IF,DF)
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, INTENT (IN) :: IF
    REAL (WP), INTENT (OUT) :: DF(:)
    REAL (WP), ALLOCATABLE :: RRES(:)
    INTEGER I, PC, STAT
    REAL (WP) R
    ALLOCATE (RRES(DATA%NUM_NODES),STAT=STAT)
    IF (STAT/=0) THEN
      CALL ERROR_HANDLER(DATA,ALLOC_ERR)
      RETURN
    END IF
    RRES(1:DATA%SIZE_X) = D0
    RRES(DATA%SIZE_X+1:IF-1) = D0
    RRES(IF) = D1
    DO I = IF, DATA%SIZE_X + 1, -1
      R = RRES(I)
      IF (R/=D0) THEN
        IF (DATA%GRAPH(I)%ONUM==2) THEN
          PC = DATA%GRAPH(I)%IPTRS(0)
          RRES(PC) = RRES(PC) + R*DATA%GRAPH(I)%RVALS(0)
          PC = DATA%GRAPH(I)%IPTRS(1)
          RRES(PC) = RRES(PC) + R*DATA%GRAPH(I)%RVALS(1)
        ELSE
          PC = DATA%GRAPH(I)%IPTRS(0)
          RRES(PC) = RRES(PC) + R*DATA%GRAPH(I)%RVALS(0)
        END IF
      END IF
    END DO
    DF(1:DATA%SIZE_X) = RRES(1:DATA%SIZE_X)
    DEALLOCATE (RRES)
  END SUBROUTINE GETDER
  SUBROUTINE GETHES(DATA,IF,DF2,LENG,PACKED,G)
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, INTENT (IN) :: IF, LENG
    REAL (WP), INTENT (OUT) :: DF2(LENG)
    LOGICAL, INTENT (IN) :: PACKED
    REAL (WP), OPTIONAL, INTENT (OUT) :: G(:)
    INTEGER I, NC, PC, J, PC1, STAT, START_POINTER
    REAL (WP) R, R1, RR ,I1, I2
    REAL (WP), ALLOCATABLE :: RRES(:), RRES2(:), RRES3(:)
    START_POINTER = 0
    ALLOCATE (RRES(DATA%NUM_NODES),RRES2(DATA%NUM_NODES),RRES3(DATA%NUM_NODES),S
    IF (STAT/=0) THEN
      CALL ERROR_HANDLER(DATA,ALLOC_ERR)
      RETURN
    END IF
    RRES(1:DATA%SIZE_X) = D0
    RRES(DATA%SIZE_X+1:IF-1) = D0
    RRES(IF) = D1
    DO I = IF, DATA%SIZE_X+1, -1
      R = RRES(I)
      IF (R/=D0) THEN
        IF (DATA%GRAPH(I)%ONUM==2) THEN
          RRES(DATA%GRAPH(I)%IPTRS(0)) = RRES(DATA%GRAPH(I)%IPTRS(0))+R*DATA%GRA
          RRES(DATA%GRAPH(I)%IPTRS(1)) = RRES(DATA%GRAPH(I)%IPTRS(1))+R*DATA%GRA
        ELSE
          PC = DATA%GRAPH(I)%IPTRS(0)
          RRES(PC) = RRES(PC) + R*DATA%GRAPH(I)%RVALS(0)
        END IF
      END IF
    END DO
    IF (PRESENT(G)) THEN
      G(1:DATA%SIZE_X) = RRES(1:DATA%SIZE_X)
    END IF
    DO J = 1, DATA%SIZE_X
      RRES2(1:DATA%SIZE_X) = D0
      RRES3(1:MAX(IF,DATA%SIZE_X)) = D0
      RRES2(J) = D1
      DO I = DATA%SIZE_X + 1,IF
        RR = D0
        NC = DATA%GRAPH(I)%ONUM
          R = RRES(I)
          IF (NC==2) THEN
            RR = RRES2(DATA%GRAPH(I)%IPTRS(0))*DATA%GRAPH(I)%RVALS(0) + &
              RRES2(DATA%GRAPH(I)%IPTRS(1))*DATA%GRAPH(I)%RVALS(1)
            IF (R/=D0) THEN
              PC1 = DATA%GRAPH(I)%IPTRS(0)
              R1 = RRES3(PC1)
              I1 = RRES2(DATA%GRAPH(I)%IPTRS(0))
              I2 = RRES2(DATA%GRAPH(I)%IPTRS(1))
              R1 = R1 + R*(I1*DATA%DER2(0,I) + I2*DATA%DER2(1,I))
              RRES3(PC1) = R1
              PC1 = DATA%GRAPH(I)%IPTRS(1)
              R1 = RRES3(PC1)
              R1 = R1 + R*(I1*DATA%DER2(1,I) + I2*DATA%DER2(2,I))
              RRES3(PC1) = R1
            END IF
          ELSE
            RR = RRES2(DATA%GRAPH(I)%IPTRS(0))*DATA%GRAPH(I)%RVALS(0)
            IF (R/=D0) THEN
              PC1 = DATA%GRAPH(I)%IPTRS(0)
              R1 = RRES3(PC1)
              R1 = R1 + R*RRES2(DATA%GRAPH(I)%IPTRS(0))*DATA%GRAPH(I)%RVALS(1)
              RRES3(PC1) = R1
            END IF
          END IF
        RRES2(I) = RR
      END DO
      DO I = IF, 1, -1
        R = RRES3(I)
        IF (R/=D0) THEN
          IF (DATA%GRAPH(I)%ONUM==2) THEN
            RRES3(DATA%GRAPH(I)%IPTRS(0)) = RRES3(DATA%GRAPH(I)%IPTRS(0)) + &
                                    R*DATA%GRAPH(I)%RVALS(0)
            RRES3(DATA%GRAPH(I)%IPTRS(1)) = RRES3(DATA%GRAPH(I)%IPTRS(1)) + &
                                    R*DATA%GRAPH(I)%RVALS(1)
          ELSE
            PC = DATA%GRAPH(I)%IPTRS(0)
            RRES3(PC) = RRES3(PC) + R*DATA%GRAPH(I)%RVALS(0)
          END IF
        END IF
      END DO
      IF (PACKED) THEN
        DO I = 1, J
          IF (I==J) THEN
            DF2(START_POINTER+I) = RRES3(I)/2.0_WP
          ELSE
            DF2(START_POINTER+I) = RRES3(I)
          END IF
        END DO
        START_POINTER = START_POINTER + J
      ELSE
        DO I = 1, J
          DF2(I+((J-1)*DATA%SIZE_X)) = RRES3(I)
          DF2(J+((I-1)*DATA%SIZE_X)) = RRES3(I)
        END DO
      END IF
    END DO
    DEALLOCATE (RRES,RRES2,RRES3,STAT=STAT)
  END SUBROUTINE GETHES
  SUBROUTINE GRAD0(A,GRAD,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: GRAD
    INTEGER, INTENT (OUT) :: ERROR
    REAL (WP) X1(1)
    CALL GRAD1(A,X1,ERROR)
    GRAD = X1(1)
  END SUBROUTINE GRAD0
  SUBROUTINE GRAD1(A,GRAD,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: GRAD(:)
    INTEGER, INTENT (OUT) :: ERROR
    TYPE(AD02_DATA), POINTER :: DATA
    ERROR = 0
    GRAD = 0.0_WP
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    ELSE
      DATA => A%DATA
      IF (DATA%LEVEL==0) THEN
        ERROR = 4
      ELSE IF (DATA%SIZE_X/=SIZE(GRAD)) THEN
        ERROR = 5
      END IF
    END IF
    IF(ERROR>0)RETURN
    CALL GETDER(DATA,A%P,GRAD)
  END SUBROUTINE GRAD1
  SUBROUTINE HESSIAN0(A,HESSIAN,ERROR,GRAD)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: HESSIAN
    INTEGER, INTENT (OUT) :: ERROR
    REAL (WP), OPTIONAL, INTENT (OUT) :: GRAD
    REAL (WP) :: H1(1,1), G1(1)
    IF (PRESENT(GRAD)) THEN
      CALL HESSIAN1(A,H1,ERROR,G1)
      IF (ERROR>0) RETURN
      HESSIAN = H1(1,1)
      GRAD = G1(1)
    ELSE
      CALL HESSIAN1(A,H1,ERROR)
      IF (ERROR>0) RETURN
      HESSIAN = H1(1,1)
    END IF
  END SUBROUTINE HESSIAN0
  SUBROUTINE HESSIAN1(A,HESSIAN,ERROR,GRAD)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: HESSIAN(:,:)
    INTEGER, INTENT (OUT) :: ERROR
    REAL (WP), OPTIONAL, INTENT (OUT) :: GRAD(:)
    TYPE(AD02_DATA), POINTER :: DATA
    HESSIAN = 0.0_WP
    ERROR = 0
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    ELSE
      DATA => A%DATA
      IF (DATA%LEVEL<2) THEN
        ERROR = 4
      ELSE IF (SIZE(HESSIAN,1)/=DATA%SIZE_X .OR. &
             SIZE(HESSIAN,2)/=DATA%SIZE_X) THEN
        ERROR = 6
      ELSE IF (PRESENT(GRAD)) THEN
        IF (DATA%SIZE_X/=SIZE(GRAD)) ERROR = 5
      END IF
    END IF
    IF(ERROR>0)RETURN
    CALL GETHES(DATA,A%P,HESSIAN,DATA%SIZE_X*DATA%SIZE_X,.FALSE.,GRAD)
  END SUBROUTINE HESSIAN1
  SUBROUTINE INITIALIZE_DATA(DATA,ERROR)
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER STAT
    ALLOCATE (DATA,STAT=STAT)
    IF (STAT/=0) THEN
       ERROR = 3
       RETURN
    END IF
    ALLOCATE(DATA%FLAGS(40),STAT=STAT)
    IF (STAT/=0) THEN
       ERROR = 3
       RETURN
    END IF
    DATA%FLAGS = 0
    DATA%MAX_CASE = DATA%MAX_CASE + 1
    DATA%CASE = DATA%MAX_CASE
  END SUBROUTINE INITIALIZE_DATA
  SUBROUTINE INITIALIZE_11(DEGREE,X,VALUE,DATA,ERROR,FULL_THRESHOLD)
    INTEGER, INTENT (IN) :: DEGREE
    TYPE (AD02_REAL), INTENT (OUT) :: X(:)
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: FULL_THRESHOLD
    REAL (WP), INTENT (IN) :: VALUE(:)
    INTEGER STAT, I
    ERROR = 0
    IF (SIZE(X)/=SIZE(VALUE)) THEN
       ERROR = 5
       RETURN
    ELSE IF (DEGREE<0 .OR. DEGREE>2) THEN
       ERROR = 4
       RETURN
    END IF
    IF(.NOT.ASSOCIATED(DATA)) THEN
       ALLOCATE (DATA,STAT=STAT)
       IF (STAT/=0) THEN
          ERROR = 3
          RETURN
       END IF
    ELSE IF (DATA%CASE==-1) THEN
       ALLOCATE (DATA,STAT=STAT)
       IF (STAT/=0) THEN
          ERROR = 3
          RETURN
       END IF
    END IF
    IF(.NOT.ASSOCIATED(DATA%FLAGS)) THEN
       ALLOCATE(DATA%FLAGS(40),STAT=STAT)
       IF (STAT/=0) THEN
          ERROR = 3
          RETURN
       END IF
       DATA%FLAGS = 0
    END IF
    DATA%MAX_CASE = DATA%MAX_CASE + 1
    DATA%CASE = DATA%MAX_CASE
    DO I = 1,SIZE(X)
      X(I)%DATA => DATA
      X(I)%CASE = DATA%CASE
    END DO
    DATA%SIZE_X = SIZE(X)
    DATA%LEVEL = DEGREE
    IF (PRESENT(FULL_THRESHOLD)) I = FULL_THRESHOLD
    LN10 = LOG(10.0_WP)
      IF (DATA%MAX_NODES<=0) THEN
        DATA%MAX_NODES = INIT_MAX_NODES
        ALLOCATE (DATA%GRAPH(DATA%MAX_NODES),STAT=STAT)
        IF (STAT/=0) THEN
          ERROR = 3
          RETURN
        END IF
      END IF
      IF (DEGREE==2) THEN
        IF (DATA%MAX_NODES2/=DATA%MAX_NODES) THEN
          DATA%MAX_NODES2 = DATA%MAX_NODES
          IF (ASSOCIATED(DATA%DER2)) DEALLOCATE (DATA%DER2)
          ALLOCATE (DATA%DER2(0:2,DATA%MAX_NODES),STAT=STAT)
          IF (STAT/=0) THEN
            ERROR = 3
            RETURN
          END IF
        END IF
      END IF
      DATA%NUM_NODES = 1
      DATA%LEVEL = DEGREE
      DO I = 1, DATA%SIZE_X
        X(I)%P = I
        DATA%GRAPH(DATA%NUM_NODES)%RVAL = VALUE(I)
        DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = 0.0_WP
        DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
        DATA%GRAPH(DATA%NUM_NODES)%ONUM = 0
        DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = 1
        DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
        IF (DATA%LEVEL==2)  DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END DO
  END SUBROUTINE INITIALIZE_11
  SUBROUTINE INITIALIZE_10(DEGREE,X,VALUE,DATA,ERROR,FULL_THRESHOLD)
    INTEGER, INTENT (IN) :: DEGREE
    TYPE (AD02_REAL), INTENT (OUT) :: X(:)
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: FULL_THRESHOLD
    REAL (WP), INTENT (IN) :: VALUE
    REAL (WP), DIMENSION (SIZE(X)) :: VAL
    VAL = VALUE
    CALL INITIALIZE_11(DEGREE,X,VAL,DATA,ERROR,FULL_THRESHOLD)
  END SUBROUTINE INITIALIZE_10
  SUBROUTINE INITIALIZE_0(DEGREE,X,VALUE,DATA,ERROR,FULL_THRESHOLD)
    INTEGER, INTENT (IN) :: DEGREE
    TYPE (AD02_REAL), INTENT (OUT) :: X
    REAL (WP), INTENT (IN) :: VALUE
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: FULL_THRESHOLD
    REAL (WP) VAL(1)
    TYPE (AD02_REAL) :: A1(1)
    VAL(1) = VALUE
    CALL INITIALIZE_11(DEGREE,A1,VAL,DATA,ERROR,FULL_THRESHOLD)
    X = A1(1)
  END SUBROUTINE INITIALIZE_0
  SUBROUTINE MAKE_TEMP(A)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    A%CASE = -ABS(A%CASE)
  END SUBROUTINE MAKE_TEMP
  SUBROUTINE REQMEM_NODES(DATA)
    TYPE (AD02_DATA), POINTER :: DATA
    TYPE (NODE), ALLOCATABLE :: TEMP1(:)
    REAL (WP), ALLOCATABLE :: TEMP2(:,:)
    INTEGER STAT
    ALLOCATE (TEMP1(DATA%MAX_NODES),STAT=STAT)
    IF (STAT/=0) THEN
      CALL ERROR_HANDLER(DATA,ALLOC_ERR)
      RETURN
    END IF
    TEMP1 = DATA%GRAPH
    DEALLOCATE (DATA%GRAPH)
    ALLOCATE (DATA%GRAPH(DATA%MAX_NODES*2),STAT=STAT)
    IF (STAT/=0) THEN
      CALL ERROR_HANDLER(DATA,ALLOC_ERR)
      RETURN
    END IF
    DATA%GRAPH(1:DATA%MAX_NODES) = TEMP1
    DEALLOCATE (TEMP1)
    IF (DATA%LEVEL==2) THEN
      ALLOCATE (TEMP2(0:2,DATA%MAX_NODES),STAT=STAT)
      IF (STAT/=0) THEN
        CALL ERROR_HANDLER(DATA,ALLOC_ERR)
        RETURN
      END IF
      TEMP2 = DATA%DER2
      DEALLOCATE (DATA%DER2)
      ALLOCATE (DATA%DER2(0:2,DATA%MAX_NODES*2),STAT=STAT)
      DATA%MAX_NODES2 = DATA%MAX_NODES*2
      IF (STAT/=0) THEN
        CALL ERROR_HANDLER(DATA,ALLOC_ERR)
        RETURN
      END IF
      DATA%DER2(:,1:DATA%MAX_NODES) = TEMP2
      DEALLOCATE (TEMP2)
    END IF
    DATA%MAX_NODES = DATA%MAX_NODES*2
  END SUBROUTINE REQMEM_NODES
  SUBROUTINE UNARY_WARNING(FUN,A,PROC)
    TYPE (AD02_REAL), INTENT (OUT) :: FUN
    TYPE (AD02_REAL), INTENT (IN) :: A
    CHARACTER(*), OPTIONAL, INTENT(IN) :: PROC
    CALL ERROR_HANDLER(A%DATA,UNDEF_WARN,PROC)
    FUN%DATA => A%DATA
  END SUBROUTINE UNARY_WARNING
  LOGICAL FUNCTION UNDEFINED(X)
    TYPE (AD02_REAL), INTENT (IN) :: X
    IF(ASSOCIATED(X%DATA))THEN
      UNDEFINED = X%DATA%CASE==-1
    ELSE
      UNDEFINED = .TRUE.
    END IF
  END FUNCTION UNDEFINED
  SUBROUTINE UNDEFINE_REAL0(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    IF(PRESENT(DATA))then
       F%DATA => DATA
       IF(ASSOCIATED(DATA)) F%CASE = DATA%CASE
    ELSE
       NULLIFY(F%DATA)
       F%CASE = 0
    END IF
    F%P = -1
  END SUBROUTINE UNDEFINE_REAL0
  SUBROUTINE UNDEFINE_REAL1(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F)
      CALL AD02_UNDEFINE(F(I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL1
  SUBROUTINE UNDEFINE_REAL2(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,2)
      CALL AD02_UNDEFINE(F(:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL2
  SUBROUTINE UNDEFINE_REAL3(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,3)
      CALL AD02_UNDEFINE(F(:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL3
  SUBROUTINE UNDEFINE_REAL4(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,4)
      CALL AD02_UNDEFINE(F(:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL4
  SUBROUTINE UNDEFINE_REAL5(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,5)
      CALL AD02_UNDEFINE(F(:,:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL5
  SUBROUTINE UNDEFINE_REAL6(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,6)
      CALL AD02_UNDEFINE(F(:,:,:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL6
  SUBROUTINE UNDEFINE_REAL7(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,7)
      CALL AD02_UNDEFINE(F(:,:,:,:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL7
  SUBROUTINE USER(D,X,F,NAME)
    TYPE (AD02_REAL), INTENT (IN) :: X
    TYPE (AD02_REAL), INTENT (OUT) :: F
    REAL (WP), INTENT (IN) :: D(0:)
    CHARACTER (LEN=*), INTENT (IN), OPTIONAL :: NAME
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    F%DATA => DATA
    IF (X%P==-1) THEN
      IF (PRESENT(NAME)) THEN
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,NAME)
      ELSE
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AD02_USER')
      END IF
      F%P = -1
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      IF (PRESENT(NAME)) THEN
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,NAME)
      ELSE
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AD02_USER')
      END IF
      F%P = -1
    ELSE
      F%CASE = -DATA%CASE
      F%P = DATA%NUM_NODES
      IF (DATA%LEVEL==2) THEN
        DATA%GRAPH(DATA%NUM_NODES) = NODE(D(0),(/D(1),D(2)/),1,(/X%P,0/))
        DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
      ELSE
        DATA%GRAPH(DATA%NUM_NODES) = NODE(D(0),(/D(1),0.0_WP/),1,(/X%P,0/))
      END IF
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END SUBROUTINE USER
  SUBROUTINE VALUE_SCALAR(A,VALUE,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: VALUE
    INTEGER, INTENT (OUT) :: ERROR
    TYPE(AD02_DATA), POINTER :: DATA
    VALUE = 0.0_WP
    ERROR = 0
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    END IF
    IF(ERROR>0)RETURN
    DATA => A%DATA
    VALUE = DATA%GRAPH(A%P)%RVAL
  END SUBROUTINE VALUE_SCALAR
  SUBROUTINE VALUE_ARRAY(A,VALUE,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A(:)
    REAL (WP), INTENT (OUT) :: VALUE(:)
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER I,ERR
    ERROR = 0
    IF (SIZE(A)/=SIZE(VALUE)) ERROR = 5
    DO I = 1, MIN(SIZE(VALUE),SIZE(A))
       CALL VALUE_SCALAR(A(I),VALUE(I),ERR)
       IF(ERR>0)ERROR = ERR
    END DO
  END SUBROUTINE VALUE_ARRAY
END MODULE HSL_AD02_BACKWARD_DOUBLE
